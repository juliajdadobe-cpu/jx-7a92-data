{
  "Testing": [
    {
      "question": "Зачем Testcontainers и когда пригодится?",
      "answer": "Testcontainers позволяет поднимать реальные зависимости (PostgreSQL, Kafka, Redis и т.п.) в Docker прямо в тестах.\n\nПригодится, когда:\n- нужны интеграционные тесты с настоящей БД/брокером,\n- важно проверить миграции, SQL, транзакции, конфигурацию, реальные ограничения,\n- хочется воспроизводимости (в CI и локально одинаково).\n\nЭто чаще надежнее, чем мокать БД/брокер, но медленнее, чем unit-тесты."
    },
    {
      "question": "Как протестировать метод void — что именно проверять?",
      "answer": "Void-метод тестируют по *эффектам*:\n- изменилось ли состояние (поля, БД, коллекции),\n- вызваны ли нужные зависимости (через mocks/verifications),\n- отправлено ли событие/сообщение,\n- выброшено ли исключение при ошибке.\n\nТо есть проверяем observable behavior, а не «что внутри метода происходило по шагам»."
    },
    {
      "question": "Как протестировать метод, возвращающий void (побочные эффекты, верификация вызовов)?",
      "answer": "Проверяем побочные эффекты:\n- если метод должен что-то сохранить — проверяем результат в хранилище/объекте,\n- если метод должен вызвать зависимость — используем mock и `verify(...)` (Mockito),\n- если метод должен логировать/метрики — обычно проверяют косвенно (или через тестовые appenders),\n- если метод должен бросать исключение — `assertThrows`.\n\nГлавное — тестировать контракт метода."
    },
    {
      "question": "Какие слои приложения покрываешь тестами и где ставишь границы моков?",
      "answer": "Обычно:\n- unit-тесты для бизнес-логики (сервисов/утилит) с моками внешних зависимостей.\n- интеграционные тесты для интеграций: репозитории, SQL, конфигурация, взаимодействие с внешними системами.\n- e2e (реже) — через HTTP/контроллеры, чтобы проверить весь сценарий.\n\nГраницы моков обычно ставят на внешних ресурсах: сеть, БД, брокеры, файловая система. Внутреннюю логику лучше тестировать «настоящей»."
    },
    {
      "question": "Когда и как использовать Testcontainers для интеграционного тестирования?",
      "answer": "Используют, когда нужен настоящий сервис (например, Postgres) в тестах.\n\nКак:\n- объявить контейнер (`PostgreSQLContainer` и т.п.),\n- стартовать его на время тестов (обычно статически),\n- прокинуть параметры подключения в Spring (`@DynamicPropertySource` или properties),\n- прогнать тесты репозиториев/сервисов.\n\nВажно: контейнеры делают тесты медленнее, поэтому их держат как integration, а не как unit."
    },
    {
      "question": "Проводите ли нагрузочное тестирование? Кто и как его делает?",
      "answer": "Нагрузочное тестирование проводят, когда нужно проверить производительность/устойчивость (RPS, latency, ошибки, ресурсы).\n\nОбычно этим занимается команда совместно (разработчики + QA/DevOps), потому что нужны:\n- корректные сценарии и данные,\n- окружение, похожее на прод,\n- сбор метрик (CPU, память, GC, БД, очереди).\n\nИнструменты: k6, JMeter, Gatling. Главное — смотреть не только RPS, но и p95/p99 latency и ошибки."
    },
    {
      "question": "Разница unit и integration тестов.",
      "answer": "Unit-тест:\n- проверяет маленькую часть кода (метод/класс),\n- быстрый, изолированный,\n- внешние зависимости заменяются моками.\n\nIntegration-тест:\n- проверяет взаимодействие компонентов и инфраструктуры (БД, Spring context, конфиг),\n- медленнее,\n- меньше моков, больше реальных зависимостей.\n\nОба нужны: unit дают скорость, integration — уверенность."
    },
    {
      "question": "Стратегии тестирования в Spring (slice-тесты, @SpringBootTest).",
      "answer": "- Unit-тесты без Spring context (обычно самый частый слой).\n- Slice-тесты: поднимают часть контекста (например, `@WebMvcTest` для контроллеров, `@DataJpaTest` для репозиториев).\n- `@SpringBootTest`: поднимает почти весь контекст, подходит для интеграционных тестов сценариев.\n\nИдея: чем выше уровень теста, тем он медленнее — поэтому сначала unit, затем slice, затем full-context."
    },
    {
      "question": "Чем отличаются модульные (unit) тесты от интеграционных?",
      "answer": "Unit-тесты проверяют компонент в изоляции (моки вместо внешних зависимостей), быстрые и точные.\n\nИнтеграционные тесты проверяют, что компоненты реально работают вместе (Spring context, БД, миграции, конфиг), но они тяжелее и медленнее.\n\nUnit ловит ошибки логики, integration — ошибки интеграции."
    },
    {
      "question": "Чем отличаются unit-тесты от интеграционных и когда использовать Testcontainers?",
      "answer": "Unit — изоляция и моки, быстро.\nIntegration — реальные зависимости, медленнее.\n\nTestcontainers используют именно для integration-тестов, когда нужно проверить реальную БД/брокер/кэш и не хочется зависеть от локально установленного окружения.\n\nДля unit-тестов Testcontainers обычно избыточен."
    },
    {
      "question": "Что такое mocking/stubbing? Инструменты.",
      "answer": "Mocking — создание «поддельного» объекта и проверка взаимодействий: какие методы вызвали, сколько раз, с какими аргументами.\n\nStubbing — настройка поведения зависимости: «когда вызовут метод X, вернуть Y/бросить исключение».\n\nИнструменты: Mockito (чаще всего), также MockK (Kotlin), WireMock для HTTP, Testcontainers для реальных зависимостей."
    }
  ]
}
