{
  "Java Core": [
    {
      "question": "Что такое LTS в контексте Java и что это означает для разработчиков?",
      "answer": "LTS (Long-Term Support) — это версии Java с длительной поддержкой: регулярные обновления безопасности и багфиксы в течение нескольких лет. Для разработчиков это означает более стабильную платформу в проде: меньше риск внезапных несовместимостей и проще планировать апгрейды. Обычно в компаниях выбирают LTS для продакшена, а non-LTS — чтобы быстрее пробовать новые фичи."
    },
    {
      "question": "Аргументы в Java передаются по значению или по ссылке? Объясни на примерах с примитивом и массивом.",
      "answer": "В Java всё передаётся ТОЛЬКО по значению. Для примитивов копируется само значение (int, boolean и т.д.), поэтому изменения параметра внутри метода не влияют на переменную снаружи. Для объектов/массивов копируется значение ссылки (адрес/указатель): ты можешь менять содержимое массива через эту ссылку, но если внутри метода присвоить параметру новый массив, внешняя ссылка не изменится."
    },
    {
      "question": "В чём отличие примитивных и ссылочных типов в Java?",
      "answer": "Примитивы (int, long, boolean и т.д.) хранят само значение и не имеют методов. Ссылочные типы (объекты, массивы, String) хранят ссылку на объект в куче, могут быть null и имеют методы/поля. Примитивы обычно дешевле по памяти/скорости, ссылочные дают гибкость (ООП)."
    },
    {
      "question": "В чём разница между JDK и JRE?",
      "answer": "JRE (Java Runtime Environment) — это среда для запуска Java-приложений (JVM + библиотеки). JDK (Java Development Kit) включает JRE и инструменты разработчика: компилятор javac, javadoc, jar и т.д. Разработчику нужен JDK, пользователю для запуска — достаточно рантайма (сейчас чаще ставят JDK везде)."
    },
    {
      "question": "Для чего нужен компилятор javac и во что он преобразует исходный код?",
      "answer": "javac компилирует исходники .java в байткод .class. Этот байткод выполняется JVM (интерпретация + JIT-компиляция «горячих» участков в машинный код). То есть javac не делает «exe» напрямую — он готовит байткод для виртуальной машины."
    },
    {
      "question": "Для чего нужен Reflection API?",
      "answer": "Reflection позволяет во время выполнения получать информацию о классах/методах/полях и взаимодействовать с ними динамически (создать объект по имени класса, вызвать метод, прочитать поле). Это основа многих фреймворков (Spring, ORM): они сканируют аннотации, строят бин-граф, делают маппинг. Минусы: медленнее, ломает инкапсуляцию и сложнее для поддержки."
    },
    {
      "question": "Для чего нужны аннотации? Как ограничить место применения (Target)?",
      "answer": "Аннотации — это метаданные для компилятора/инструментов/рантайма: валидация, DI, сериализация, маппинг и т.п. Ограничить, где аннотацию можно ставить, помогает @Target: например TYPE (класс), METHOD, FIELD, PARAMETER и т.д. Если @Target не задан, аннотацию можно применить в более широких местах, что часто нежелательно."
    },
    {
      "question": "Есть ли в Java беззнаковые (unsigned) типы? Какие?",
      "answer": "В Java нет отдельных примитивов unsigned (кроме char, который фактически 16-бит без знака). Но есть методы для работы «как unsigned»: Integer.toUnsignedString, Integer.compareUnsigned, Long.divideUnsigned и т.д. Также можно использовать более широкий тип (например, хранить unsigned int в long) или BigInteger, если нужно совсем большое."
    },
    {
      "question": "Жизненный цикл сервлета: какие три метода и их назначение? (init, service, destroy)",
      "answer": "init() вызывается один раз при создании сервлета контейнером: инициализация ресурсов. service() вызывается на каждый запрос (внутри обычно маршрутизация на doGet/doPost). destroy() вызывается при остановке/выгрузке сервлета: освобождение ресурсов. Важно: один экземпляр сервлета обслуживает много запросов."
    },
    {
      "question": "Зачем нужны классы-обёртки примитивов и где они необходимы?",
      "answer": "Обёртки (Integer, Long, Boolean и т.д.) нужны, когда требуется объект: коллекции (List<Integer>), дженерики, рефлексия, nullable значения (null вместо «нет значения»). Они участвуют в автоупаковке/распаковке (autoboxing/unboxing). Минус — больше памяти и возможные лишние аллокации, поэтому в горячем коде примитивы предпочтительнее."
    },
    {
      "question": "К каким конструкциям применим модификатор static (поля, методы, классы, блоки и т. п.)?",
      "answer": "static применим к полям (одно на класс), методам (вызов без объекта), вложенным классам (static nested class), блокам инициализации (static { ... }), импортам (import static ...). К top-level классу static применить нельзя. static означает принадлежность к классу, а не к конкретному объекту."
    },
    {
      "question": "Как в новых версиях Java удобно создавать неизменяемые объекты (каким механизмом)?",
      "answer": "Для моделей данных удобны record (Java 16+): компактный синтаксис и неизменяемые поля по умолчанию (final). Для коллекций есть фабрики List.of/Set.of/Map.of и Collectors.toUnmodifiableList/Set/Map — они создают неизменяемые коллекции. Также остаётся классический подход: final поля + без сеттеров + defensive copy для мутабельных полей."
    },
    {
      "question": "Как в Java представляются отрицательные целые числа (какой код)?",
      "answer": "Отрицательные целые числа представлены в дополнительном коде (two’s complement). Это упрощает арифметику на уровне процессора: сложение/вычитание работают одинаково для положительных и отрицательных. Старший бит — знак, а диапазон, например у int: от −2^31 до 2^31−1."
    },
    {
      "question": "Как выбрать между конкатенацией строк, StringBuilder и String.format() в разных сценариях?",
      "answer": "Одна-две конкатенации через + в обычном коде — нормально (компилятор часто превратит в StringBuilder). В циклах и при множественных склейках — лучше StringBuilder (эффективнее по памяти/скорости). String.format удобен для читаемости и форматирования (числа, выравнивание), но обычно тяжелее по производительности — его лучше не использовать в горячих местах."
    },
    {
      "question": "Как гарантированно получить строку из пула?",
      "answer": "Литералы строк попадают в String Pool автоматически. Если у тебя строка создана динамически (new String или из данных), можно вызвать intern(): он вернёт ссылку на строку из пула с тем же содержимым (или добавит туда). intern полезен редко: может экономить память при огромном количестве повторяющихся строк, но увеличивает нагрузку на пул."
    },
    {
      "question": "Как запустить виртуальную машину Java из командной строки?",
      "answer": "Обычно запускают командой java: например, java -version для проверки, или java -cp <classpath> com.example.Main для запуска класса с main(). Для jar: java -jar app.jar. Важные параметры: -cp/-classpath, системные свойства -Dkey=value, параметры памяти (-Xms/-Xmx) при необходимости."
    },
    {
      "question": "Как избежать деградации при конкатенации строк в цикле? Чем StringBuilder отличается от StringBuffer?",
      "answer": "Конкатенация через + в цикле создаёт много временных String (иммутабельность), что ведёт к лишним аллокациям и GC. Решение — использовать StringBuilder и добавлять через append(). StringBuffer похож, но синхронизирован (потокобезопасен), поэтому медленнее; в одиночном потоке почти всегда выбирают StringBuilder."
    },
    {
      "question": "Как работает механизм varargs: во что трансформируется и какие накладные расходы/ограничения есть?",
      "answer": "varargs (например, foo(String... args)) компилятор превращает в массив (String[]). При вызове создаётся массив (иногда лишняя аллокация), поэтому в горячих местах это может быть затратнее. Ограничение: varargs должен быть последним параметром метода, и возможны предупреждения с дженериками (heap pollution)."
    },
    {
      "question": "Как сделать аннотацию доступной во время выполнения (Retention)? Какие уровни retention существуют?",
      "answer": "Нужно поставить @Retention(RetentionPolicy.RUNTIME) — тогда аннотацию можно прочитать через reflection во время выполнения. Уровни: SOURCE (только в исходниках, компилятор выкидывает), CLASS (в байткоде, но обычно не доступно через reflection), RUNTIME (доступно в рантайме)."
    },
    {
      "question": "Как сервлет обрабатывает многопоточность: по одному потоку на запрос?",
      "answer": "Да, типично контейнер берёт поток из пула и вызывает service() для каждого запроса. Один экземпляр сервлета обслуживает много запросов параллельно, поэтому нельзя хранить запрос-специфичное состояние в полях сервлета (это будет shared state). Нужно использовать локальные переменные, ThreadLocal или передавать данные через параметры/контекст запроса."
    },
    {
      "question": "Как устроен StringBuilder под капотом?",
      "answer": "StringBuilder хранит изменяемый буфер символов (обычно char[] или byte[] в современных реализациях) и текущую длину. append() дописывает в буфер, а при нехватке места буфер расширяется (обычно с запасом), поэтому вставки амортизированно эффективны. toString() создаёт новый String на основе содержимого буфера."
    },
    {
      "question": "Какие классификации типов данных есть в Java? Перечисли основные типы.",
      "answer": "Основная классификация: примитивные типы и ссылочные типы. Примитивные: целочисленные (byte, short, int, long), вещественные (float, double), логический (boolean), символьный (char). Ссылочные: классы (в т.ч. String), интерфейсы, массивы, enum, record и т.д."
    },
    {
      "question": "Какие ключевые методы есть у Object (toString, equals, hashCode) и для чего они?",
      "answer": "toString() — строковое представление объекта (для логов/дебага). equals() — логическое сравнение объектов (обычно по значимым полям). hashCode() — числовой хеш для хеш-коллекций (HashMap/HashSet): если equals() истинно, hashCode() обязан совпасть. Часто их переопределяют вместе."
    },
    {
      "question": "Какие новые фичи в Java вы знаете/используете (например, var, structured concurrency)?",
      "answer": "Примеры: var (локальная типизация), record для data-моделей, switch expressions, text blocks, sealed classes, pattern matching (instanceof/switch), улучшения GC, виртуальные потоки (Project Loom) в новых версиях, и structured concurrency (группировка задач и их отмена/ожидание как единое целое). На собесе достаточно назвать 5–7 и кратко зачем."
    },
    {
      "question": "Какими методами и контрактами обладает базовый класс Object?",
      "answer": "Ключевые: equals/hashCode (контракт сравнения), toString, getClass, clone (осторожно, спорный API), wait/notify/notifyAll (монитор и синхронизация), finalize (устарел/не рекомендован). Важно понимать, что wait/notify работают только внутри synchronized на том же объекте, а finalize сейчас считается плохой практикой."
    },
    {
      "question": "Какими функциональными интерфейсами пользуетесь? Примеры (Function, BiFunction, Supplier, Consumer и т.д.)",
      "answer": "Function<T,R> — преобразование T→R, BiFunction<T,U,R> — два входа, Supplier<T> — отдаёт значение без входов, Consumer<T> — принимает и «потребляет» без результата, Predicate<T> — проверка boolean, UnaryOperator<T> — T→T, Comparator<T> — сравнение для сортировки. Они активно используются в Stream API, Optional, коллекциях и коллбэках."
    },
    {
      "question": "Каковы издержки иммутабельности строк и как их обходят (builder/buffer)?",
      "answer": "String неизменяемый: любая «модификация» создаёт новый объект, что в циклах приводит к множеству аллокаций и нагрузке на GC. Обход: использовать StringBuilder/StringBuffer для накопления, а потом один раз делать toString(). Ещё варианты: форматирование через Formatter/String.format (но обычно тяжелее) и использование join/collect."
    },
    {
      "question": "Какой ключевой default-метод появился в Java 8 (в Collection)?",
      "answer": "В Java 8 в интерфейсах появились default-методы, чтобы добавлять функциональность без поломки старых реализаций. В Collection/Iterable популярные: forEach (Iterable), removeIf (Collection), spliterator, а также stream()/parallelStream() (в Collection). Самый «поворотный» для стиля кода — stream()."
    },
    {
      "question": "Когда выбирать Comparable, а когда — Comparator? Какой паттерн реализует Comparator?",
      "answer": "Comparable задаёт «естественный» порядок внутри самого класса (implements Comparable) — один основной порядок. Comparator нужен, когда сортировок может быть много (по имени, по дате, по рейтингу) или когда нельзя/не хочется менять класс. Comparator — это по сути паттерн Strategy: алгоритм сравнения можно подставлять снаружи."
    },
    {
      "question": "Когда выбирать StringBuilder vs StringBuffer?",
      "answer": "StringBuilder — по умолчанию для одного потока: быстрее, без синхронизации. StringBuffer — когда один и тот же экземпляр реально используется конкурентно из нескольких потоков и нужна встроенная синхронизация (сейчас это редко). В большинстве случаев потокобезопасность решают иначе, поэтому чаще выбирают StringBuilder."
    },
    {
      "question": "Когда два объекта могут иметь одинаковый hashCode(), но быть не равны по equals()?",
      "answer": "Это нормальная ситуация: hashCode — не уникальный идентификатор, а хеш, возможны коллизии. В HashMap сначала выбирается бакет по hashCode, а затем внутри бакета проверяется equals. Главное правило обратное: если equals() == true, то hashCode() обязан быть одинаковым."
    },
    {
      "question": "Когда и зачем в Java добавили default-методы в интерфейсах?",
      "answer": "Default-методы добавили в Java 8, чтобы развивать стандартные интерфейсы (например, Collection/Iterable) без поломки всех существующих реализаций. Если бы добавили абстрактный метод — старые классы не скомпилировались бы. Default даёт реализацию по умолчанию и сохраняет обратную совместимость."
    },
    {
      "question": "Когда следует переопределять toString, equals, hashCode, compareTo?",
      "answer": "toString — когда объект участвует в логах/дебаге и хочется понятное представление. equals/hashCode — когда логическое равенство не равно ссылочному (например, сущности по id, value object по полям) и объект будет ключом/элементом в HashMap/HashSet. compareTo — когда у типа есть естественный порядок и он будет использоваться в сортировках/TreeSet/TreeMap."
    },
    {
      "question": "Контракт equals/hashCode: почему важен и что нарушится при его несоблюдении?",
      "answer": "Если equals считает объекты равными, но hashCode разный — хеш-коллекции ломаются: HashSet может хранить «дубликаты», HashMap не найдёт ключ, хотя он «равен». Коллекции зависят от того, что равные объекты попадают в один и тот же бакет. Поэтому equals и hashCode должны быть согласованы."
    },
    {
      "question": "Контракт equals/hashCode: что он гарантирует?",
      "answer": "Гарантия: если a.equals(b) == true, то a.hashCode() == b.hashCode(). Обратное не требуется: одинаковый hashCode не означает equals. Также equals должен быть рефлексивным, симметричным, транзитивным, консистентным и возвращать false при сравнении с null."
    },
    {
      "question": "Может ли абстрактный класс быть final? А абстрактные методы — какими могут/не могут быть?",
      "answer": "Абстрактный класс не может быть final: final запрещает наследование, а abstract подразумевает, что класс нужно наследовать и реализовать. Абстрактный метод не может быть final (нельзя одновременно требовать override и запрещать его), static (не переопределяется полиморфно) и private (его нельзя переопределить). Обычно abstract методы имеют protected/public."
    },
    {
      "question": "Может ли класс быть static?",
      "answer": "Top-level класс (отдельный файл) не может быть static. Static может быть только вложенный класс (static nested class) внутри другого класса. Такой класс не держит ссылку на внешний объект и создаётся как обычный: new Outer.Nested()."
    },
    {
      "question": "Можно ли вызвать приватный метод/изменить приватное поле? Что нужно сделать (например, setAccessible)?",
      "answer": "Да, через Reflection можно получить Method/Field и вызвать setAccessible(true), после чего читать/менять приватное. Но это ломает инкапсуляцию и может быть ограничено модульной системой (Java 9+) и настройками безопасности. В проде так делать стоит только когда нет нормальной альтернативы (например, в фреймворках/тестах)."
    },
    {
      "question": "Можно ли класс объявить final и abstract одновременно? Почему?",
      "answer": "Нельзя. abstract означает «нужно наследовать и реализовать», final означает «наследовать запрещено». Это логическое противоречие, поэтому компилятор не даст так сделать."
    },
    {
      "question": "Можно ли наследоваться от String? Почему?",
      "answer": "Нельзя, потому что String объявлен как final. Это сделано ради безопасности и предсказуемости (например, в ClassLoader, security, работе с хешами и пулом строк). Если бы можно было наследовать, можно было бы нарушать ожидания о неизменяемости и поведении строки."
    },
    {
      "question": "Можно ли переопределить статический метод? Чем override отличается от hiding?",
      "answer": "Статический метод нельзя переопределить в смысле полиморфизма. Его можно «скрыть» (hiding): если в наследнике объявить static метод с той же сигнатурой, выбор будет зависеть от типа ссылки на этапе компиляции, а не от реального объекта. Override — это динамический полиморфизм (виртуальные методы), hiding — статическая привязка."
    },
    {
      "question": "Можно ли понижать модификатор доступа при override?",
      "answer": "Нет. При переопределении нельзя делать доступ более строгим (например, было public → стало protected/private). Иначе код, который ожидает доступность метода через базовый тип, сломается. Разрешено только сохранять или расширять доступ (protected → public)."
    },
    {
      "question": "Можно ли при переопределении метода сузить/расширить модификатор доступа? Какой принцип ООП нарушим при сужении?",
      "answer": "Расширять доступ можно (protected → public), сужать нельзя. При сужении нарушается подстановочность (LSP — принцип Барбары Лисков): объект наследника должен быть взаимозаменяем с базовым типом без сюрпризов."
    },
    {
      "question": "Можно ли свой класс использовать в for-each? Что нужно реализовать (Iterable/Iterator)?",
      "answer": "Да. Нужно, чтобы класс реализовал Iterable<T> и возвращал Iterator<T> в методе iterator(). Либо можно вернуть iterator() из какого-то внутреннего контейнера. for-each под капотом вызывает iterator(), затем hasNext()/next()."
    },
    {
      "question": "Можно ли сузить или расширить модификатор доступа при переопределении метода? Почему?",
      "answer": "Расширить можно, сузить нельзя. Почему: при вызове через ссылку базового типа компилятор/контракт ожидают, что метод доступен как в базовом классе. Если сделать доступ уже — получится ситуация, где «наследник хуже базового», а так быть не должно."
    },
    {
      "question": "Обязательно ли всегда закрывать поля? Можно ли организовать инкапсуляцию на уровне пакета? Какой модификатор доступа используется?",
      "answer": "Чаще всего поля делают private, чтобы контролировать доступ через методы/валидацию. Но инкапсуляцию можно делать и на уровне пакета: модификатор по умолчанию (package-private, без слова) — доступен только внутри пакета. Это удобно, например, для внутренней доменной модели/модулей."
    },
    {
      "question": "Переопределение vs перегрузка. Перегружается ли конструктор?",
      "answer": "Перегрузка (overload) — один и тот же метод/конструктор, но разные параметры (в одном классе). Переопределение (override) — замена реализации метода в наследнике с той же сигнатурой. Конструкторы НЕ переопределяются, но перегружаются (можно иметь несколько конструкторов с разными параметрами)."
    },
    {
      "question": "Перечисли и объясни принципы ООП: инкапсуляция, наследование, полиморфизм.",
      "answer": "Инкапсуляция — скрываем внутренности, даём понятный публичный API, защищаем инварианты. Наследование — переиспользование и расширение поведения через «is-a» (но использовать аккуратно). Полиморфизм — один интерфейс, разные реализации: код работает с абстракцией (интерфейс/базовый тип), а конкретное поведение определяется реальным объектом."
    },
    {
      "question": "Перечисли примитивные типы.",
      "answer": "byte, short, int, long, float, double, char, boolean."
    },
    {
      "question": "Почему в Java нет множественного наследования? Как добиваться похожего эффекта?",
      "answer": "Чтобы избежать проблем вроде «ромба» (неоднозначность, какой метод/поле брать) и усложнения модели. Похожий эффект достигают через интерфейсы (в т.ч. default-методы), композицию (держим поле другого класса и делегируем) и паттерны (Strategy/Decorator)."
    },
    {
      "question": "Почему конкатенация строк в цикле — анти-паттерн? Чем заменить?",
      "answer": "String иммутабелен: каждый + создаёт новый объект и копирует данные, в цикле это превращается в лавину аллокаций и нагрузку на GC. Заменять нужно на StringBuilder (append), либо собирать через join/collect, либо писать в поток/буфер по месту."
    },
    {
      "question": "Почему конкатенация строк в цикле — антипаттерн?",
      "answer": "Потому что приводит к множеству временных String и копированию символов на каждом шаге. Итог — лишние аллокации, тормоза и GC. Правильный инструмент — StringBuilder."
    },
    {
      "question": "Почему нельзя использовать оператор == для сравнения объектов в Java?",
      "answer": "== сравнивает ссылки (один и тот же объект в памяти), а не содержимое. Для логического сравнения по данным используется equals(). Исключение: иногда специально нужно проверить «тот же самый объект» — тогда == как раз правильный."
    },
    {
      "question": "Почему нельзя сравнивать объекты оператором ==?",
      "answer": "Потому что == проверяет идентичность ссылок, а не равенство по значению. Два разных объекта с одинаковыми полями будут false через ==, но могут быть true через equals()."
    },
    {
      "question": "Почему объекты нельзя сравнивать через ==?",
      "answer": "Потому что == не знает «смысл» равенства для объекта, он сравнивает адреса/ссылки. Смысл равенства задаёт equals() (и вместе с ним контракт hashCode())."
    },
    {
      "question": "Почему предпочтительнее использовать коллекции/дженерики вместо массивов?",
      "answer": "Коллекции гибче: динамический размер, богатый API (add/remove/contains), удобные алгоритмы, потокобезопасные варианты и т.п. Дженерики дают типобезопасность без кастов. Массивы проще и быстрее в некоторых задачах, но менее удобны и хуже масштабируются по функциональности."
    },
    {
      "question": "Почему при переопределении equals() обычно нужно переопределять и hashCode()?",
      "answer": "Потому что хеш-коллекции (HashMap/HashSet) используют hashCode для выбора бакета. Если equals переопределили, а hashCode оставили «как был», то равные объекты могут иметь разные hashCode → коллекции начнут вести себя неправильно (не найдёт ключ, появятся «дубликаты»)."
    },
    {
      "question": "Почему строки нельзя сравнивать через ==? Какие виды сравнения есть? Что сравнивает String.equals()?",
      "answer": "== у строк сравнивает ссылки (иногда случайно совпадёт из-за пула строк, но это ловушка). Виды сравнения: 1) ссылочное (==) — один объект или нет; 2) по содержимому (equals) — одинаковые символы; 3) лексикографическое сравнение (compareTo). String.equals() сравнивает именно последовательность символов."
    },
    {
      "question": "Почему Comparator удобен как функциональный интерфейс и как это влияет на способы сортировки?",
      "answer": "Comparator — функциональный интерфейс, поэтому его удобно задавать лямбдой/метод-ссылкой. Это делает сортировки гибкими: можно быстро описывать порядок (Comparator.comparing(...).thenComparing(...)), комбинировать критерии, не меняя сам класс модели."
    },
    {
      "question": "Почему String иммутабелен и какие плюсы это даёт (потоки, хеши, безопасность)?",
      "answer": "Иммутабельность упрощает жизнь: String безопасен для многопоточности (его нельзя изменить), безопасен для использования как ключ в HashMap (hashCode стабилен), подходит для security-сценариев (например, пути/параметры не «подменят» после проверки). Также это позволяет оптимизации вроде String Pool."
    },
    {
      "question": "Почему String иммутабельный и какие плюсы это даёт?",
      "answer": "Потому что так проще гарантировать безопасность и предсказуемость. Плюсы: потокобезопасность «бесплатно», стабильный hashCode, возможность пула строк, меньше багов из-за неожиданных изменений значения."
    },
    {
      "question": "Почему String immutable и final?",
      "answer": "immutable — чтобы строку нельзя было менять (безопасность, хеши, потоки, пул). final — чтобы никто не мог наследованием «сломать» это поведение (например, переопределить методы так, чтобы объект внезапно стал мутабельным или нарушал контракт)."
    },
    {
      "question": "Почему String immutable? Плюсы и минусы иммутабельности строк.",
      "answer": "Плюсы: потокобезопасность, стабильный hashCode, удобство как ключ, безопасность, String Pool. Минусы: при частых модификациях создаются новые объекты → лишние аллокации/GC. Поэтому для сборки текста используют StringBuilder/StringBuffer."
    },
    {
      "question": "Приведи примеры билдера в стандартной Java.",
      "answer": "StringBuilder / StringBuffer — классический builder для строк. Также: StringJoiner, Collectors.toMap/toList с накоплением, и в API NIO есть builder-подобные подходы (например, Path/URI часто собирают из частей). В целом «builder-стиль» часто встречается в fluent API (например, HttpClient/HttpRequest в новых Java)."
    },
    {
      "question": "Работает ли for-each без итератора? Как связаны Iterable и Iterator?",
      "answer": "for-each работает через итератор. Если объект реализует Iterable, цикл вызывает iterator() и получает Iterator. Затем по кругу вызывает hasNext() и next(). То есть без итератора по факту не работает (кроме массивов — у них отдельная поддержка компилятором)."
    },
    {
      "question": "Разница между интерфейсами Iterable и Iterator?",
      "answer": "Iterable — это «контейнер, по которому можно итерироваться» (имеет iterator()). Iterator — это «сам процесс обхода» (hasNext/next и часто remove). Один Iterable может создавать много разных Iterator (например, несколько обходов)."
    },
    {
      "question": "Разница создания строк: литерал vs new String(...)?",
      "answer": "Литерал \"abc\" попадает в String Pool, и одинаковые литералы обычно ссылаются на один объект. new String(\"abc\") почти всегда создаёт новый объект в куче (даже если такой текст уже есть в пуле), то есть это лишняя аллокация. Поэтому new String(...) почти никогда не нужен."
    },
    {
      "question": "Разница final, finally, finalize (и почему finalize не использовать).",
      "answer": "final — запрет изменить (переменную), запрет переопределить (метод), запрет наследовать (класс). finally — блок, который выполняется после try/catch (для уборки ресурсов), но лучше использовать try-with-resources. finalize — старый механизм «перед удалением объектом GC», не гарантирован по времени/вообще, медленный и признан плохой практикой (устарел)."
    },
    {
      "question": "Разница String, StringBuilder, StringBuffer и где какой использовать?",
      "answer": "String — неизменяемый, удобен как значение. StringBuilder — изменяемый, быстрый для сборки строк в одном потоке (циклы/append). StringBuffer — как Builder, но с синхронизацией (потокобезопаснее, но медленнее). В 99% случаев: String + StringBuilder."
    },
    {
      "question": "Реализуйте мини-Optional: дженерик-класс с value, методами map и filter (как в java.util.Optional).",
      "answer": "Идея: хранить value (может быть null, но лучше запретить и использовать отдельное состояние empty). map применяет функцию только если значение есть и возвращает новый Optional. filter оставляет значение только если predicate true, иначе возвращает empty. Важно: не вызывать функцию/предикат на empty и аккуратно обрабатывать null (обычно Optional.ofNullable для входа)."
    },
    {
      "question": "Чем отличается ссылочное сравнение от сравнения «по значению» и как это связано с методом equals()?",
      "answer": "Ссылочное сравнение (==) отвечает: это один и тот же объект? Сравнение по значению отвечает: данные эквивалентны? Для объектов «по значению» реализуют equals(). Поэтому: == для идентичности, equals для логического равенства."
    },
    {
      "question": "Чем отличаются final, finally и finalize?",
      "answer": "final — модификатор неизменности/запрета наследования/override. finally — блок после try/catch для гарантированной уборки (но лучше try-with-resources). finalize — устаревший метод «перед сборкой мусора», использовать не нужно."
    },
    {
      "question": "Чем отличаются StringBuilder и StringBuffer? Какой из них потокобезопасен?",
      "answer": "StringBuffer потокобезопасен (его методы синхронизированы), StringBuilder — нет, но быстрее. Если нет реальной конкурентной записи в один экземпляр — выбирай StringBuilder."
    },
    {
      "question": "Чем перегрузка отличается от переопределения?",
      "answer": "Перегрузка — разные сигнатуры в одном классе (выбор происходит на этапе компиляции). Переопределение — та же сигнатура в наследнике, другая реализация (выбор происходит в рантайме по реальному типу объекта)."
    },
    {
      "question": "Чем abstract класс отличается от interface?",
      "answer": "Абстрактный класс может хранить состояние (поля), иметь конструкторы и частичную реализацию, но наследоваться можно только от одного класса. Интерфейс — контракт: можно реализовать много интерфейсов, обычно без состояния (хотя есть default/static методы). На практике: интерфейс — для ролей/контрактов, абстрактный класс — для общего кода и состояния."
    },
    {
      "question": "Чем String отличается от StringBuilder и StringBuffer по назначению и потокобезопасности?",
      "answer": "String — значение, неизменяемый и потокобезопасен по природе. StringBuilder — для сборки строк, не потокобезопасен. StringBuffer — тоже для сборки, но потокобезопасен из-за синхронизации (часто это лишнее и медленнее)."
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации + «под капотом»?",
      "answer": "В обычном выражении компилятор часто сам использует StringBuilder. Но в цикле при + легко получить много временных объектов на каждой итерации. Явный StringBuilder даёт контроль и избегает лишних аллокаций, особенно при большом количестве append()."
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации строк через + в цикле?",
      "answer": "StringBuilder переиспользует один буфер и дописывает в него. Конкатенация через + создаёт новый String на каждой итерации и копирует данные, поэтому сильно проигрывает по памяти и скорости при больших объёмах."
    },
    {
      "question": "Что будет, если hashCode() всегда возвращает константу? Это корректно?",
      "answer": "Формально корректно (контракт equals/hashCode не нарушен), но очень плохо для производительности: все ключи попадут в один бакет HashMap/HashSet, и операции деградируют от O(1) к O(n) (или к дереву при определённых условиях). Итог — коллекции начнут «тормозить»."
    },
    {
      "question": "Что делает блок finally? Всегда ли нужен для закрытия ресурсов?",
      "answer": "finally выполняется после try/catch (даже при исключении), обычно для освобождения ресурсов. Но для ресурсов (файлы, сокеты, DB) лучше try-with-resources: он надёжнее, короче и правильно обрабатывает suppressed exceptions. finally всё ещё полезен для логики «всегда сделать X»."
    },
    {
      "question": "Что делает intern()?",
      "answer": "intern() возвращает ссылку на строку из String Pool с тем же содержимым (или добавляет туда). Это может экономить память на повторяющихся строках, но использовать нужно осторожно: пул — общий ресурс, и излишний intern может навредить производительности/памяти."
    }
  ],
  "ООП": [
    {
      "question": "Что такое объект в ООП?",
      "answer": "Ответ будет добавлен позже."
    }
  ]
}
