{
  "Java Core": [
    {
      "question": "Что такое LTS в контексте Java и что это означает для разработчиков?",
      "answer": "LTS (Long-Term Support) — это версии Java с длительной поддержкой: регулярные обновления безопасности и багфиксы в течение нескольких лет. Для разработчиков это означает более стабильную платформу в проде: меньше риск внезапных несовместимостей и проще планировать апгрейды. Обычно в компаниях выбирают LTS для продакшена, а non-LTS — чтобы быстрее пробовать новые фичи."
    },
    {
      "question": "Аргументы в Java передаются по значению или по ссылке? Объясни на примерах с примитивом и массивом.",
      "answer": "В Java всё передаётся ТОЛЬКО по значению. Для примитивов копируется само значение (int, boolean и т.д.), поэтому изменения параметра внутри метода не влияют на переменную снаружи. Для объектов/массивов копируется значение ссылки (адрес/указатель): ты можешь менять содержимое массива через эту ссылку, но если внутри метода присвоить параметру новый массив, внешняя ссылка не изменится."
    },
    {
      "question": "В чём отличие примитивных и ссылочных типов в Java?",
      "answer": "Примитивы (int, long, boolean и т.д.) хранят само значение и не имеют методов. Ссылочные типы (объекты, массивы, String) хранят ссылку на объект в куче, могут быть null и имеют методы/поля. Примитивы обычно дешевле по памяти/скорости, ссылочные дают гибкость (ООП)."
    },
    {
      "question": "В чём разница между JDK и JRE?",
      "answer": "JRE (Java Runtime Environment) — это среда для запуска Java-приложений (JVM + библиотеки). JDK (Java Development Kit) включает JRE и инструменты разработчика: компилятор javac, javadoc, jar и т.д. Разработчику нужен JDK, пользователю для запуска — достаточно рантайма (сейчас чаще ставят JDK везде)."
    },
    {
      "question": "Для чего нужен компилятор javac и во что он преобразует исходный код?",
      "answer": "javac компилирует исходники .java в байткод .class. Этот байткод выполняется JVM (интерпретация + JIT-компиляция «горячих» участков в машинный код). То есть javac не делает «exe» напрямую — он готовит байткод для виртуальной машины."
    },
    {
      "question": "Для чего нужен Reflection API?",
      "answer": "Reflection позволяет во время выполнения получать информацию о классах/методах/полях и взаимодействовать с ними динамически (создать объект по имени класса, вызвать метод, прочитать поле). Это основа многих фреймворков (Spring, ORM): они сканируют аннотации, строят бин-граф, делают маппинг. Минусы: медленнее, ломает инкапсуляцию и сложнее для поддержки."
    },
    {
      "question": "Для чего нужны аннотации? Как ограничить место применения (Target)?",
      "answer": "Аннотации — это метаданные для компилятора/инструментов/рантайма: валидация, DI, сериализация, маппинг и т.п. Ограничить, где аннотацию можно ставить, помогает @Target: например TYPE (класс), METHOD, FIELD, PARAMETER и т.д. Если @Target не задан, аннотацию можно применить в более широких местах, что часто нежелательно."
    },
    {
      "question": "Есть ли в Java беззнаковые (unsigned) типы? Какие?",
      "answer": "В Java нет отдельных примитивов unsigned (кроме char, который фактически 16-бит без знака). Но есть методы для работы «как unsigned»: Integer.toUnsignedString, Integer.compareUnsigned, Long.divideUnsigned и т.д. Также можно использовать более широкий тип (например, хранить unsigned int в long) или BigInteger, если нужно совсем большое."
    },
    {
      "question": "Жизненный цикл сервлета: какие три метода и их назначение? (init, service, destroy)",
      "answer": "init() вызывается один раз при создании сервлета контейнером: инициализация ресурсов. service() вызывается на каждый запрос (внутри обычно маршрутизация на doGet/doPost). destroy() вызывается при остановке/выгрузке сервлета: освобождение ресурсов. Важно: один экземпляр сервлета обслуживает много запросов."
    },
    {
      "question": "Зачем нужны классы-обёртки примитивов и где они необходимы?",
      "answer": "Обёртки (Integer, Long, Boolean и т.д.) нужны, когда требуется объект: коллекции (List<Integer>), дженерики, рефлексия, nullable значения (null вместо «нет значения»). Они участвуют в автоупаковке/распаковке (autoboxing/unboxing). Минус — больше памяти и возможные лишние аллокации, поэтому в горячем коде примитивы предпочтительнее."
    },
    {
      "question": "К каким конструкциям применим модификатор static (поля, методы, классы, блоки и т. п.)?",
      "answer": "static применим к полям (одно на класс), методам (вызов без объекта), вложенным классам (static nested class), блокам инициализации (static { ... }), импортам (import static ...). К top-level классу static применить нельзя. static означает принадлежность к классу, а не к конкретному объекту."
    },
    {
      "question": "Как в новых версиях Java удобно создавать неизменяемые объекты (каким механизмом)?",
      "answer": "Для моделей данных удобны record (Java 16+): компактный синтаксис и неизменяемые поля по умолчанию (final). Для коллекций есть фабрики List.of/Set.of/Map.of и Collectors.toUnmodifiableList/Set/Map — они создают неизменяемые коллекции. Также остаётся классический подход: final поля + без сеттеров + defensive copy для мутабельных полей."
    },
    {
      "question": "Как в Java представляются отрицательные целые числа (какой код)?",
      "answer": "Отрицательные целые числа представлены в дополнительном коде (two’s complement). Это упрощает арифметику на уровне процессора: сложение/вычитание работают одинаково для положительных и отрицательных. Старший бит — знак, а диапазон, например у int: от −2^31 до 2^31−1."
    },
    {
      "question": "Как выбрать между конкатенацией строк, StringBuilder и String.format() в разных сценариях?",
      "answer": "Одна-две конкатенации через + в обычном коде — нормально (компилятор часто превратит в StringBuilder). В циклах и при множественных склейках — лучше StringBuilder (эффективнее по памяти/скорости). String.format удобен для читаемости и форматирования (числа, выравнивание), но обычно тяжелее по производительности — его лучше не использовать в горячих местах."
    },
    {
      "question": "Как гарантированно получить строку из пула?",
      "answer": "Литералы строк попадают в String Pool автоматически. Если у тебя строка создана динамически (new String или из данных), можно вызвать intern(): он вернёт ссылку на строку из пула с тем же содержимым (или добавит туда). intern полезен редко: может экономить память при огромном количестве повторяющихся строк, но увеличивает нагрузку на пул."
    },
    {
      "question": "Как запустить виртуальную машину Java из командной строки?",
      "answer": "Обычно запускают командой java: например, java -version для проверки, или java -cp <classpath> com.example.Main для запуска класса с main(). Для jar: java -jar app.jar. Важные параметры: -cp/-classpath, системные свойства -Dkey=value, параметры памяти (-Xms/-Xmx) при необходимости."
    },
    {
      "question": "Как избежать деградации при конкатенации строк в цикле? Чем StringBuilder отличается от StringBuffer?",
      "answer": "Конкатенация через + в цикле создаёт много временных String (иммутабельность), что ведёт к лишним аллокациям и GC. Решение — использовать StringBuilder и добавлять через append(). StringBuffer похож, но синхронизирован (потокобезопасен), поэтому медленнее; в одиночном потоке почти всегда выбирают StringBuilder."
    },
    {
      "question": "Как работает механизм varargs: во что трансформируется и какие накладные расходы/ограничения есть?",
      "answer": "varargs (например, foo(String... args)) компилятор превращает в массив (String[]). При вызове создаётся массив (иногда лишняя аллокация), поэтому в горячих местах это может быть затратнее. Ограничение: varargs должен быть последним параметром метода, и возможны предупреждения с дженериками (heap pollution)."
    },
    {
      "question": "Как сделать аннотацию доступной во время выполнения (Retention)? Какие уровни retention существуют?",
      "answer": "Нужно поставить @Retention(RetentionPolicy.RUNTIME) — тогда аннотацию можно прочитать через reflection во время выполнения. Уровни: SOURCE (только в исходниках, компилятор выкидывает), CLASS (в байткоде, но обычно не доступно через reflection), RUNTIME (доступно в рантайме)."
    },
    {
      "question": "Как сервлет обрабатывает многопоточность: по одному потоку на запрос?",
      "answer": "Да, типично контейнер берёт поток из пула и вызывает service() для каждого запроса. Один экземпляр сервлета обслуживает много запросов параллельно, поэтому нельзя хранить запрос-специфичное состояние в полях сервлета (это будет shared state). Нужно использовать локальные переменные, ThreadLocal или передавать данные через параметры/контекст запроса."
    },
    {
      "question": "Как устроен StringBuilder под капотом?",
      "answer": "StringBuilder хранит изменяемый буфер символов (обычно char[] или byte[] в современных реализациях) и текущую длину. append() дописывает в буфер, а при нехватке места буфер расширяется (обычно с запасом), поэтому вставки амортизированно эффективны. toString() создаёт новый String на основе содержимого буфера."
    },
    {
      "question": "Какие классификации типов данных есть в Java? Перечисли основные типы.",
      "answer": "Основная классификация: примитивные типы и ссылочные типы. Примитивные: целочисленные (byte, short, int, long), вещественные (float, double), логический (boolean), символьный (char). Ссылочные: классы (в т.ч. String), интерфейсы, массивы, enum, record и т.д."
    },
    {
      "question": "Какие ключевые методы есть у Object (toString, equals, hashCode) и для чего они?",
      "answer": "toString() — строковое представление объекта (для логов/дебага). equals() — логическое сравнение объектов (обычно по значимым полям). hashCode() — числовой хеш для хеш-коллекций (HashMap/HashSet): если equals() истинно, hashCode() обязан совпасть. Часто их переопределяют вместе."
    },
    {
      "question": "Какие новые фичи в Java вы знаете/используете (например, var, structured concurrency)?",
      "answer": "Примеры: var (локальная типизация), record для data-моделей, switch expressions, text blocks, sealed classes, pattern matching (instanceof/switch), улучшения GC, виртуальные потоки (Project Loom) в новых версиях, и structured concurrency (группировка задач и их отмена/ожидание как единое целое). На собесе достаточно назвать 5–7 и кратко зачем."
    },
    {
      "question": "Какими методами и контрактами обладает базовый класс Object?",
      "answer": "Ключевые: equals/hashCode (контракт сравнения), toString, getClass, clone (осторожно, спорный API), wait/notify/notifyAll (монитор и синхронизация), finalize (устарел/не рекомендован). Важно понимать, что wait/notify работают только внутри synchronized на том же объекте, а finalize сейчас считается плохой практикой."
    },
    {
      "question": "Какими функциональными интерфейсами пользуетесь? Примеры (Function, BiFunction, Supplier, Consumer и т.д.)",
      "answer": "Function<T,R> — преобразование T→R, BiFunction<T,U,R> — два входа, Supplier<T> — отдаёт значение без входов, Consumer<T> — принимает и «потребляет» без результата, Predicate<T> — проверка boolean, UnaryOperator<T> — T→T, Comparator<T> — сравнение для сортировки. Они активно используются в Stream API, Optional, коллекциях и коллбэках."
    },
    {
      "question": "Каковы издержки иммутабельности строк и как их обходят (builder/buffer)?",
      "answer": "String неизменяемый: любая «модификация» создаёт новый объект, что в циклах приводит к множеству аллокаций и нагрузке на GC. Обход: использовать StringBuilder/StringBuffer для накопления, а потом один раз делать toString(). Ещё варианты: форматирование через Formatter/String.format (но обычно тяжелее) и использование join/collect."
    },
    {
      "question": "Какой ключевой default-метод появился в Java 8 (в Collection)?",
      "answer": "В Java 8 в интерфейсах появились default-методы, чтобы добавлять функциональность без поломки старых реализаций. В Collection/Iterable популярные: forEach (Iterable), removeIf (Collection), spliterator, а также stream()/parallelStream() (в Collection). Самый «поворотный» для стиля кода — stream()."
    },
    {
      "question": "Когда выбирать Comparable, а когда — Comparator? Какой паттерн реализует Comparator?",
      "answer": "Comparable задаёт «естественный» порядок внутри самого класса (implements Comparable) — один основной порядок. Comparator нужен, когда сортировок может быть много (по имени, по дате, по рейтингу) или когда нельзя/не хочется менять класс. Comparator — это по сути паттерн Strategy: алгоритм сравнения можно подставлять снаружи."
    },
    {
      "question": "Когда выбирать StringBuilder vs StringBuffer?",
      "answer": "StringBuilder — по умолчанию для одного потока: быстрее, без синхронизации. StringBuffer — когда один и тот же экземпляр реально используется конкурентно из нескольких потоков и нужна встроенная синхронизация (сейчас это редко). В большинстве случаев потокобезопасность решают иначе, поэтому чаще выбирают StringBuilder."
    },
    {
      "question": "Когда два объекта могут иметь одинаковый hashCode(), но быть не равны по equals()?",
      "answer": "Это нормальная ситуация: hashCode — не уникальный идентификатор, а хеш, возможны коллизии. В HashMap сначала выбирается бакет по hashCode, а затем внутри бакета проверяется equals. Главное правило обратное: если equals() == true, то hashCode() обязан быть одинаковым."
    },
    {
      "question": "Когда и зачем в Java добавили default-методы в интерфейсах?",
      "answer": "Default-методы добавили в Java 8, чтобы развивать стандартные интерфейсы (например, Collection/Iterable) без поломки всех существующих реализаций. Если бы добавили абстрактный метод — старые классы не скомпилировались бы. Default даёт реализацию по умолчанию и сохраняет обратную совместимость."
    },
    {
      "question": "Когда следует переопределять toString, equals, hashCode, compareTo?",
      "answer": "toString — когда объект участвует в логах/дебаге и хочется понятное представление. equals/hashCode — когда логическое равенство не равно ссылочному (например, сущности по id, value object по полям) и объект будет ключом/элементом в HashMap/HashSet. compareTo — когда у типа есть естественный порядок и он будет использоваться в сортировках/TreeSet/TreeMap."
    },
    {
      "question": "Контракт equals/hashCode: почему важен и что нарушится при его несоблюдении?",
      "answer": "Если equals считает объекты равными, но hashCode разный — хеш-коллекции ломаются: HashSet может хранить «дубликаты», HashMap не найдёт ключ, хотя он «равен». Коллекции зависят от того, что равные объекты попадают в один и тот же бакет. Поэтому equals и hashCode должны быть согласованы."
    },
    {
      "question": "Контракт equals/hashCode: что он гарантирует?",
      "answer": "Гарантия: если a.equals(b) == true, то a.hashCode() == b.hashCode(). Обратное не требуется: одинаковый hashCode не означает equals. Также equals должен быть рефлексивным, симметричным, транзитивным, консистентным и возвращать false при сравнении с null."
    },
    {
      "question": "Может ли абстрактный класс быть final? А абстрактные методы — какими могут/не могут быть?",
      "answer": "Абстрактный класс не может быть final: final запрещает наследование, а abstract подразумевает, что класс нужно наследовать и реализовать. Абстрактный метод не может быть final (нельзя одновременно требовать override и запрещать его), static (не переопределяется полиморфно) и private (его нельзя переопределить). Обычно abstract методы имеют protected/public."
    },
    {
      "question": "Может ли класс быть static?",
      "answer": "Top-level класс (отдельный файл) не может быть static. Static может быть только вложенный класс (static nested class) внутри другого класса. Такой класс не держит ссылку на внешний объект и создаётся как обычный: new Outer.Nested()."
    },
    {
      "question": "Можно ли вызвать приватный метод/изменить приватное поле? Что нужно сделать (например, setAccessible)?",
      "answer": "Да, через Reflection можно получить Method/Field и вызвать setAccessible(true), после чего читать/менять приватное. Но это ломает инкапсуляцию и может быть ограничено модульной системой (Java 9+) и настройками безопасности. В проде так делать стоит только когда нет нормальной альтернативы (например, в фреймворках/тестах)."
    },
    {
      "question": "Можно ли класс объявить final и abstract одновременно? Почему?",
      "answer": "Нельзя. abstract означает «нужно наследовать и реализовать», final означает «наследовать запрещено». Это логическое противоречие, поэтому компилятор не даст так сделать."
    },
    {
      "question": "Можно ли наследоваться от String? Почему?",
      "answer": "Нельзя, потому что String объявлен как final. Это сделано ради безопасности и предсказуемости (например, в ClassLoader, security, работе с хешами и пулом строк). Если бы можно было наследовать, можно было бы нарушать ожидания о неизменяемости и поведении строки."
    },
    {
      "question": "Можно ли переопределить статический метод? Чем override отличается от hiding?",
      "answer": "Статический метод нельзя переопределить в смысле полиморфизма. Его можно «скрыть» (hiding): если в наследнике объявить static метод с той же сигнатурой, выбор будет зависеть от типа ссылки на этапе компиляции, а не от реального объекта. Override — это динамический полиморфизм (виртуальные методы), hiding — статическая привязка."
    }
  ],
  "ООП": [
    {
      "question": "Что такое объект в ООП?",
      "answer": "Ответ будет добавлен позже."
    }
  ]
}
