{
  "ООП": [
    {
      "question": "Как выбрать между конкатенацией строк, StringBuilder и String.format() в разных сценариях?",
      "answer": ""
    },
    {
      "question": "Как избежать деградации при конкатенации строк в цикле? Чем StringBuilder отличается от StringBuffer?",
      "answer": ""
    },
    {
      "question": "Как устроен StringBuilder под капотом?",
      "answer": ""
    },
    {
      "question": "Каковы издержки иммутабельности строк и как их обходят (builder/buffer)?",
      "answer": ""
    },
    {
      "question": "Когда выбирать Comparable, а когда — Comparator? Какой паттерн реализует Comparator?",
      "answer": ""
    },
    {
      "question": "Когда выбирать StringBuilder vs StringBuffer?",
      "answer": ""
    },
    {
      "question": "Когда следует переопределять toString, equals, hashCode, compareTo?",
      "answer": ""
    },
    {
      "question": "Может ли абстрактный класс быть final? А абстрактные методы — какими могут/не могут быть?",
      "answer": ""
    },
    {
      "question": "Можно ли понижать модификатор доступа при override?",
      "answer": ""
    },
    {
      "question": "Можно ли при переопределении метода сузить/расширить модификатор доступа? Какой принцип ООП нарушим при сужении?",
      "answer": ""
    },
    {
      "question": "Можно ли сузить или расширить модификатор доступа при переопределении метода? Почему?",
      "answer": ""
    },
    {
      "question": "Обязательно ли всегда закрывать поля? Можно ли организовать инкапсуляцию на уровне пакета? Какой модификатор доступа используется?",
      "answer": ""
    },
    {
      "question": "Переопределение vs перегрузка. Перегружается ли конструктор?",
      "answer": ""
    },
    {
      "question": "Перечисли и объясни принципы ООП: инкапсуляция, наследование, полиморфизм.",
      "answer": ""
    },
    {
      "question": "Почему в Java нет множественного наследования? Как добиваться похожего эффекта?",
      "answer": ""
    },
    {
      "question": "Почему конкатенация строк в цикле — анти-паттерн? Чем заменить?",
      "answer": ""
    },
    {
      "question": "Почему конкатенация строк в цикле — антипаттерн?",
      "answer": ""
    },
    {
      "question": "Почему при переопределении equals() обычно нужно переопределять и hashCode()?",
      "answer": ""
    },
    {
      "question": "Разница String, StringBuilder, StringBuffer и где какой использовать?",
      "answer": ""
    },
    {
      "question": "Чем отличаются StringBuilder и StringBuffer? Какой из них потокобезопасен?",
      "answer": ""
    },
    {
      "question": "Чем перегрузка отличается от переопределения?",
      "answer": ""
    },
    {
      "question": "Чем abstract класс отличается от interface?",
      "answer": ""
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации + «под капотом»?",
      "answer": ""
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации строк через + в цикле?",
      "answer": ""
    },
    {
      "question": "StringBuilder vs StringBuffer: различия и когда что использовать?",
      "answer": ""
    },
    {
      "question": "Что такое «объект» в ООП и чем он принципиально отличается от «процедуры»?",
      "answer": ""
    },
    {
      "question": "Что такое инкапсуляция и зачем она нужна?",
      "answer": ""
    },
    {
      "question": "Что такое класс в ООП и чем он отличается от примитивного типа?",
      "answer": ""
    },
    {
      "question": "Что такое полиморфизм на практике?",
      "answer": ""
    },
    {
      "question": "Что такое полиморфизм? Какие его виды в Java (без опоры на наследование)?",
      "answer": ""
    },
    {
      "question": "Что такое принципы SOLID? Назови любимый и кратко охарактеризуй.",
      "answer": ""
    },
    {
      "question": "В чём контракт между equals и hashCode и когда их нужно переопределять?",
      "answer": ""
    },
    {
      "question": "В чём различия между процедурным программированием и ООП?",
      "answer": ""
    },
    {
      "question": "В чём разница между абстрактными классами и интерфейсами? Когда что выбирать?",
      "answer": ""
    },
    {
      "question": "В чём смысл инкапсуляции?",
      "answer": ""
    },
    {
      "question": "В чём смысл наследования?",
      "answer": ""
    },
    {
      "question": "В чём суть паттерна проектирования Builder и какие проблемы он решает?",
      "answer": ""
    },
    {
      "question": "Где в стандартной библиотеке используется паттерн Декоратор (пример)?",
      "answer": ""
    },
    {
      "question": "Где в стандартной библиотеке Java можно увидеть применение паттерна Builder?",
      "answer": ""
    },
    {
      "question": "Зачем делать immutable-класс final? Чем опасно наследование от immutable-класса?",
      "answer": ""
    },
    {
      "question": "Интерфейс vs абстрактный класс: в чём ключевые различия и «контракт»?",
      "answer": ""
    },
    {
      "question": "Как запретить переопределение метода/наследование класса?",
      "answer": ""
    },
    {
      "question": "Как полиморфизм применять на практике (интерфейсы, базовые типы на вход методов)?",
      "answer": ""
    },
    {
      "question": "Как правильно переопределять equals() и hashCode()?",
      "answer": ""
    },
    {
      "question": "Какие четыре столпа ООП? Примеры каждого.",
      "answer": ""
    },
    {
      "question": "Какие шаги необходимо выполнить при корректном переопределении equals()?",
      "answer": ""
    },
    {
      "question": "Какие группы паттернов проектирования существуют (порождающие, структурные, поведенческие)?",
      "answer": ""
    },
    {
      "question": "Какие реализации шаблона Builder есть в Java и чем отличаются StringBuilder и StringBuffer?",
      "answer": ""
    },
    {
      "question": "Чем отличается Builder и для чего он используется?",
      "answer": ""
    },
    {
      "question": "Что делает паттерн «Адаптер»?",
      "answer": ""
    }
  ]
}
