{
  "ООП": [
    {
      "question": "Что такое «объект» в ООП и чем он принципиально отличается от «процедуры»?",
      "answer": "Объект — это сущность, которая объединяет *данные (состояние)* и *поведение (методы)*.\n\nПроцедура — это просто функция/набор команд, который работает с данными «снаружи».\n\nВ ООП мы стремимся держать данные и операции над ними вместе, чтобы легче сохранять инварианты и скрывать детали реализации."
    },
    {
      "question": "Что такое инкапсуляция и зачем она нужна?",
      "answer": "Инкапсуляция — скрытие внутреннего состояния и реализации объекта за публичным интерфейсом.\n\nЗачем:\n- защищать инварианты (не дать «сломать» объект неправильным доступом),\n- уменьшать связность (можно менять реализацию без переписывания клиентов),\n- делать API понятнее и безопаснее.\n\nВ Java это достигается модификаторами доступа, геттерами/сеттерами, неизменяемыми объектами."
    },
    {
      "question": "Что такое класс в ООП и чем он отличается от примитивного типа?",
      "answer": "Класс — это шаблон (тип), по которому создаются объекты: он описывает поля и методы.\n\nПримитивный тип (например, `int`) — встроенный тип-значение без методов (в чистом виде) и без объектной семантики.\n\nОбъекты создаются из классов и имеют поведение, а примитивы — просто значения (хотя есть обёртки `Integer` и т.п.)."
    },
    {
      "question": "Что такое полиморфизм на практике?",
      "answer": "Полиморфизм — это когда код работает через общий тип (интерфейс/базовый класс), а конкретное поведение определяется реализацией в рантайме.\n\nПример: метод принимает `List`, но фактически может быть `ArrayList` или `LinkedList`.\n\nВ Java это обычно проявляется через интерфейсы и переопределение методов (динамическая диспетчеризация)."
    },
    {
      "question": "Что такое полиморфизм? Какие его виды в Java (без опоры на наследование)?",
      "answer": "Полиморфизм — способность работать с объектами разных типов через единый интерфейс.\n\nВиды в Java:\n- динамический (runtime): переопределение методов (виртуальные вызовы).\n- статический (compile-time): перегрузка методов.\n\nБез опоры на наследование всё равно есть полиморфизм через интерфейсы (это тоже полиморфизм типов, но не обязательно через классовое наследование)."
    },
    {
      "question": "Что такое принципы SOLID? Назови любимый и кратко охарактеризуй.",
      "answer": "SOLID — набор принципов проектирования:\n- S: Single Responsibility,\n- O: Open/Closed,\n- L: Liskov Substitution,\n- I: Interface Segregation,\n- D: Dependency Inversion.\n\nНапример, любимый — SRP: у класса должна быть одна причина для изменения. Это уменьшает связность и упрощает поддержку."
    },
    {
      "question": "В чём контракт между equals и hashCode и когда их нужно переопределять?",
      "answer": "Контракт:\n- если `a.equals(b)` — то `a.hashCode() == b.hashCode()` обязательно.\n- обратное не требуется: одинаковый `hashCode` возможен у разных объектов.\n\nПереопределять нужно, когда вы хотите сравнение «по значению» для своих классов (а не по ссылке) и планируете использовать их в хеш-коллекциях (`HashMap`, `HashSet`). Переопределять надо *оба* метода."
    },
    {
      "question": "В чём контракт между equals() и hashCode()?",
      "answer": "Главное правило: равные по `equals()` объекты обязаны иметь одинаковый `hashCode()`.\n\nТакже желательно:\n- `hashCode()` должен быть стабильным, пока объект «логически» не изменился,\n- хорошее распределение уменьшает коллизии.\n\nЕсли нарушить контракт, `HashMap/HashSet` начнут работать некорректно (например, объект «потеряется» в коллекции)."
    },
    {
      "question": "В чём контракт equals/hashCode и зачем он нужен? Почему нельзя сравнивать объекты только по hashCode?",
      "answer": "Контракт нужен для корректной работы хеш-коллекций: `hashCode` определяет бакет, а `equals` — точное сравнение.\n\nНельзя сравнивать только по `hashCode`, потому что коллизии нормальны: разные объекты могут иметь одинаковый `hashCode`.\n\nПоэтому `hashCode` — быстрый предварительный фильтр, а `equals` — окончательная проверка равенства."
    },
    {
      "question": "В чём различия между процедурным программированием и ООП?",
      "answer": "Процедурное: программа — набор функций/процедур, данные часто отделены и передаются между функциями.\n\nООП: программа — набор объектов, которые инкапсулируют состояние и поведение, взаимодействуют через интерфейсы.\n\nНа практике ООП удобнее для больших доменных моделей и расширяемости, процедурный стиль — проще для небольших алгоритмических задач."
    },
    {
      "question": "В чём разница между абстрактными классами и интерфейсами? Когда что выбирать?",
      "answer": "Интерфейс задаёт контракт: что умеет тип. Может иметь `default` методы, но обычно хранит минимум состояния.\n\nАбстрактный класс — частичная реализация + общий код и поля для наследников.\n\nВыбор:\n- интерфейс — когда важен контракт и возможны разные реализации,\n- абстрактный класс — когда есть общий код/состояние и вы контролируете иерархию.\n\nВ Java нет множественного наследования классов, но можно реализовать много интерфейсов."
    },
    {
      "question": "В чём разница между процедурным и объектно-ориентированным программированием?",
      "answer": "Процедурное — фокус на функциях и алгоритмах.\nООП — фокус на моделировании сущностей предметной области объектами (состояние + поведение).\n\nВ ООП больше внимания инкапсуляции и контрактам, что помогает при развитии и поддержке больших систем."
    },
    {
      "question": "В чём смысл инкапсуляции?",
      "answer": "Смысл — скрыть детали и защитить состояние:\n- объект сам контролирует, как меняются его данные,\n- внешний код работает через понятный API,\n- можно менять реализацию без массовых правок.\n\nЭто снижает связность и делает код безопаснее."
    },
    {
      "question": "В чём смысл наследования?",
      "answer": "Наследование позволяет переиспользовать код и описать отношение «является» (is-a).\n\nНо его нужно применять аккуратно: часто композиция лучше наследования. Наследование хорошо подходит для общих базовых абстракций (например, общий контракт + часть реализации)."
    },
    {
      "question": "В чём суть контракта между equals() и hashCode()?",
      "answer": "Суть: равные объекты должны иметь одинаковый `hashCode`.\n\nИначе нарушается логика хеш-коллекций: объект может оказаться «в другом бакете» и не находиться.\n\nТакже `equals` должен быть корректным (рефлексивность, симметрия, транзитивность, консистентность, `null`)."
    },
    {
      "question": "В чём суть паттерна проектирования Builder и какие проблемы он решает?",
      "answer": "Builder помогает создавать сложные объекты пошагово.\n\nРешает проблемы:\n- много параметров в конструкторе (telescoping constructor),\n- читаемость и порядок параметров,\n- возможность задавать опциональные параметры,\n- создание неизменяемых объектов.\n\nОбычно: `new Foo.Builder().a(...).b(...).build()`."
    },
    {
      "question": "Где в стандартной библиотеке используется паттерн Декоратор (пример)?",
      "answer": "Классический пример — I/O в Java:\n- `InputStream`/`OutputStream` и обёртки `BufferedInputStream`, `DataInputStream`, `GZIPInputStream`.\n\nОни «декорируют» базовый поток дополнительным поведением (буферизация, чтение примитивов, сжатие)."
    },
    {
      "question": "Где в стандартной библиотеке Java можно увидеть применение паттерна Builder?",
      "answer": "Примеры builder-подобного API:\n- `StringBuilder` (пошаговая сборка строки),\n- `java.net.http.HttpRequest.Builder` (Java 11+),\n- `Stream.Builder`.\n\nТакже множество «fluent» API в стандартной библиотеке следуют идее builder."
    },
    {
      "question": "Где и как обычно нарушают Single Responsibility Principle?",
      "answer": "Частые нарушения:\n- «god class»/«service that does everything»: бизнес-логика + работа с БД + HTTP + маппинг + логирование.\n- классы, которые одновременно валидируют, считают, сохраняют и отправляют уведомления.\n\nРешение: разделять ответственность по слоям/компонентам (валидатор, репозиторий, сервис, клиент), выносить инфраструктуру в отдельные классы."
    },
    {
      "question": "Для чего нужен hashCode() и как его используют хеш-коллекции (HashMap, HashSet)?",
      "answer": "`hashCode()` даёт целое число, которое помогает быстро распределять объекты по «корзинам» (buckets).\n\n`HashMap/HashSet` сначала вычисляют `hashCode`, выбирают бакет, а затем внутри бакета проверяют `equals` для точного совпадения.\n\nХороший `hashCode` уменьшает коллизии и ускоряет операции."
    },
    {
      "question": "Если объявить произвольный класс, какой у него будет родитель по умолчанию?",
      "answer": "По умолчанию любой класс в Java неявно наследуется от `java.lang.Object`, если явно не указан другой родитель."
    },
    {
      "question": "Зачем в immutable-классе возвращать defensive copy из геттеров?",
      "answer": "Если immutable-класс хранит внутри изменяемый объект (например, `Date`, `List`), то возвращая его напрямую, вы даёте внешнему коду возможность изменить внутреннее состояние.\n\nDefensive copy (копия) в геттере защищает неизменяемость: наружу отдаём копию, а не внутреннюю ссылку.\n\nТо же касается копирования входных коллекций в конструкторе."
    },
    {
      "question": "Зачем делать immutable-класс final? Чем опасно наследование от immutable-класса?",
      "answer": "Если класс не `final`, от него можно унаследоваться и добавить изменяемое состояние или переопределить методы так, что «неизменяемость» нарушится.\n\n`final` предотвращает это и делает контракт immutability надёжнее.\n\nАльтернатива — сделать конструктор приватным и контролировать наследование, но проще `final`."
    },
    {
      "question": "Зачем нужен класс Object?",
      "answer": "`Object` — корень иерархии классов в Java.\n\nОн задаёт базовые методы, которые есть у всех объектов: `toString()`, `equals()`, `hashCode()`, `getClass()`, `wait/notify`, `clone()` (protected).\n\nЭто обеспечивает единый «минимальный интерфейс» для всех объектов."
    },
    {
      "question": "Зачем нужны классы и как они соотносятся с объектами?",
      "answer": "Класс — описание типа (структура + поведение).\n\nОбъект — конкретный экземпляр класса в памяти.\n\nОдин класс может породить много объектов. Класс задаёт, какие поля/методы у объектов и как они работают."
    },
    {
      "question": "Интерфейс vs абстрактный класс: в чём ключевые различия и «контракт»?",
      "answer": "Интерфейс — контракт возможностей: что должен уметь тип. Поддерживает множественную реализацию.\n\nАбстрактный класс — базовая реализация для иерархии: может хранить состояние и общий код.\n\nКлючевое: интерфейсы задают «что», абстрактные классы часто задают «частично как»."
    },
    {
      "question": "Как запретить переопределение метода/наследование класса?",
      "answer": "- запретить наследование класса: `final class`.\n- запретить переопределение метода: `final` метод.\n\nТакже можно сделать конструкторы приватными (например, утилитный класс), но `final` — основной инструмент."
    },
    {
      "question": "Как полиморфизм применять на практике (интерфейсы, базовые типы на вход методов)?",
      "answer": "На практике принимают/возвращают абстракции:\n- метод принимает `List`, а не `ArrayList`,\n- сервис зависит от интерфейса репозитория, а не от конкретной реализации.\n\nЭто позволяет подменять реализации (тесты, разные стратегии) и снижает связность.\n\nПолиморфизм + DI дают гибкую архитектуру."
    },
    {
      "question": "Как правильно переопределять equals() и hashCode()?",
      "answer": "Правила:\n- использовать один и тот же набор значимых полей в `equals` и `hashCode`.\n- `equals` должен быть: рефлексивный, симметричный, транзитивный, консистентный, `x.equals(null)` → `false`.\n- учитывать `null`.\n\nПрактика в Java:\n- использовать `Objects.equals(...)` и `Objects.hash(...)` или IDE генерацию.\n- для record обычно всё генерируется автоматически.\n\nВажно: не включать в `hashCode/equals` поля, которые меняются, если объект будет ключом в `HashMap`."
    },
    {
      "question": "Как сделать класс immutable (поля/конструкторы/геттеры)?",
      "answer": "Шаги:\n- все поля `private final`,\n- нет сеттеров,\n- состояние задаётся только в конструкторе,\n- если есть изменяемые поля (коллекции/Date) — делать defensive copy при присваивании и при возврате,\n- сам класс часто делают `final`.\n\nРезультат: объект нельзя изменить после создания."
    },
    {
      "question": "Как спроектировать класс как immutable (конструктор, поля, геттеры/сеттеры, копирование коллекций)?",
      "answer": "- `final class`,\n- `private final` поля,\n- конструктор принимает значения и копирует изменяемые (например, `List.copyOf(list)`),\n- геттеры возвращают либо примитивы/иммутабельные типы, либо копии/неизменяемые представления,\n- сеттеров нет.\n\nТак сохраняется инвариант «после создания состояние не меняется»."
    },
    {
      "question": "Как спроектировать immutable-класс в Java? Какие шаги и ограничения нужны?",
      "answer": "Шаги:\n1) Сделать класс `final`.\n2) Поля `private final`.\n3) Инициализация только в конструкторе.\n4) Не отдавать наружу изменяемые ссылки (defensive copy).\n5) Не предоставлять методов, меняющих состояние.\n\nОграничения: наследование усложняет гарантию immutability, изменяемые поля требуют копирования, а корректность equals/hashCode зависит от выбранных полей."
    },
    {
      "question": "Какие свойства (рефлексивность, симметричность, транзитивность, консистентность, null) должен соблюдать equals()?",
      "answer": "`equals` должен быть:\n- рефлексивным: `x.equals(x) == true`.\n- симметричным: `x.equals(y) == y.equals(x)`.\n- транзитивным: если `x=y` и `y=z`, то `x=z`.\n- консистентным: при неизменных данных результат не меняется.\n- `x.equals(null)` всегда `false`.\n\nЭто базовые требования контракта `Object.equals`."
    },
    {
      "question": "Какие четыре столпа ООП? Примеры каждого.",
      "answer": "4 столпа:\n- инкапсуляция (скрытие состояния),\n- наследование (переиспользование иерархий),\n- полиморфизм (работа через общий тип),\n- абстракция (выделение существенного, контракт).\n\nПримеры:\n- интерфейс `List` — абстракция,\n- `private` поля — инкапсуляция,\n- `ArrayList implements List` — полиморфизм,\n- `extends` — наследование."
    },
    {
      "question": "Какие шаги необходимо выполнить при корректном переопределении equals()?",
      "answer": "Типичный чеклист:\n- проверить `this == o` → `true`,\n- проверить `o == null` → `false`,\n- проверить тип (`getClass()` или `instanceof`),\n- сравнить значимые поля (`Objects.equals`),\n- убедиться в соблюдении свойств (симметрия, транзитивность),\n- после переопределения `equals` обязательно переопределить `hashCode`."
    },
    {
      "question": "Каков контракт между equals() и hashCode()?",
      "answer": "Если два объекта равны по `equals`, то их `hashCode` должен совпадать.\n\nЕсли `hashCode` совпал — это не значит, что объекты равны (возможны коллизии).\n\nНарушение контракта ломает корректность `HashMap/HashSet`."
    },
    {
      "question": "Можно ли процедурный код «представить» в виде объектов?",
      "answer": "Да. Обычно выделяют:\n- объект состояния (данные + инварианты),\n- объект стратегии/алгоритма (например, интерфейс + реализации),\n- сервис как объект, который координирует работу.\n\nНо не всегда стоит: иногда чистые функции проще. Важно балансировать: ООП для модели и расширяемости, функциональный/процедурный стиль — для локальных вычислений."
    },
    {
      "question": "Какие группы паттернов проектирования существуют (порождающие, структурные, поведенческие)?",
      "answer": "Три основные группы:\n- порождающие (creational): создание объектов (Factory, Builder, Singleton),\n- структурные (structural): композиция объектов (Adapter, Decorator, Facade),\n- поведенческие (behavioral): взаимодействие и алгоритмы (Strategy, Observer, Iterator, Command)."
    },
    {
      "question": "Какие реализации шаблона Builder есть в Java и чем отличаются StringBuilder и StringBuffer?",
      "answer": "Примеры builder-подхода:\n- `StringBuilder`/`StringBuffer`,\n- `HttpRequest.Builder` (Java 11+).\n\n`StringBuilder` не потокобезопасен, быстрее в single-thread.\n\n`StringBuffer` синхронизирован (потокобезопасен), но медленнее.\n\nВ большинстве случаев используют `StringBuilder`."
    },
    {
      "question": "Какие шаблоны проектирования ты использовала?",
      "answer": "Часто в Java используют:\n- Builder,\n- Factory,\n- Strategy,\n- Decorator,\n- Adapter,\n- Observer,\n- Singleton (редко и осторожно),\n- Template Method.\n\nВыбор зависит от задачи: чаще всего Strategy/Builder/Decorator встречаются в бизнес-коде и библиотеках."
    },
    {
      "question": "Чем отличается Builder и для чего он используется?",
      "answer": "Builder — паттерн для пошагового создания сложного объекта.\n\nИспользуется, когда:\n- много параметров (часть опциональная),\n- важна читаемость создания,\n- объект должен быть неизменяемым,\n- нужно избежать длинных конструкторов.\n\nBuilder делает создание объекта более понятным и безопасным."
    },
    {
      "question": "Что делает паттерн «Адаптер»?",
      "answer": "Adapter «переводит» интерфейс одного класса в интерфейс, который ожидает клиент.\n\nИспользуют, когда:\n- есть старая/сторонняя библиотека с неудобным API,\n- нужно подстроить её под ваш интерфейс,\n- не хочется менять клиентский код.\n\nПример: обёртка вокруг клиента, чтобы он реализовывал ваш `PaymentProvider` интерфейс."
    },
    {
      "question": "Что такое паттерн «Итератор» (Iterator pattern)?",
      "answer": "Iterator — паттерн, который позволяет последовательно обходить элементы коллекции, не раскрывая её внутреннюю структуру.\n\nВ Java это интерфейсы `Iterator` и `Iterable`, а `for-each` работает через `iterator()`.\n\nПлюсы: единый способ обхода разных коллекций и возможность безопасного удаления через `Iterator.remove()`."
    }
  ]
}
