{
  "Spring MVC / Web / Security": [
    {
      "question": "Как Spring маршрутизирует HTTP-запрос на нужный контроллер? Что такое DispatcherServlet?",
      "answer": "В Spring MVC входная точка — `DispatcherServlet` (фронт-контроллер). Он принимает HTTP-запрос и:\n- находит подходящий контроллер/метод по mapping’ам (`@RequestMapping`, `@GetMapping` и т.п.) через `HandlerMapping`,\n- вызывает контроллер через `HandlerAdapter`,\n- обрабатывает аргументы/валидацию, формирует ответ (через `HttpMessageConverter`),\n- применяет `HandlerInterceptor` и обработку ошибок.\n\nТо есть `DispatcherServlet` — центральный маршрутизатор запросов в MVC."
    },
    {
      "question": "Какие обязанности у DispatcherServlet? Нужен ли он для REST?",
      "answer": "Обязанности `DispatcherServlet`:\n- маршрутизация запроса к обработчику,\n- запуск цепочки интерсепторов,\n- биндинг параметров/тела в аргументы контроллера,\n- выбор `HttpMessageConverter` для сериализации/десериализации,\n- обработка исключений (через `@ExceptionHandler`, `@ControllerAdvice`).\n\nДа, он нужен и для REST в Spring MVC: `@RestController` всё равно работает через `DispatcherServlet`."
    },
    {
      "question": "Какие шаги происходят между DispatcherServlet и контроллером (фильтры и пр.)? Писал ли свой веб-фильтр и для чего?",
      "answer": "Типичная цепочка:\n1) Servlet container вызывает цепочку `Filter` (Servlet filters).\n2) Запрос попадает в `DispatcherServlet`.\n3) `HandlerMapping` выбирает handler.\n4) `HandlerInterceptor` (preHandle) выполняется до контроллера.\n5) `HandlerAdapter` вызывает метод контроллера.\n6) `HttpMessageConverter` читает/пишет тело.\n7) `HandlerInterceptor` (postHandle/afterCompletion).\n8) Фильтры завершают обработку.\n\nФильтр пишут для задач уровня «всех запросов»: логирование, correlation id, security headers, CORS, rate limiting, оборачивание request/response, метрики."
    },
    {
      "question": "Какими HTTP-клиентами в Spring пользовался (RestTemplate/WebClient/Feign)?",
      "answer": "Частые варианты:\n- `RestTemplate` — классический блокирующий клиент (сейчас чаще легаси).\n- `WebClient` — современный клиент, поддерживает неблокирующий/reactive подход.\n- OpenFeign — декларативный HTTP-клиент (интерфейсы + аннотации), удобен для межсервисного взаимодействия.\n\nВыбор зависит от стека (MVC vs WebFlux), требований к производительности и удобства."
    },
    {
      "question": "Когда выбирать WebFlux вместо MVC?",
      "answer": "WebFlux стоит выбирать, когда:\n- нужна высокая конкурентность при большом числе одновременных I/O запросов,\n- вы используете неблокирующие драйверы/клиенты и готовы к реактивному стеку,\n- нужен streaming (SSE/WebSocket) и реактивные пайплайны.\n\nMVC лучше, когда:\n- стандартный CRUD и блокирующие зависимости (JPA/JDBC),\n- команда хочет более простой императивный код,\n- нет явной необходимости в реактивности.\n\nВажно: WebFlux даёт выгоду только если *вся цепочка* в основном неблокирующая."
    },
    {
      "question": "Разница RestTemplate и WebClient?",
      "answer": "`RestTemplate`:\n- блокирующий (thread-per-request),\n- простой, но считается устаревающим.\n\n`WebClient`:\n- поддерживает неблокирующий/reactive стиль,\n- лучше подходит для WebFlux, стриминга, высокой конкурентности,\n- умеет композицию и более гибкую настройку.\n\nНа практике в новых проектах чаще выбирают `WebClient`."
    },
    {
      "question": "Реактивный vs классический стек в Spring: DispatcherServlet против WebHandler — в чём разница и когда что выбирать?",
      "answer": "Spring MVC: `DispatcherServlet`, модель «один запрос — один поток», блокирующие вызовы допустимы (типично: JPA/JDBC).\n\nSpring WebFlux: вместо сервлетной модели используется реактивный pipeline, входная точка — `WebHandler` (обычно через `DispatcherHandler`), выполнение на event-loop (Netty) или другом реактивном рантайме. Предполагается неблокирующий I/O.\n\nВыбор:\n- MVC — проще и отлично подходит для большинства CRUD.\n- WebFlux — когда реально нужна реактивность/стриминг/очень много одновременных I/O и есть неблокирующие зависимости."
    },
    {
      "question": "REST-взаимодействие: реактивный стек или стандартный Spring MVC?",
      "answer": "Для большинства REST API хватает Spring MVC: проще код, легко интегрируется с JPA/JDBC и привычной экосистемой.\n\nРеактивный стек (WebFlux) оправдан, если цель — масштабировать огромное количество одновременных I/O запросов, использовать streaming, или когда вся цепочка (клиенты/драйверы) неблокирующая.\n\nЕсли у вас внутри блокирующий JDBC/JPA и вы просто «обернёте» это в WebFlux — выгоды будет мало, а сложность вырастет."
    },
    {
      "question": "Что такое back-pressure?",
      "answer": "Back-pressure — механизм управления скоростью потока данных: когда потребитель не успевает, он может «сказать» источнику, сколько элементов готов принять.\n\nВ реактивных стримах (Reactive Streams) это реализовано через сигнал `request(n)` от подписчика. Это помогает избегать переполнения памяти и неконтролируемых очередей при потоковой обработке."
    },
    {
      "question": "Что такое Servlet: интерфейс или класс?",
      "answer": "`Servlet` — это интерфейс (`jakarta.servlet.Servlet` / `javax.servlet.Servlet`).\n\nЧаще всего пишут не напрямую, а наследуются от базовых классов, например `HttpServlet`, который реализует `Servlet` и добавляет удобные методы `doGet`, `doPost` и т.п."
    },
    {
      "question": "Как реализуем аутентификацию/авторизацию (JWT?) и где её Terminate’им?",
      "answer": "Типичный подход для stateless API:\n- клиент получает JWT после логина,\n- дальше отправляет `Authorization: Bearer <token>`.\n\nАутентификация (кто ты) и авторизация (что тебе можно) делаются на API-границе — обычно в Spring Security фильтрах.\n\nJWT «терминируют» там, где принимают запросы (API Gateway или сам сервис):\n- проверяют подпись, срок, issuer/audience,\n- извлекают claims/roles,\n- кладут `Authentication` в `SecurityContext`.\n\nЕсли есть gateway, часто он делает первичную проверку, но сервисы всё равно обычно валидируют токен (или доверяют mTLS/внутреннему токену) — зависит от архитектуры."
    },
    {
      "question": "Что такое SQL-инъекции, какой код к ним приводит и как защищаться в JDBC?",
      "answer": "SQL-инъекция — когда пользовательский ввод попадает в SQL как часть *кода*, позволяя изменить запрос.\n\nПример плохого кода:\n- конкатенация: `\"SELECT * FROM users WHERE login='\" + login + \"'\"`.\n\nЗащита в JDBC:\n- использовать `PreparedStatement` с параметрами (`?`),\n- не строить SQL из пользовательского ввода (особенно части `WHERE`, `ORDER BY`),\n- для динамического `ORDER BY` — whitelist допустимых полей,\n- минимальные права у DB-пользователя."
    }
  ]
}
