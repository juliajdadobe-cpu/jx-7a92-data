{
  "JVM / GC / Memory": [
    {
      "question": "В чём разница между стеком и кучей (heap) в JVM?",
      "answer": "Стек (stack) — память *потока*: там лежат фреймы вызовов методов (локальные переменные, параметры, адрес возврата). Стек растёт/уменьшается вместе с вызовами и освобождается автоматически.\n\nКуча (heap) — общая память процесса JVM, где живут *объекты* и массивы. Куча управляется сборщиком мусора (GC)."
    },
    {
      "question": "В чём разница между стеком и кучей с точки зрения потоков и видимости данных?",
      "answer": "Стек у каждого потока свой, поэтому данные в локальных переменных *не разделяются* между потоками напрямую.\n\nКуча общая для всех потоков, поэтому объекты в куче — это общий доступ и источник гонок.\n\nНо важно: «где лежит» ≠ «как видится». Видимость между потоками определяет Java Memory Model: без `volatile`/синхронизации один поток может не увидеть обновления другого даже для объекта в куче."
    },
    {
      "question": "Где хранятся объекты и где хранятся примитивы?",
      "answer": "Объекты и массивы размещаются в куче (heap).\n\nПримитивы зависят от контекста:\n- локальные переменные и параметры методов — обычно в стеке (в фрейме),\n- поля объекта — внутри объекта в куче.\n\nСсылки на объекты (reference) сами по себе — это не объект; ссылка как значение хранится там же, где и переменная (в стеке или внутри другого объекта)."
    },
    {
      "question": "Где хранятся объекты, а где — примитивные типы?",
      "answer": "Объекты/массивы — в куче.\n\nПримитивы:\n- локальные переменные/параметры — в стеке (фрейм метода),\n- поля объекта — внутри объекта в куче.\n\nОбёртки (`Integer`, `Long` и т.д.) — это объекты, значит они в куче."
    },
    {
      "question": "Где хранятся примитивы в разных случаях (поле объекта vs локальная переменная/параметр)?",
      "answer": "- Если примитив — *поле объекта*, он хранится внутри объекта в куче.\n- Если примитив — *локальная переменная* или *параметр метода*, он хранится в стеке (во фрейме вызова).\n\nНа практике JIT может оптимизировать (например, scalar replacement), но на собеседовании этого разделения достаточно."
    },
    {
      "question": "Где хранятся примитивы и обёртки и почему примитив нельзя использовать ключом в HashMap?",
      "answer": "Примитивы — значения (могут быть в стеке как локальные/параметры или внутри объекта в куче как поля).\n\nОбёртки (`Integer`, `Long`...) — объекты, живут в куче.\n\nКлючом в `HashMap` может быть только объект (ссылка), потому что `Map<K,V>` работает с ссылочными типами и использует методы `hashCode()`/`equals()`, которые есть у объектов. Примитив не имеет методов, поэтому напрямую ключом быть не может — его нужно «упаковать» в обёртку."
    },
    {
      "question": "Два объекта ссылаются друг на друга. Будут ли они собраны?",
      "answer": "Могут быть собраны, если *вся циклическая группа* стала недостижимой из GC Roots.\n\nGC смотрит не на «циклы», а на достижимость: если на эти объекты больше нет ссылок из корней (стек потоков, статические поля и т.д.), то даже если они ссылаются друг на друга, они мусор."
    },
    {
      "question": "Если объект содержит поля-примитивы — где хранятся эти примитивы?",
      "answer": "Поля-примитивы хранятся внутри самого объекта в куче, как часть его памяти.\n\nНапример, у объекта с полем `int x` значение `x` лежит рядом с другими полями объекта в heap."
    },
    {
      "question": "Зачем нужен GC и каковы этапы (mark/sweep/compact)?",
      "answer": "GC нужен, чтобы автоматически освобождать память объектов, которые больше недостижимы, и снижать риск утечек «как в C/C++».\n\nУпрощённая схема mark–sweep–compact:\n- mark: отметить достижимые объекты, начиная от GC Roots,\n- sweep: освободить память недостижимых,\n- compact: уплотнить живые объекты, чтобы убрать фрагментацию (не всегда выполняется каждым сборщиком на каждом цикле)."
    },
    {
      "question": "Зачем нужно уплотнение памяти (compaction)?",
      "answer": "Compaction устраняет фрагментацию кучи: после освобождения объектов остаются «дыры». Даже если свободной памяти много, может не быть *непрерывного* блока под большой объект.\n\nУплотнение перемещает живые объекты ближе друг к другу, объединяя свободное место, и обычно ускоряет последующие выделения памяти (allocation)."
    },
    {
      "question": "Зачем разработчику знать про classloader’ы?",
      "answer": "ClassLoader влияет на:\n- то, *какой* класс будет загружен (особенно при нескольких версиях библиотек),\n- изоляцию модулей/плагинов (каждый может иметь свой classloader),\n- проблемы вида `ClassNotFoundException`, `NoClassDefFoundError`, `ClassCastException` «одинаковые классы, но разные загрузчики»,\n- утечки памяти (часто: утечки classloader’ов при hot-reload/контейнерах).\n\nЭто важно для диагностики в реальных приложениях."
    },
    {
      "question": "Из-за чего возникает OutOfMemoryError и с чего начать разбор на предпроде?",
      "answer": "Причины OOM бывают разные:\n- переполнен heap (`Java heap space`): много живых объектов/утечка/слишком маленький `-Xmx`,\n- переполнен metaspace (`Metaspace`): много классов/утечка classloader’ов,\n- слишком много потоков/мало памяти под стеки,\n- `Direct buffer memory` (off-heap),\n- `GC overhead limit exceeded` (GC почти всё время работает, но памяти не хватает).\n\nСтарт разбора:\n- включить heap dump на OOM (`-XX:+HeapDumpOnOutOfMemoryError`),\n- посмотреть логи GC и тип OOM,\n- анализировать дамп (MAT/YourKit/JProfiler), найти «кто держит память» (retained size, dominator tree)."
    },
    {
      "question": "Как задать порог для JIT (например, CompileThreshold)?",
      "answer": "Порог компиляции можно задавать JVM-флагами. Например, для HotSpot:\n- `-XX:CompileThreshold=<N>` — сколько раз метод должен быть вызван/пройти по циклу, чтобы JIT начал компилировать.\n\nНа практике это тонкая настройка: чаще важнее профилировать и смотреть реальные метрики, чем крутить пороги без необходимости."
    },
    {
      "question": "Как обнаружить и устранить утечку памяти на проде?",
      "answer": "План:\n- подтвердить рост: метрики heap/metaspace, частота GC, паузы, рост RSS.\n- снять артефакты: heap dump (лучше несколько с интервалом), GC logs.\n- в дампе найти «доминирующие» объекты и пути удержания (Dominator Tree / Retained Size).\n- понять источник: кэш без ограничений, коллекции, `ThreadLocal`, listeners, статические поля, утечки classloader’ов.\n- исправить: ограничить/очищать кэш, закрывать ресурсы, убирать лишние ссылки, корректно завершать потоки.\n\nИнструменты: Eclipse MAT, VisualVM, YourKit, JProfiler, `jcmd`/`jmap`."
    },
    {
      "question": "Как работает загрузка классов в Java: этапы, виды classloader’ов и принцип делегирования?",
      "answer": "Этапы: loading (загрузка байт-кода), linking (verification + preparation + resolution), initialization (выполнение статических инициализаторов).\n\nКласс-лоадеры: bootstrap (ядро Java), platform/ext (платформенные модули), application (classpath), плюс пользовательские.\n\nПринцип делегирования: обычно classloader сначала спрашивает родителя, и только если тот не нашёл класс — пытается загрузить сам. Это защищает от подмены системных классов и уменьшает дубли."
    },
    {
      "question": "Как GC определяет, что объект — мусор? Что такое GC-roots?",
      "answer": "GC считает мусором объекты, которые *недостижимы* из GC Roots.\n\nGC Roots — это «точки входа», откуда начинается обход графа объектов: ссылки из стека потоков (локальные переменные/параметры), статические поля, JNI-ссылки, активные `Class`-объекты, иногда внутренние структуры JVM.\n\nЕсли до объекта нельзя добраться по ссылкам от корней — он кандидат на сборку."
    },
    {
      "question": "Как Young/Old поколения влияют на сборку мусора?",
      "answer": "Куча часто делится на поколения:\n- Young (Eden + Survivor) — много короткоживущих объектов, сборка происходит часто и быстро.\n- Old (Tenured) — объекты, которые прожили несколько сборок в Young, «продвигаются» сюда; сборка реже, но обычно дороже.\n\nИдея generational GC: большинство объектов умирает быстро, поэтому выгодно часто чистить Young и реже трогать Old."
    },
    {
      "question": "Какие есть GC (Serial, Parallel, CMS/G1/ZGC/Shenandoah) и верхние отличия?",
      "answer": "Коротко:\n- Serial GC — один поток, простая реализация; подходит для маленьких heap/однопоточных нагрузок.\n- Parallel GC — stop-the-world, но использует несколько потоков для сборки; цель — высокая пропускная способность.\n- CMS (устаревший) — стремился уменьшить паузы за счёт частично конкурентной сборки Old, но сложнее и может фрагментировать.\n- G1 — «региональный» сборщик, баланс пауз и throughput; часто дефолт в современных Java.\n- ZGC и Shenandoah — low-latency сборщики: делают большую часть работы конкурентно и стараются держать паузы очень маленькими даже на больших heap."
    },
    {
      "question": "Какие механизмы ускоряют выполнение байткода (JIT/AOT и др.)?",
      "answer": "Основные механизмы ускорения:\n- интерпретатор + профилирование горячих участков,\n- JIT-компиляция (C1/C2): компилирует «горячие» методы в машинный код,\n- оптимизации JIT: inlining, escape analysis, elimination of locks, loop optimizations,\n- AOT (например, `jaotc`/GraalVM) — заранее скомпилированный код (используется реже),\n- кэширование скомпилированного кода (code cache).\n\nВ итоге JVM «разгоняется» со временем (warm-up)."
    },
    {
      "question": "Какие области памяти в Java ты знаешь?",
      "answer": "На уровне JVM обычно выделяют:\n- heap (куча) — объекты,\n- stacks (стеки потоков) — фреймы методов,\n- metaspace — метаданные классов,\n- code cache — скомпилированный JIT-код,\n- direct/off-heap память (например, `ByteBuffer.allocateDirect`).\n\nПлюс есть нативная память JVM и ОС."
    },
    {
      "question": "Какие области памяти есть в JVM (heap, metaspace, code cache, стек потоков) и за что каждая отвечает?",
      "answer": "- Heap: объекты и массивы, управляется GC.\n- Стек потока: фреймы методов (локальные переменные, параметры), живёт вместе с потоком.\n- Metaspace: метаданные загруженных классов (описания классов, методов, константный пул и т.п.).\n- Code cache: машинный код, сгенерированный JIT.\n\nДополнительно: direct/off-heap память (NIO), и нативная память JVM (внутренние структуры)."
    },
    {
      "question": "Какие объекты могут стать недостижимыми? Примеры.",
      "answer": "Любые объекты, на которые больше нет ссылок из GC Roots.\n\nПримеры:\n- локальный объект, который «вышел из области видимости» после возврата из метода,\n- объект, который был в коллекции, но его удалили, и больше на него никто не ссылается,\n- циклическая группа объектов, на которую больше нет внешних ссылок."
    },
    {
      "question": "Какие поколения памяти в JVM и почему объекты «переезжают»?",
      "answer": "Обычно говорят про Young и Old поколения (плюс Metaspace отдельно).\n\nОбъекты «переезжают» из Eden в Survivor, а затем в Old (promotion), если они пережили несколько minor GC. Это сделано потому, что большинство объектов короткоживущие: выгодно быстро очищать Young, а «долгожителей» хранить отдельно и собирать реже."
    },
    {
      "question": "Какие сборщики мусора знаешь и в общих чертах как они работают?",
      "answer": "Знаю Serial, Parallel, G1, ZGC, Shenandoah (и исторически CMS).\n\nВ общих чертах любой GC:\n- определяет достижимые объекты от GC Roots,\n- освобождает память недостижимых,\n- иногда делает компакцию/перемещение.\n\nРазница — в том, сколько работы делается stop-the-world vs конкурентно, как организована память (регионы/поколения) и на что оптимизация: throughput или низкие паузы."
    },
    {
      "question": "Какие JVM-параметры ты настраивал (heap/stack/GC и т.п.)?",
      "answer": "Типичные параметры:\n- heap: `-Xms`, `-Xmx`.\n- стек: `-Xss`.\n- metaspace: `-XX:MaxMetaspaceSize`.\n- выбор GC: `-XX:+UseG1GC` / `-XX:+UseZGC` (и т.п.).\n- GC логи: `-Xlog:gc*`.\n- дампы: `-XX:+HeapDumpOnOutOfMemoryError`, `-XX:HeapDumpPath=...`.\n\nВажно: настраивать осмысленно, опираясь на нагрузку и метрики."
    },
    {
      "question": "Какими настройками JVM для памяти пользовался? Как регулировать размер стека? Сколько стека по умолчанию?",
      "answer": "Размер heap обычно задают `-Xms`/`-Xmx`.\n\nРазмер стека потока задаётся `-Xss`.\n\n«По умолчанию» размер стека зависит от JVM и ОС (часто около 1 МБ, но это не гарантировано). Поэтому в ответе на интервью лучше подчеркнуть: значение платформозависимое, регулируется через `-Xss`."
    },
    {
      "question": "Какими флагами JVM включить дамп хипа при OOM и чем читать дамп?",
      "answer": "Флаги:\n- `-XX:+HeapDumpOnOutOfMemoryError`\n- `-XX:HeapDumpPath=/path/to/dumps`\n\nЧитать/анализировать: Eclipse MAT, VisualVM, YourKit, JProfiler. Также полезны `jcmd`/`jmap` для снятия дампа вручную."
    },
    {
      "question": "Каков общий алгоритм работы сборщика мусора (mark–sweep–compact)?",
      "answer": "Упрощённо:\n1) Mark: обойти граф объектов от GC Roots и пометить живые.\n2) Sweep: освободить память непомеченных.\n3) Compact: при необходимости переместить живые объекты и уплотнить память.\n\nКонкретные сборщики могут делать эти шаги по-разному (поколения/регионы/конкурентно)."
    },
    {
      "question": "Могут ли примитивы храниться в куче? В каких случаях?",
      "answer": "Да. Если примитив — поле объекта, то он хранится в куче внутри этого объекта.\n\nТакже примитивы могут храниться в куче как элементы массивов примитивов (например, `int[]`).\n\nА вот локальные примитивы/параметры методов обычно на стеке."
    },
    {
      "question": "Можно ли «заставить» GC запуститься? Гарантирован ли запуск?",
      "answer": "Можно *попросить* GC: `System.gc()` или `Runtime.getRuntime().gc()`.\n\nНо это не гарантия немедленного запуска: JVM может проигнорировать или отложить запрос (зависит от настроек и конкретной JVM). В продакшене на это не полагаются; лучше устранять причину давления на память."
    },
    {
      "question": "Слышал ли/использовал режимы работы без обычной сборки мусора?",
      "answer": "Есть экспериментальные/нишевые варианты:\n- Epsilon GC — «no-op» сборщик: память не освобождается, полезно для тестов производительности/короткоживущих процессов.\n- Off-heap подходы (direct buffers, memory-mapped files) — часть данных хранится вне heap, но GC всё равно остаётся для объектов.\n\nВ типичных серверных приложениях обычно выбирают подходящий GC (G1/ZGC) вместо полного отказа от сборки."
    },
    {
      "question": "Структура памяти JVM: heap, stack, metaspace.",
      "answer": "Коротко:\n- Heap — объекты и массивы, управляется GC.\n- Stack — память каждого потока для вызовов методов и локальных переменных.\n- Metaspace — метаданные загруженных классов (вместо старого PermGen).\n\nПлюс есть code cache и off-heap/нативная память."
    },
    {
      "question": "Чем измеряете и диагностируете GC-проблемы? Полезные флаги?",
      "answer": "Смотрю на:\n- паузы GC (latency), частоту и время minor/major,\n- загрузку CPU, рост heap/metaspace, allocation rate,\n- `GC overhead` и промоушены в Old.\n\nПолезно включать логи:\n- `-Xlog:gc*` (современный unified logging).\n\nИнструменты: Grafana/Prometheus метрики, GC log analyzers, VisualVM/YourKit/JProfiler, `jcmd`."
    },
    {
      "question": "Чем отличаются Serial/Parallel GC, G1 и ZGC? Когда какой выбрать?",
      "answer": "- Serial: прост, но stop-the-world в одном потоке — обычно только для маленьких heap/утилит.\n- Parallel: STW, но параллельный — хорош для throughput, когда паузы не критичны.\n- G1: баланс, предсказуемее паузы, хорошо «по умолчанию» для большинства сервисов.\n- ZGC: минимальные паузы даже на больших heap, подходит для low-latency систем (ценой большей сложности и иногда overhead).\n\nВыбор зависит от требований: если важны паузы — смотрят в сторону ZGC/Shenandoah; если важен throughput и heap небольшой — Parallel/G1."
    },
    {
      "question": "Чем ссылка на объект на стеке отличается от самого объекта в куче?",
      "answer": "Ссылка (reference) — это значение, которое «указывает» на объект. Ссылка может храниться в стеке (локальная переменная) или в другом объекте.\n\nСам объект — данные (поля, заголовок объекта) — хранится в куче.\n\nКопирование ссылки не копирует объект: два разных места могут хранить ссылку на один и тот же объект."
    },
    {
      "question": "Чем metaspace отличается от permgen и что там хранится?",
      "answer": "PermGen — старая область памяти HotSpot для метаданных классов (до Java 8), часто приводила к `PermGen space` OOM.\n\nMetaspace (Java 8+) хранит метаданные классов и выделяется из нативной памяти, а не из heap. Размер можно ограничивать `-XX:MaxMetaspaceSize`.\n\nТам хранятся структуры, описывающие классы/методы/константы и т.п."
    },
    {
      "question": "Что происходит при компиляции и выполнении Java-кода?",
      "answer": "Компиляция: `javac` переводит исходники `.java` в байткод `.class`.\n\nВыполнение:\n- JVM загружает классы (classloader),\n- байткод сначала может выполняться интерпретатором,\n- «горячие» участки JIT компилирует в машинный код и оптимизирует,\n- GC управляет памятью объектов.\n\nИз-за JIT у приложений есть «разогрев» (warm-up)."
    },
    {
      "question": "Что такое утечки памяти в Java? Как их находить и анализировать? Какими инструментами пользоваться?",
      "answer": "Утечка памяти в Java — это когда объекты больше не нужны, но на них всё ещё есть ссылки, поэтому GC не может их собрать (часто: коллекции, кэши без ограничений, `ThreadLocal`, listeners, статические поля).\n\nИщут по метрикам и heap dump’ам: смотрят, какие объекты занимают память и кто их удерживает (retained size, dominators).\n\nИнструменты: Eclipse MAT, VisualVM, YourKit, JProfiler, `jcmd`/`jmap`, GC logs."
    },
    {
      "question": "Что такое GC Roots и какие объекты к ним относятся?",
      "answer": "GC Roots — набор «корней», откуда GC начинает обход графа объектов.\n\nК ним обычно относят:\n- ссылки из стека потоков (локальные переменные/параметры активных методов),\n- статические поля загруженных классов,\n- JNI ссылки,\n- объекты, удерживаемые JVM (например, системные classloader’ы и т.п.)."
    },
    {
      "question": "Что такое GC roots? Примеры источников корней.",
      "answer": "GC roots — источники начальной достижимости.\n\nПримеры:\n- локальные переменные в стеке работающих потоков,\n- `static` поля классов,\n- ссылки из JNI,\n- объекты, на которые ссылаются внутренние структуры JVM (например, класс-лоадеры)."
    },
    {
      "question": "Что такое GC-roots и достижимость?",
      "answer": "Достижимость — это возможность добраться до объекта по цепочке ссылок, начиная от GC Roots.\n\nGC-roots — стартовые точки обхода. Если объект достижим от корней — он живой. Если нет — он мусор и может быть собран."
    },
    {
      "question": "Что такое JIT-компиляция в JVM и в чём её особенности?",
      "answer": "JIT (Just-In-Time) компилирует байткод в машинный код *во время работы* программы, ориентируясь на реальные профили выполнения.\n\nОсобенности:\n- есть «разогрев» (сначала интерпретация/профилирование, потом оптимизация),\n- возможна деоптимизация (если предположения оптимизатора перестали быть верными),\n- даёт сильные оптимизации (inlining, escape analysis и др.), поэтому на «горячих» участках Java может быть очень быстрой."
    },
    {
      "question": "Что такое stop-the-world?",
      "answer": "Stop-the-world (STW) — пауза, когда JVM останавливает потоки приложения, чтобы выполнить работу GC (или некоторые другие VM операции).\n\nДаже у «конкурентных» сборщиков бывают короткие STW-фазы. В проде важно следить за длительностью и частотой STW, потому что это напрямую влияет на latency."
    }
  ]
}
