{
  "JDBC / JPA / Hibernate": [
    {
      "question": "Чем JPA/Hibernate отличается от «чистого» JDBC и когда предпочесть JDBC Template?",
      "answer": ""
    },
    {
      "question": "Что такое JDBC? Зачем нужна спецификация и драйверы?",
      "answer": ""
    },
    {
      "question": "Что такое PreparedStatement и как он помогает против SQL-инъекций?",
      "answer": ""
    },
    {
      "question": "При какой загрузке возникает проблема N+1 и как её решать (join fetch, entity graph, batch size)?",
      "answer": ""
    },
    {
      "question": "Что такое проблема N+1 и как с ней бороться в Hibernate?",
      "answer": ""
    },
    {
      "question": "Что такое проблема N+1, как её диагностировать и решать (fetch join/EntityGraph/LAZY/EAGER)?",
      "answer": ""
    },
    {
      "question": "Что такое проблема N+1, как её находить и чем лечить (fetch join, entity graph, batch size)?",
      "answer": ""
    },
    {
      "question": "Что такое persistence context и кэш первого уровня?",
      "answer": ""
    },
    {
      "question": "Блокировки: оптимистическая vs пессимистическая — когда какую использовать? Как реализовать в JPA (версионирование, SELECT FOR UPDATE)?",
      "answer": ""
    },
    {
      "question": "В Hibernate у сущности есть аннотация @Id со стратегией генерации. Какие стратегии генерации ID помните? Какую рекомендуется использовать с PostgreSQL и почему?",
      "answer": ""
    },
    {
      "question": "В Spring Data JPA: как написать простой метод репозитория, чтобы получить всех сотрудников по имени?",
      "answer": ""
    },
    {
      "question": "Где и как в коде задаются EntityGraph/NamedEntityGraph?",
      "answer": ""
    },
    {
      "question": "Два метода с @Transactional в одном бине: что произойдёт при внутреннем вызове? Как это обойти?",
      "answer": ""
    },
    {
      "question": "Если в транзакции загрузили сущность, поменяли поля — нужно ли явно вызывать save()? Почему?",
      "answer": ""
    },
    {
      "question": "Как должна работать @Transactional в показанном месте? Будет ли она реально активна? Почему?",
      "answer": ""
    },
    {
      "question": "Как избежать дедлоков при блокировках сущностей (например, при переводе денег между пользователями)?",
      "answer": ""
    },
    {
      "question": "Как поведёт себя транзакция, если @Transactional метод вызывается из @PostConstruct?",
      "answer": ""
    },
    {
      "question": "Как работает @Transactional под капотом (прокси, правила rollback, readOnly, изоляция)?",
      "answer": ""
    },
    {
      "question": "Как работает @Transactional: прокси, rollback-правила, уровень изоляции, readOnly?",
      "answer": ""
    },
    {
      "question": "Как работает fetch LAZY/EAGER? Проблема N+1 и решения.",
      "answer": ""
    },
    {
      "question": "Как рефакторить код со @Transactional, чтобы избежать долгих внешних вызовов внутри транзакции?",
      "answer": ""
    },
    {
      "question": "Какие ещё способы задания EntityGraph есть?",
      "answer": ""
    },
    {
      "question": "Какие состояния жизненного цикла сущности JPA (transient, managed, detached, removed)?",
      "answer": ""
    },
    {
      "question": "Какие стратегии загрузки связей в JPA/Hibernate (lazy/eager) и как они влияют на производительность?",
      "answer": ""
    },
    {
      "question": "Какие уровни кэширования есть в Hibernate?",
      "answer": ""
    },
    {
      "question": "Какой синтаксис можно использовать в @Query (HQL/JPQL или native SQL)?",
      "answer": ""
    },
    {
      "question": "Кэш JPA: кэш первого и второго уровня — что это? Как работает @Cacheable в Spring?",
      "answer": ""
    },
    {
      "question": "Нужен ли save() после изменения управляемой сущности в транзакции? Почему?",
      "answer": ""
    },
    {
      "question": "Отличие save vs saveAndFlush.",
      "answer": ""
    }
  ]
}
