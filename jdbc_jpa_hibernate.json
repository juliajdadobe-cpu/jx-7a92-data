{
  "JDBC / JPA / Hibernate": [
    {
      "question": "Чем JPA/Hibernate отличается от «чистого» JDBC и когда предпочесть JDBC Template?",
      "answer": "JDBC — низкоуровневый API: вы сами пишете SQL, маппите `ResultSet` в объекты, управляете транзакциями/батчами/ресурсами.\n\nJPA/Hibernate — ORM: вы работаете с сущностями, связями и состояниями объектов, а ORM генерирует SQL и управляет persistence context.\n\nКогда предпочесть `JdbcTemplate`/чистый JDBC:\n- сложные/нестандартные запросы и отчёты,\n- критичная производительность и полный контроль над SQL,\n- небольшой слой данных без сложных связей.\n\nКогда JPA удобнее:\n- типовой CRUD, богатая доменная модель, связи, кеширование."
    },
    {
      "question": "Что такое JDBC? Зачем нужна спецификация и драйверы?",
      "answer": "JDBC (Java Database Connectivity) — стандартный API Java для работы с реляционными БД: соединения, запросы, транзакции.\n\nСпецификация нужна, чтобы код приложения был одинаковым, а конкретная БД подключалась через драйвер.\n\nДрайвер JDBC — реализация спецификации под конкретную БД (Postgres/MySQL и т.д.): он знает протокол, типы, особенности и превращает вызовы JDBC в сетевые запросы к БД."
    },
    {
      "question": "Что такое PreparedStatement и как он помогает против SQL-инъекций?",
      "answer": "`PreparedStatement` — это параметризованный SQL-запрос с плейсхолдерами (`?`).\n\nОн помогает против SQL-инъекций, потому что данные передаются отдельно от SQL-кода: драйвер корректно экранирует/кодирует параметры, и пользовательский ввод не может «вклиниться» как часть SQL.\n\nПлюс часто даёт повторное использование плана запроса и удобнее для батчей."
    },
    {
      "question": "При какой загрузке возникает проблема N+1 и как её решать (join fetch, entity graph, batch size)?",
      "answer": "N+1 возникает, когда вы загружаете список сущностей (1 запрос), а затем для каждой сущности лениво догружаете связь отдельным запросом (N запросов). При большом N это превращается в лавину SQL и тормозит.\n\nРешения:\n- `join fetch` (JPQL) — подтянуть связь одним запросом.\n- `EntityGraph` — декларативно указать, что загрузить.\n- `batch size` (`@BatchSize`, настройки Hibernate) — догружать связи пачками, уменьшая число запросов.\n\nВажно не «перетянуть» лишнее: `join fetch` на many-to-many может раздувать результат."
    },
    {
      "question": "Что такое проблема N+1 и как с ней бороться в Hibernate?",
      "answer": "N+1 — это когда для списка из N сущностей ORM делает 1 запрос на список + N запросов на связанные данные (обычно из-за `LAZY` загрузки в цикле).\n\nКак бороться:\n- использовать `fetch join`/`JOIN FETCH` в нужных запросах,\n- `EntityGraph`/`NamedEntityGraph`,\n- настроить batch fetching (`@BatchSize`, `hibernate.default_batch_fetch_size`),\n- внимательно выбирать `LAZY`/`EAGER` и не вызывать ленивые связи «в цикле» без подготовки."
    },
    {
      "question": "Что такое проблема N+1, как её диагностировать и решать (fetch join/EntityGraph/LAZY/EAGER)?",
      "answer": "Диагностика:\n- включить логирование SQL (`hibernate.show_sql`, логгер `org.hibernate.SQL`) и увидеть 1+N запросов,\n- профайлер/метрики, `p6spy`.\n\nРешения:\n- `fetch join` для конкретного кейса,\n- `EntityGraph` (в репозитории/на запросе),\n- batch fetching,\n- по умолчанию лучше держать связи `LAZY`, а `EAGER` использовать осторожно (может скрыто создавать тяжёлые запросы)."
    },
    {
      "question": "Что такое проблема N+1, как её находить и чем лечить (fetch join, entity graph, batch size)?",
      "answer": "Находят по логам SQL/профайлеру: видно, что после получения списка идут одинаковые запросы на связь для каждого элемента.\n\nЛечат:\n- `JOIN FETCH` (JPQL) для точечной загрузки,\n- `EntityGraph`/`NamedEntityGraph` для декларативной подгрузки,\n- batch fetching (`@BatchSize`, `hibernate.default_batch_fetch_size`) — чтобы ORM догружал связи пачками.\n\nГлавное — выбирать стратегию под конкретный экран/операцию."
    },
    {
      "question": "Что такое persistence context и кэш первого уровня?",
      "answer": "Persistence context — это «контекст сущностей» (в JPA обычно связан с `EntityManager`): он хранит управляемые (managed) сущности в рамках транзакции/сессии.\n\nКэш первого уровня — это и есть persistence context: если вы дважды загрузите сущность по одному id в рамках одного контекста, второй раз SQL может не выполняться — вернётся уже загруженный объект.\n\nОн также обеспечивает dirty checking: изменения managed-сущностей автоматически попадут в SQL при flush."
    },
    {
      "question": "Блокировки: оптимистическая vs пессимистическая — когда какую использовать? Как реализовать в JPA (версионирование, SELECT FOR UPDATE)?",
      "answer": "Оптимистическая — когда конфликтов мало: добавляем поле версии `@Version`, при обновлении версия проверяется. Если кто-то изменил запись — получаем конфликт и повторяем.\n\nПессимистическая — когда конкуренция высокая и конфликт дорогостоящий (деньги/остатки): блокируем строки в БД.\n\nВ JPA:\n- оптимистично: `@Version`.\n- пессимистично: `@Lock(LockModeType.PESSIMISTIC_WRITE)` или `entityManager.find(..., LockModeType.PESSIMISTIC_WRITE)` (в БД это похоже на `SELECT ... FOR UPDATE`)."
    },
    {
      "question": "В Hibernate у сущности есть аннотация @Id со стратегией генерации. Какие стратегии генерации ID помните? Какую рекомендуется использовать с PostgreSQL и почему?",
      "answer": "Стратегии `@GeneratedValue`:\n- `IDENTITY`\n- `SEQUENCE`\n- `TABLE`\n- `AUTO`\n\nДля PostgreSQL обычно рекомендуют `SEQUENCE`, потому что Postgres нативно поддерживает sequences, это хорошо работает с батч-вставками и даёт предсказуемое поведение.\n\n`IDENTITY` тоже работает (через `SERIAL/IDENTITY`), но часто хуже сочетается с батчингом, потому что id получается только после вставки."
    },
    {
      "question": "В Spring Data JPA: как написать простой метод репозитория, чтобы получить всех сотрудников по имени?",
      "answer": "В Spring Data JPA можно сделать derived query по имени метода, например:\n- `List<Employee> findByName(String name);`\n\nЕсли нужно игнорировать регистр:\n- `List<Employee> findByNameIgnoreCase(String name);`\n\nИли более сложное — через `@Query`."
    },
    {
      "question": "Где и как в коде задаются EntityGraph/NamedEntityGraph?",
      "answer": "Два основных варианта:\n- `@NamedEntityGraph` на сущности (задаём имя и атрибуты), а затем используем его в запросе.\n- динамический `@EntityGraph` в Spring Data JPA: на методе репозитория можно указать `@EntityGraph(attributePaths = {\"department\", \"roles\"})`.\n\nЦель — явно сказать, какие связи подгрузить, чтобы избежать N+1."
    },
    {
      "question": "Два метода с @Transactional в одном бине: что произойдёт при внутреннем вызове? Как это обойти?",
      "answer": "Если один метод вызывает другой *внутри того же объекта* (self-invocation), вызов проходит мимо Spring-прокси. В результате аннотация `@Transactional` на вызываемом методе может *не сработать* (не создастся новая транзакция, не применится propagation и т.д.).\n\nКак обойти:\n- вынести метод в другой Spring-бин и вызывать его через DI,\n- использовать `AopContext.currentProxy()` (нежелательно),\n- или изменить дизайн: транзакции на публичных границах сервиса."
    },
    {
      "question": "Если в транзакции загрузили сущность, поменяли поля — нужно ли явно вызывать save()? Почему?",
      "answer": "Обычно нет, если сущность находится в состоянии `managed` внутри persistence context.\n\nHibernate делает dirty checking: при `flush`/`commit` он сам сформирует `UPDATE` по изменившимся полям.\n\n`save()` нужен, когда вы создаёте новую сущность или работаете с detached-сущностью и хотите явно её сохранить/смёржить."
    },
    {
      "question": "Как должна работать @Transactional в показанном месте? Будет ли она реально активна? Почему?",
      "answer": "`@Transactional` в Spring работает через AOP-прокси: транзакция открывается при входе в проксируемый метод и закрывается при выходе.\n\nОна будет активна, если:\n- метод вызван извне через Spring-прокси,\n- метод не `final` (для CGLIB),\n- это публичный метод (по дефолту прокси применяются к public).\n\nНе будет активна при self-invocation (внутреннем вызове) или если объект создан не Spring’ом."
    },
    {
      "question": "Как избежать дедлоков при блокировках сущностей (например, при переводе денег между пользователями)?",
      "answer": "Основные приёмы:\n- всегда захватывать блокировки в одном порядке (например, по меньшему `userId` сначала) — это убирает цикл ожидания,\n- держать транзакцию короткой, не делать под блокировкой внешние вызовы,\n- использовать таймауты блокировок и ретраи при дедлоках,\n- минимизировать область блокировки (блокировать только нужные строки).\n\nДля переводов обычно блокируют обе записи `FOR UPDATE` в фиксированном порядке."
    },
    {
      "question": "Как поведёт себя транзакция, если @Transactional метод вызывается из @PostConstruct?",
      "answer": "`@PostConstruct` вызывается во время инициализации бина, и часто это происходит *до того*, как бин будет полностью «обёрнут» прокси (или вызов идёт внутри самого бина).\n\nПоэтому `@Transactional` в таком вызове обычно не срабатывает как ожидается.\n\nРешения: переносить стартовую логику на события после старта контекста (например, `ApplicationReadyEvent`), `@EventListener`, `CommandLineRunner`, или вызывать транзакционный метод через другой бин."
    },
    {
      "question": "Как работает @Transactional под капотом (прокси, правила rollback, readOnly, изоляция)?",
      "answer": "Spring создаёт прокси вокруг бина. При вызове метода через прокси:\n- открывается/присоединяется транзакция (по propagation),\n- на выходе — `commit`, при исключении — `rollback` по правилам.\n\nRollback по умолчанию:\n- откат на `RuntimeException` и `Error`,\n- checked-исключения по умолчанию не откатывают (можно настроить `rollbackFor`).\n\n`readOnly=true` — подсказка для оптимизаций (например, в Hibernate может отключать dirty checking).\n\nИзоляция задаёт уровень (`READ_COMMITTED`, `SERIALIZABLE` и т.д.), но реально поддержка зависит от БД."
    },
    {
      "question": "Как работает @Transactional: прокси, rollback-правила, уровень изоляции, readOnly?",
      "answer": "Механизм — AOP-прокси: транзакция начинается при входе в метод и завершается при выходе.\n\nRollback:\n- по умолчанию откат на `RuntimeException`/`Error`,\n- на checked — нет (если не настроить `rollbackFor`).\n\nИзоляция определяет, какие аномалии параллельности допустимы (реализуется БД).\n\n`readOnly` — оптимизация/контракт: «мы не пишем». Может улучшить производительность, но не всегда гарантирует запрет записи."
    },
    {
      "question": "Как работает fetch LAZY/EAGER? Проблема N+1 и решения.",
      "answer": "`LAZY` — связь загружается при первом обращении (может привести к дополнительным запросам).\n\n`EAGER` — связь стараются загрузить сразу вместе с сущностью (может раздувать запросы и тянуть лишние данные).\n\nЧастая практика: держать связи `LAZY` по умолчанию и под конкретный кейс подгружать нужное через `JOIN FETCH`, `EntityGraph` или batch fetching, чтобы избежать N+1."
    },
    {
      "question": "Как рефакторить код со @Transactional, чтобы избежать долгих внешних вызовов внутри транзакции?",
      "answer": "Правило: транзакция должна быть короткой и не включать долгие внешние вызовы (HTTP, очереди, файлы).\n\nРефакторинг:\n- вынести внешние вызовы *вне* транзакции,\n- внутри транзакции оставить только работу с БД,\n- если нужно гарантировать «БД + событие» — использовать паттерн outbox/события после коммита (`TransactionSynchronization`).\n\nТак уменьшаем блокировки и риск таймаутов/дедлоков."
    },
    {
      "question": "Какие ещё способы задания EntityGraph есть?",
      "answer": "Основные способы:\n- `@NamedEntityGraph` на сущности + использование по имени.\n- `@EntityGraph` на методе репозитория (Spring Data).\n- динамический граф через `EntityManager.createEntityGraph()` и передачу в query hints.\n\nВсе они помогают управлять fetch-планом и бороться с N+1."
    },
    {
      "question": "Какие состояния жизненного цикла сущности JPA (transient, managed, detached, removed)?",
      "answer": "- `transient` (new): объект создан, но не связан с persistence context.\n- `managed` (persistent): объект в persistence context, изменения отслеживаются.\n- `detached`: объект был managed, но контекст закрыт/очищен; изменения сами не сохранятся.\n- `removed`: помечен на удаление (удалится при flush/commit).\n\nПереходы зависят от `persist`, `merge`, `remove`, закрытия транзакции и т.д."
    },
    {
      "question": "Какие стратегии загрузки связей в JPA/Hibernate (lazy/eager) и как они влияют на производительность?",
      "answer": "Стратегии:\n- `LAZY`: загрузка по требованию → меньше данных сразу, но риск N+1 и `LazyInitializationException` вне транзакции.\n- `EAGER`: загрузка сразу → меньше «сюрпризов», но легко перетащить лишние данные и получить тяжёлые запросы.\n\nПрактика: чаще `LAZY` по умолчанию + явные `fetch join`/`EntityGraph` под нужные сценарии."
    },
    {
      "question": "Какие уровни кэширования есть в Hibernate?",
      "answer": "- Кэш первого уровня (L1) — persistence context, всегда включён, живёт в пределах `Session/EntityManager`.\n- Кэш второго уровня (L2) — общий кэш между сессиями (опционально, нужен провайдер: Ehcache, Hazelcast и т.п.).\n- Query cache — кэш результатов запросов (опционально, обычно используется осторожно).\n\nВажно понимать консистентность и инвалидирование."
    },
    {
      "question": "Какой синтаксис можно использовать в @Query (HQL/JPQL или native SQL)?",
      "answer": "В `@Query` можно писать:\n- JPQL/HQL (работает с сущностями и их полями),\n- native SQL (`nativeQuery = true`) — когда нужен полный контроль или специфичные фичи БД.\n\nJPQL удобен и переносим, native SQL — мощнее, но привязан к конкретной СУБД."
    },
    {
      "question": "Кэш JPA: кэш первого и второго уровня — что это? Как работает @Cacheable в Spring?",
      "answer": "Кэш первого уровня (L1) — persistence context: в рамках одной сессии/транзакции сущность по id обычно не грузится повторно.\n\nКэш второго уровня (L2) — общий кэш между сессиями (если включён и настроен в Hibernate).\n\n`@Cacheable` в Spring — это отдельный механизм кэширования на уровне приложения (обычно в памяти/Redis): он кэширует результат метода по ключу. Это не то же самое, что L1/L2 Hibernate."
    },
    {
      "question": "Нужен ли save() после изменения управляемой сущности в транзакции? Почему?",
      "answer": "Нет, обычно не нужен.\n\nЕсли сущность `managed`, Hibernate отслеживает изменения (dirty checking) и при `flush/commit` сам выполнит `UPDATE`.\n\n`save()` нужен для новых сущностей или когда вы хотите сохранить detached-объект (через `save/merge`)."
    },
    {
      "question": "Отличие save vs saveAndFlush.",
      "answer": "В Spring Data JPA:\n- `save()` сохраняет/обновляет сущность, но SQL может быть отправлен в БД позже — при `flush` или `commit`.\n- `saveAndFlush()` делает `save()` и затем принудительный `flush()` — отправляет изменения в БД сразу.\n\n`flush` не делает `commit`: транзакция всё ещё может быть откатана."
    }
  ]
}
