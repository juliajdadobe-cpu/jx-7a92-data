{
  "Java Stream API": [
    {
      "question": "Стримы: на какие группы делятся операции? Примеры промежуточных и терминальных.",
      "answer": "Операции делятся на промежуточные (intermediate) и терминальные (terminal).\nПромежуточные возвращают новый `Stream` и «настраивают конвейер»: `map`, `filter`, `flatMap`, `sorted`, `distinct`, `limit`, `skip`, `peek`.\nТерминальные запускают выполнение и возвращают результат: `collect`, `forEach`, `count`, `reduce`, `findFirst/findAny`, `anyMatch/allMatch`, `min/max`."
    },
    {
      "question": "Терминальные vs промежуточные операции — примеры.",
      "answer": "Промежуточные: `filter`, `map`, `sorted`, `distinct`, `limit` (возвращают `Stream`).\nТерминальные: `collect(toList())`, `count()`, `forEach(...)`, `reduce(...)`, `findFirst()`."
    },
    {
      "question": "Чем опасен parallelStream() и когда он действительно помогает?",
      "answer": "Опасности: легко получить гонки и баги при shared state (изменение общих коллекций/счётчиков), сложно предсказать порядок, есть накладные расходы на распараллеливание.\n`parallelStream()` помогает, когда:\n- операция CPU-bound и достаточно «тяжёлая»;\n- данных много;\n- нет общего изменяемого состояния;\n- задача хорошо параллелится (мало зависимостей/синхронизаций).\nДля IO-bound задач чаще лучше явный пул/асинхронность, а не параллельные стримы."
    },
    {
      "question": "Чем терминальные операции стримов отличаются от нетерминальных?",
      "answer": "Промежуточные (нетерминальные) операции ленивые: они не выполняют работу сразу и возвращают `Stream`.\nТерминальные операции запускают выполнение всего пайплайна, потребляют стрим и возвращают результат/side-effect.\nПосле терминальной операции стрим использовать нельзя."
    },
    {
      "question": "Чем Stream API отличается от коллекций?",
      "answer": "Коллекция — это структура данных, которая хранит элементы и может использоваться многократно.\n`Stream` — это «конвейер обработки» данных: не хранит элементы сам по себе, а описывает, как их обработать.\nСтримы обычно одноразовые, операции могут быть ленивыми, а вычисление запускается только терминальной операцией."
    },
    {
      "question": "Что возвращают findFirst/findAny? Во что можно собирать стрим (коллекторы)?",
      "answer": "`findFirst()` и `findAny()` возвращают `Optional<T>`.\n`findFirst` старается вернуть первый элемент в порядке стрима; `findAny` может вернуть любой (в parallel обычно быстрее).\nСобирать можно через `collect(...)`: в `List`, `Set`, `Map`, строки (`joining`), группировки (`groupingBy`), подсчёты/суммы/средние (`counting/summing/averaging`), кастомные коллекторы."
    },
    {
      "question": "Что делает Collectors.groupingBy и mapping?",
      "answer": "`groupingBy` группирует элементы по ключу и возвращает `Map<K, List<T>>` (или другой downstream-коллектор).\n`mapping` — это downstream, который сначала преобразует элементы, а потом собирает.\nПример: `groupingBy(User::getRole, mapping(User::getId, toList()))` → `Map<Role, List<Long>>`."
    },
    {
      "question": "Что значит «ленивость» промежуточных операций?",
      "answer": "Ленивость означает: `map/filter/sorted` и т.п. не выполняются сразу.\nОни просто строят пайплайн, а реальная обработка начинается только при терминальной операции (например, `collect`/`count`).\nИз-за этого вычисления часто выполняются «на лету» и могут остановиться раньше (например, `findFirst`, `anyMatch`)."
    },
    {
      "question": "Что такое примитивные стримы и когда их использовать (IntStream, и т.д.)?",
      "answer": "Это специальные стримы для примитивов: `IntStream`, `LongStream`, `DoubleStream`.\nОни помогают избежать автобоксинга/анбоксинга и обычно быстрее/экономнее по памяти.\nИспользуйте, когда много числовых данных и есть операции `sum/average/min/max/range`."
    },
    {
      "question": "Что такое Stream API и зачем он? Промежуточные vs терминальные операции. Ленивость стримов.",
      "answer": "Stream API — функциональный способ обрабатывать последовательности данных через цепочку операций.\nПромежуточные операции (`map`, `filter`, `sorted`...) строят пайплайн и возвращают `Stream`.\nТерминальные (`collect`, `count`, `forEach`, `reduce`...) запускают выполнение.\nПайплайн ленивый: ничего не считается до терминальной операции."
    },
    {
      "question": "Что такое Stream API? Какие бывают промежуточные и терминальные операции?",
      "answer": "Stream API — конвейер обработки данных.\nПромежуточные: `filter/map/flatMap/sorted/distinct/limit/skip/peek`.\nТерминальные: `collect/forEach/count/reduce/findFirst/findAny/anyMatch/allMatch/min/max`."
    },
    {
      "question": "sorted() вызван дважды на числовом стриме — сортировка выполнится один раз или два?",
      "answer": "Дважды: каждый вызов `sorted()` добавляет ещё один stateful-этап пайплайна.\nОптимизация «склеить два sorted в один» не гарантируется спецификацией.\nНа практике второй `sorted()` обычно лишний: сортируйте один раз (или удалите первый, если он не нужен)."
    },
    {
      "question": "Stream API: ленивость, промежуточные и терминальные операции — примеры.",
      "answer": "Пример: `list.stream().filter(x -> x > 0).map(x -> x * 2).limit(10).collect(toList())`.\n`filter/map/limit` — промежуточные и ленивые.\n`collect` — терминальная, запускает обработку.\nЛенивость позволяет не обрабатывать весь список: `limit(10)` остановит конвейер после 10 подходящих элементов."
    },
    {
      "question": "Будет ли гарантирован порядок вывода в примере со стримом и runAsync? Почему?",
      "answer": "Если вы запускаете работу через `runAsync`, порядок вывода между задачами не гарантирован: это разные потоки.\nУ стримов порядок зависит от источника и операций: последовательный стрим по `List` обычно сохраняет encounter order, но параллелизм и `forEach` могут ломать порядок.\nЕсли нужен порядок в параллельном стриме — используйте `forEachOrdered`, но это может снизить параллелизм."
    },
    {
      "question": "В чём разница между map и flatMap на практике?",
      "answer": "`map` превращает каждый элемент в один результат: `T -> R`, итог `Stream<R>`.\n`flatMap` превращает элемент в «много результатов» (стрим/коллекцию) и «сплющивает»: `T -> Stream<R>`, итог тоже `Stream<R>`.\nПример: `map` даст `Stream<List<R>>`, а `flatMap` — `Stream<R>`."
    },
    {
      "question": "В чём разница между peek и map? Какие функциональные интерфейсы они принимают?",
      "answer": "`map` — преобразование элементов, принимает `Function<T,R>`.\n`peek` — для побочных эффектов (обычно отладка/лог), принимает `Consumer<T>` и возвращает тот же элемент без изменения.\nВажно: `peek` выполнится только если есть терминальная операция."
    },
    {
      "question": "Во что можно собирать стрим через collect (варианты целей коллектора)?",
      "answer": "Частые варианты: `toList()`, `toSet()`, `toMap(keyMapper, valueMapper, mergeFn)`, `joining()`, `groupingBy()`, `partitioningBy()`, `counting()`, `summingInt/Long/Double`, `averagingInt/...`, `mapping(...)`, `collectingAndThen(...)`, `reducing(...)`.\nМожно написать и свой коллектор через `Collector.of(...)`."
    },
    {
      "question": "Зачем нужен flatMap и чем он отличается от map?",
      "answer": "`flatMap` нужен, когда один элемент превращается в несколько элементов (коллекция/стрим), и вы хотите получить «плоский» результат.\n`map` оставляет вложенность (например, `Stream<List<T>>`), `flatMap` её убирает (получаете `Stream<T>`)."
    },
    {
      "question": "Как в функциональном стиле (stream) обработать список строк→чисел с возможными ошибками парсинга и сообщить позицию ошибки?",
      "answer": "Один из подходов: стрим по индексам, чтобы сохранить позицию.\nНапример: `IntStream.range(0, list.size()).mapToObj(i -> { try { return parse(list.get(i)); } catch (...) { throw new ParseException(i, list.get(i)); }})...`.\nИдея: индекс берём из `range`, а при ошибке бросаем исключение/возвращаем объект-результат с `index` и причиной."
    },
    {
      "question": "Как отсортировать записи Map по значениям с использованием Stream API?",
      "answer": "Берёте `entrySet().stream()`, сортируете по `Entry::getValue`, затем собираете в `LinkedHashMap`, чтобы сохранить порядок.\nСхема: `map.entrySet().stream().sorted(comparingByValue()).collect(toMap(Entry::getKey, Entry::getValue, (a,b)->a, LinkedHashMap::new))`."
    },
    {
      "question": "Как посчитать количество элементов после фильтрации (count)?",
      "answer": "Используйте `count()` после `filter`: `stream.filter(...).count()`.\n`count()` — терминальная операция и возвращает `long`."
    },
    {
      "question": "Как потокобезопасно вести счётчик в стриме и почему обычный int не подходит?",
      "answer": "Обычный `int` в лямбде при параллельном стриме даст гонки (и в целом не получится менять эффективно из-за требований к effectively final).\nПравильно: избегать сайд-эффектов и использовать терминальные операции (`count`, `sum`, `collect`).\nЕсли очень нужно — `AtomicInteger/LongAdder`, но это обычно хуже по стилю/производительности, чем нормальный `collect/reduce`."
    },
    {
      "question": "Как устроена map/filter/collect под капотом на высоком уровне?",
      "answer": "Стрим строит пайплайн стадий: источник → цепочка промежуточных операций → терминальная операция.\nПри терминальной операции элементы «проталкиваются» через операции по одному (или пачками), применяя `filter/map` и т.д.\n`collect` использует коллектор: создаёт контейнер (supplier), добавляет элементы (accumulator) и при параллелизме объединяет части (combiner)."
    },
    {
      "question": "Какие варианты Collectors/collect ты знаешь (List/Set/Map/кастомный)?",
      "answer": "Стандартные: `toList`, `toSet`, `toCollection`, `toMap`, `joining`, `groupingBy`, `partitioningBy`, `mapping`, `flatMapping` (в новых версиях), `counting`, `summarizingInt/Long/Double`, `summing...`, `averaging...`, `collectingAndThen`.\nКастомный: `Collector.of(supplier, accumulator, combiner[, finisher])`."
    },
    {
      "question": "Какие виды операций в Stream API существуют? Примеры промежуточных и терминальных.",
      "answer": "Два вида: промежуточные и терминальные.\nПромежуточные: `filter`, `map`, `flatMap`, `sorted`, `distinct`, `limit`, `skip`.\nТерминальные: `collect`, `count`, `forEach`, `reduce`, `findFirst/findAny`, `min/max`, `anyMatch`."
    },
    {
      "question": "Какие операции Stream являются stateful? Примеры.",
      "answer": "Stateful — те, которым нужно «состояние»/буфер, чтобы выдать результат: `sorted`, `distinct`, `limit/skip` (часто), `peek` не stateful.\nПример: `sorted` должен увидеть все элементы, чтобы отсортировать; `distinct` хранит уже встреченные элементы."
    },
    {
      "question": "Какие риски у параллельных стримов при работе с shared state и как их избегать?",
      "answer": "Риски: гонки, некорректные результаты, `ConcurrentModificationException`, непредсказуемый порядок, деградация из-за синхронизации.\nИзбегать: не использовать shared mutable state; применять чистые функции; собирать через `collect` с корректным коллектором; для side-effect использовать потокобезопасные структуры или вообще вынести это из стрима."
    },
    {
      "question": "Какие терминальные и промежуточные операции Stream используешь чаще и почему?",
      "answer": "Часто: `filter`, `map`, `flatMap` — потому что это основной способ преобразования данных.\nТерминальные: `collect(toList())/toMap(...)`, `count`, `anyMatch`, `findFirst` — потому что они дают нужный результат (коллекцию/проверку/поиск)."
    },
    {
      "question": "Когда стоит использовать parallel() у стрима? Какие подводные камни (порядок, стоимость, пул)?",
      "answer": "Использовать, когда задача CPU-bound, данных много, операции независимые и без shared state.\nПодводные камни: накладные расходы на распараллеливание, потеря порядка (нужен `forEachOrdered`), работа на общем пуле (`ForkJoinPool.commonPool`), возможная деградация при блокировках/IO."
    },
    {
      "question": "Когда стоит использовать parallelStream()? Подводные камни.",
      "answer": "Когда подходит параллелизм: тяжёлая CPU-работа, много элементов, нет синхронизации/IO.\nПодводные камни: гонки при сайд-эффектах, непредсказуемый порядок, overhead, общий пул потоков, сложнее отлаживать/профилировать."
    },
    {
      "question": "Когда стоит применять примитивные стримы (IntStream/LongStream/DoubleStream)?",
      "answer": "Когда много числовых данных и важны производительность/память: примитивные стримы избегают автобоксинга.\nПолезно для `sum/average/min/max`, диапазонов (`IntStream.range`) и статистики (`summaryStatistics`)."
    },
    {
      "question": "На каком пуле выполняются parallelStream-операции и сколько там потоков по умолчанию?",
      "answer": "По умолчанию parallel stream использует `ForkJoinPool.commonPool`.\nЧисло потоков обычно равно `Runtime.getRuntime().availableProcessors()` (по сути, уровень параллелизма common pool).\nЭто общий пул на весь процесс, поэтому параллельные стримы могут конкурировать с другими задачами."
    },
    {
      "question": "Параллельные стримы: когда уместны, какие риски и подводные камни?",
      "answer": "Уместны для CPU-bound задач с большим объёмом данных и без shared state.\nРиски: гонки/сайд-эффекты, проблемы порядка, overhead, общий пул потоков, плохая масштабируемость при синхронизации.\nЧасто лучше сначала сделать последовательный стрим и измерить, прежде чем включать parallel."
    },
    {
      "question": "Параллельные стримы: на каком пуле выполняются? Имеет ли значение, где ставить parallel()?",
      "answer": "По умолчанию — `ForkJoinPool.commonPool`.\n`parallel()`/`sequential()` — это настройка режима стрима: важен последний вызов перед терминальной операцией.\nГде поставить в цепочке обычно не критично по смыслу (режим применяется ко всему пайплайну), но влияет на читаемость; и помните про операции, где порядок важен."
    },
    {
      "question": "Пользовались ли parallelStream? Зачем он и какие у него минусы?",
      "answer": "Да/можно использовать для ускорения CPU-bound обработки больших коллекций.\nМинусы: сложнее контролировать пул потоков, возможны гонки при сайд-эффектах, непредсказуемый порядок, overhead и иногда даже медленнее последовательного варианта."
    },
    {
      "question": "Почему после терминальной операции стрим «заканчивается»?",
      "answer": "Стрим одноразовый: терминальная операция потребляет источник данных и завершает пайплайн.\nПосле этого использовать тот же `Stream` нельзя (будет `IllegalStateException`). Если нужно повторить — создайте новый стрим из источника."
    }
  ]
}
