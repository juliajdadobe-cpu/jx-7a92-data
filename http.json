{
  "HTTP": [
    {
      "question": "Что значит, что HTTP «синхронный» на уровне протокола?",
      "answer": "HTTP — запросно-ответный протокол: на один запрос клиент ожидает один ответ. В этом смысле взаимодействие «синхронное» по модели протокола.\n\nНо в приложении это можно реализовать по-разному:\n- блокирующе (поток ждёт ответ),\n- асинхронно/неблокирующе (мы не блокируем поток, а получаем ответ позже через callback/`Future`).\n\nТо есть синхронность/асинхронность — чаще про *клиентскую реализацию*, а не про сам HTTP как протокол."
    },
    {
      "question": "Что такое connect/read timeout и зачем их настраивать?",
      "answer": "`connect timeout` — максимум времени на установление TCP-соединения.\n\n`read timeout` (или `response timeout`) — максимум времени ожидания данных/ответа после подключения.\n\nЗачем: чтобы запросы не «висели» бесконечно из-за проблем сети/сервиса. Таймауты защищают потоки и ресурсы, повышают стабильность и позволяют включать ретраи/фоллбеки."
    },
    {
      "question": "HTTP: из чего состоит запрос/ответ? Идемпотентность методов?",
      "answer": "HTTP-запрос состоит из:\n- стартовой строки: метод + путь + версия,\n- заголовков (headers),\n- тела (body) — опционально.\n\nHTTP-ответ:\n- статусная строка (код + reason phrase),\n- заголовки,\n- тело (опционально).\n\nИдемпотентность: повторный одинаковый запрос даёт тот же эффект на сервере.\nОбычно идемпотентны `GET`, `HEAD`, `PUT`, `DELETE` (по смыслу), `OPTIONS`. `POST` обычно не идемпотентен."
    },
    {
      "question": "В чём разница REST и RPC подходов?",
      "answer": "REST — ориентирован на *ресурсы* и стандартные операции над ними: URL описывает ресурс, а действие задаётся HTTP-методом (`GET/POST/PUT/DELETE`). Часто используется единый стиль ошибок, коды статусов, кэширование.\n\nRPC — ориентирован на *вызов методов*: есть «команды»/процедуры (например, `/createUser`, `/calculatePrice`). Обычно меньше ограничений по стилю, проще моделировать сложные операции.\n\nНа практике REST — чаще для публичных API и простых CRUD, RPC — для внутреннего взаимодействия сервисов/командных операций."
    },
    {
      "question": "Как бы спроектировать идемпотентную REST-операцию?",
      "answer": "Есть два основных подхода:\n\n1) Сделать операцию идемпотентной по природе:\n- использовать `PUT` для «установить состояние» по стабильному ключу ресурса (`PUT /orders/{id}`),\n- `DELETE /resource/{id}` — повторный delete не должен ломать систему.\n\n2) Идемпотентность для `POST` через idempotency key:\n- клиент передаёт заголовок `Idempotency-Key` (уникальный ключ),\n- сервер сохраняет результат обработки по ключу и при повторе возвращает тот же результат,\n- важно хранить ключ с TTL и делать операцию атомарной (например, через уникальный индекс/транзакцию)."
    },
    {
      "question": "Как из сервиса отправить HTTP-запрос в другой сервис? Какими клиентами/подходами можно пользоваться?",
      "answer": "В Java/Spring обычно используют:\n- `RestTemplate` (устаревает, но встречается),\n- `WebClient` (Spring WebFlux, умеет неблокирующе),\n- `HttpClient` из `java.net.http` (Java 11+),\n- декларативные клиенты: OpenFeign.\n\nПодходы:\n- синхронно (блокирующий вызов) или асинхронно,\n- добавить таймауты, ретраи (осторожно), circuit breaker, логирование/трейсинг,\n- использовать пул соединений (keep-alive) и лимиты."
    },
    {
      "question": "Как настроить пулы потоков для WebClient/Netty?",
      "answer": "`WebClient` на Reactor Netty использует event-loop (Netty). По умолчанию он рассчитан на неблокирующую обработку.\n\nВажные правила:\n- не выполнять блокирующие операции на event-loop (иначе «замораживаем» обработку).\n- для блокирующих задач переносить работу на отдельный пул: `publishOn/subscribeOn` и `Schedulers.boundedElastic()` или свой `Executor`.\n\nТонкие настройки (обычно нужны редко):\n- ограничение соединений/пул соединений через `ConnectionProvider`,\n- настройка количества event-loop threads (через `LoopResources` или системные свойства в зависимости от конфигурации)."
    },
    {
      "question": "По HTTP: какими способами можно передать данные на сервер?",
      "answer": "Основные способы:\n- в URL: path-параметры (`/users/{id}`) и query-параметры (`?page=1`).\n- в заголовках (например, `Authorization`, `If-Match`, `Idempotency-Key`).\n- в теле запроса: JSON/XML, form-data (`multipart/form-data` для файлов), `application/x-www-form-urlencoded`.\n- в cookies.\n\nВыбор зависит от семантики: идентификаторы/фильтры — чаще в URL, содержимое — в body, метаданные — в headers."
    },
    {
      "question": "Что такое CORS, для чего он нужен и как настраивается в Spring Security?",
      "answer": "CORS (Cross-Origin Resource Sharing) — механизм браузера, который ограничивает запросы с одного origin (scheme+host+port) к другому. Сервер должен явно разрешить такие запросы через CORS-заголовки.\n\nНужен для фронтенда, который ходит на API с другого домена/порта.\n\nВ Spring Security обычно:\n- включают `cors()` и задают `CorsConfigurationSource` (allowed origins, methods, headers, credentials),\n- учитывают preflight-запросы `OPTIONS`.\n\nВажно: CORS — это про браузер; сервер-сервер запросы CORS не «блокирует»."
    }
  ]
}
