{
  "Java Core": [
    {
      "question": "Что такое LTS в контексте Java и что это означает для разработчиков?",
      "answer": "LTS (Long-Term Support) — релиз Java с длительной поддержкой: для него дольше выходят обновления безопасности и исправления. Обычно для продакшена выбирают LTS (меньше рисков и дольше поддержка), а не‑LTS — когда нужно быстрее получить фичи и есть план частых обновлений. Примеры LTS: 8, 11, 17, 21."
    },
    {
      "question": "Аргументы в Java передаются по значению или по ссылке? Объясни на примерах с примитивом и массивом.",
      "answer": "В Java всегда передача по значению. Для примитива копируется само значение: `void inc(int x){x++;}` не изменит исходную переменную. Для объектов/массивов копируется значение ссылки: можно менять содержимое массива (`a[0]=...`) и это увидит вызывающий код, но если присвоить параметру новую ссылку (`a = new int[10]`), исходная переменная снаружи не изменится."
    },
    {
      "question": "В чём отличие примитивных и ссылочных типов в Java?",
      "answer": "Примитивы хранят само значение и не могут быть `null`. Ссылочные типы хранят ссылку на объект, могут быть `null`, имеют идентичность (две ссылки могут указывать на один объект) и обычно сравниваются по содержимому через `equals()`."
    },
    {
      "question": "В чём разница между JDK и JRE?",
      "answer": "JRE — среда выполнения (JVM + стандартные библиотеки), чтобы запускать уже собранные приложения. JDK — комплект разработчика: включает JRE и инструменты (например, `javac`, `jar`, `javadoc`, отладчики)."
    },
    {
      "question": "Для чего нужен компилятор javac и во что он преобразует исходный код?",
      "answer": "`javac` компилирует исходники `.java` в байткод `.class`. Этот байткод затем выполняет JVM (интерпретирует и JIT-компилирует «горячие» участки в машинный код)."
    },
    {
      "question": "Для чего нужен Reflection API?",
      "answer": "Reflection позволяет в рантайме узнать структуру классов (поля/методы/аннотации), создавать объекты и вызывать методы динамически. Это нужно фреймворкам (DI, ORM, сериализация), плагинам и тестам. Минусы: медленнее, сложнее читать, может ломать инкапсуляцию и упираться в ограничения модулей/доступа."
    },
    {
      "question": "Для чего нужны аннотации? Как ограничить место применения (Target)?",
      "answer": "Аннотации — метаданные для компилятора, инструментов и/или рантайма (например, `@Override`, `@Deprecated`, `@Autowired`). Ограничить, где аннотацию можно ставить, можно через `@Target(...)`, например `@Target({ElementType.METHOD, ElementType.FIELD})`."
    },
    {
      "question": "Есть ли в Java беззнаковые (unsigned) типы? Какие?",
      "answer": "Отдельных беззнаковых примитивов типа `uint` в Java нет. По смыслу беззнаковый: `char` (16 бит, 0…65535). Для «unsigned» арифметики есть методы в `Integer`/`Long`: `compareUnsigned`, `toUnsignedString`, `divideUnsigned`, `remainderUnsigned`; «unsigned int» часто хранят в `long`."
    },
    {
      "question": "Жизненный цикл сервлета: какие три метода и их назначение? (init, service, destroy)",
      "answer": "`init()` вызывается один раз при создании сервлета (инициализация). `service()` вызывается на каждый запрос (в `HttpServlet` обычно делегирует в `doGet/doPost/...`). `destroy()` вызывается при остановке/выгрузке сервлета (освобождение ресурсов)."
    },
    {
      "question": "Зачем нужны классы-обёртки примитивов и где они необходимы?",
      "answer": "Обёртки (Integer, Long, Boolean и т.д.) нужны, когда требуется объект: в дженериках/коллекциях (`List<Integer>`), чтобы иметь `null`, для рефлексии и утилит (парсинг/сравнение). Автоупаковка удобна, но может давать лишние аллокации и NPE при распаковке `null`."
    },
    {
      "question": "К каким конструкциям применим модификатор static (поля, методы, классы, блоки и т. п.)?",
      "answer": "`static` применим к полям (одно значение на класс), методам (вызов без объекта), вложенным классам (static nested class) и статическим блокам инициализации (`static { ... }`). К top-level классам `static` не применим. В интерфейсах поля неявно `public static final`, методы могут быть `static` и `default`."
    },
    {
      "question": "Как в новых версиях Java удобно создавать неизменяемые объекты (каким механизмом)?",
      "answer": "Для «data»-объектов удобно использовать `record` (Java 16+): поля `final`, генерируются конструктор/аксессоры/equals/hashCode/toString. Для неизменяемых коллекций — фабрики `List.of(...)`, `Set.of(...)`, `Map.of(...)`, а также `Stream.toList()` (возвращает неизменяемый список)."
    },
    {
      "question": "Как в Java представляются отрицательные целые числа (какой код)?",
      "answer": "Отрицательные целые в Java представлены в дополнительном коде (two’s complement). Это важно для побитовых операций: старший бит — знак, а переполнение происходит по модулю 2^N (N — число бит)."
    },
    {
      "question": "Как выбрать между конкатенацией строк, StringBuilder и String.format() в разных сценариях?",
      "answer": "Если строк немного и выражение простое — `+` читаем и компилятор часто оптимизирует его. Если конкатенация в цикле/в большом количестве — лучше `StringBuilder` (меньше лишних объектов). `String.format()` удобен для форматирования (числа, выравнивание, Locale), но обычно медленнее и тяжелее по накладным расходам."
    },
    {
      "question": "Как гарантированно получить строку из пула?",
      "answer": "Гарантированно получить каноническую строку из пула можно через `s.intern()`. Строковые литералы (`\"abc\"`) и константные выражения уже берутся из пула; `new String(\"abc\")` создаёт новый объект, пока не вызвать `intern()`."
    },
    {
      "question": "Как запустить виртуальную машину Java из командной строки?",
      "answer": "Через команду `java`: `java -version` (проверка), `java -cp <classpath> com.example.Main` (запуск класса с `main`), `java -jar app.jar` (запуск JAR). Для компиляции — `javac ...`, а в Java 11+ можно запустить один файл напрямую: `java Hello.java`."
    },
    {
      "question": "Как избежать деградации при конкатенации строк в цикле? Чем StringBuilder отличается от StringBuffer?",
      "answer": "В цикле вместо `result += part` используйте `StringBuilder`: он накапливает символы в изменяемом буфере и создаёт итоговую строку один раз через `toString()`. `StringBuffer` похож, но его методы синхронизированы (потокобезопаснее при совместном доступе), поэтому обычно медленнее; в большинстве случаев хватает `StringBuilder`."
    },
    {
      "question": "Как работает механизм varargs: во что трансформируется и какие накладные расходы/ограничения есть?",
      "answer": "Varargs — синтаксический сахар: параметр `foo(String... args)` внутри метода — это обычный массив `String[]`. Ограничения: varargs должен быть последним параметром; при вызове часто создаётся новый массив (аллокация); перегрузки с varargs иногда дают неоднозначность."
    },
    {
      "question": "Как сделать аннотацию доступной во время выполнения (Retention)? Какие уровни retention существуют?",
      "answer": "Нужно указать `@Retention(RetentionPolicy.RUNTIME)` — тогда аннотацию можно читать рефлексией в рантайме. Уровни: `SOURCE` (только в исходниках), `CLASS` (в байткоде), `RUNTIME` (доступна во время выполнения)."
    },
    {
      "question": "Как сервлет обрабатывает многопоточность: по одному потоку на запрос?",
      "answer": "Обычно контейнер использует пул потоков: один запрос обслуживает один поток, но один и тот же экземпляр сервлета может параллельно обрабатывать много запросов. Поэтому нельзя хранить состояние запроса в полях сервлета; используйте локальные переменные и thread-safe зависимости."
    },
    {
      "question": "Как устроен StringBuilder под капотом?",
      "answer": "`StringBuilder` хранит изменяемый буфер символов (внутри — массив), имеет `length` и `capacity`. При `append()` при необходимости расширяет буфер (обычно примерно в 2 раза) и копирует данные. `toString()` создаёт новый `String` с текущим содержимым."
    },
    {
      "question": "Какие классификации типов данных есть в Java? Перечисли основные типы.",
      "answer": "Базовая классификация: примитивные типы и ссылочные типы. Примитивы: `byte, short, int, long, float, double, char, boolean`. Ссылочные: классы (в т.ч. `String`), интерфейсы, массивы, `enum`, `record`."
    },
    {
      "question": "Какие ключевые методы есть у Object (toString, equals, hashCode) и для чего они?",
      "answer": "`toString()` — строковое представление объекта (логи/отладка). `equals()` — логическое равенство (обычно по значимым полям). `hashCode()` — хэш для хеш-коллекций (HashMap/HashSet) и должен быть согласован с `equals()`."
    },
    {
      "question": "Какие новые фичи в Java вы знаете/используете (например, var, structured concurrency)?",
      "answer": "Примеры (достаточно назвать 5–7 и кратко зачем): `var`, `record`, switch expressions, text blocks, sealed classes, pattern matching (instanceof/switch), новый HTTP Client (Java 11), виртуальные потоки (Project Loom), structured concurrency (как концепция/превью — группировать параллельные задачи как единое целое)."
    },
    {
      "question": "Какими методами и контрактами обладает базовый класс Object?",
      "answer": "Ключевые методы: `equals`, `hashCode`, `toString`, `getClass`, `wait/notify/notifyAll` (монитор), `clone` (protected, при `Cloneable`), `finalize` (устаревший). Контракты: свойства `equals` (рефлексивность/симметричность/транзитивность/консистентность/неравенство с null) и связь `equals`↔`hashCode`."
    },
    {
      "question": "Какими функциональными интерфейсами пользуетесь? Примеры (Function, BiFunction, Supplier, Consumer и т.д.)",
      "answer": "Частые: `Function<T,R>`, `BiFunction<T,U,R>`, `Predicate<T>`, `Supplier<T>`, `Consumer<T>`, `UnaryOperator<T>`/`BinaryOperator<T>`, `Comparator<T>`, `Runnable`/`Callable<V>`. Встречаются в Stream API, `Optional`, `CompletableFuture`, коллекциях (например, `Map.computeIfAbsent`)."
    },
    {
      "question": "Каковы издержки иммутабельности строк и как их обходят (builder/buffer)?",
      "answer": "Иммутабельность означает: любая «модификация» создаёт новый `String`, поэтому при частой конкатенации появляются лишние аллокации и нагрузка на GC. Обход: `StringBuilder`/`StringBuffer` для сборки, `StringJoiner`/`String.join` для списков строк, а `String.format()` — когда нужно форматирование."
    },
    {
      "question": "Какой ключевой default-метод появился в Java 8 (в Collection)?",
      "answer": "В Java 8 в `Collection` появились важные default-методы: `stream()`/`parallelStream()` (основа Stream API) и `removeIf(Predicate)` для удаления по условию. Это позволило расширить интерфейс без поломки старых реализаций."
    },
    {
      "question": "Когда выбирать Comparable, а когда — Comparator? Какой паттерн реализует Comparator?",
      "answer": "`Comparable` реализуют в классе, когда есть «естественный» порядок и он один. `Comparator` используют, когда порядок внешний или вариантов несколько (по имени, по дате, по сумме) — его можно передать в сортировку и комбинировать `thenComparing`. `Comparator` — пример паттерна Strategy (стратегия сравнения)."
    },
    {
      "question": "Когда выбирать StringBuilder vs StringBuffer?",
      "answer": "Почти всегда — `StringBuilder`: быстрее, без синхронизации, отлично подходит для локальной сборки строки в одном потоке. `StringBuffer` синхронизирован и нужен редко — только при реальном совместном доступе нескольких потоков к одному буферу."
    },
    {
      "question": "Когда два объекта могут иметь одинаковый hashCode(), но быть не равны по equals()?",
      "answer": "Это нормально и возможно всегда: `hashCode` — значение типа `int`, поэтому коллизии неизбежны. Важно лишь правило: если `equals()` возвращает `true`, то `hashCode()` обязан быть одинаковым; обратное не требуется."
    },
    {
      "question": "Когда и зачем в Java добавили default-методы в интерфейсах?",
      "answer": "Default-методы добавили в Java 8, чтобы можно было развивать интерфейсы (добавлять методы) и не ломать существующие реализации. Это было критично для Collections и появления Stream API."
    },
    {
      "question": "Когда следует переопределять toString, equals, hashCode, compareTo?",
      "answer": "`toString` — когда нужен удобный вывод (логи/отладка). `equals`/`hashCode` — когда сравниваем объекты «по значению» и/или используем их в `HashMap/HashSet`. `compareTo` — когда нужен естественный порядок сортировки (и лучше, чтобы он не противоречил `equals`, если это важно для логики)."
    },
    {
      "question": "Контракт equals/hashCode: почему важен и что нарушится при его несоблюдении?",
      "answer": "Хеш-коллекции сначала используют `hashCode`, затем `equals`. Если равные по `equals` объекты имеют разные `hashCode`, элемент может «потеряться»: не найдётся по ключу, появятся дубликаты в set. Если `hashCode` зависит от изменяемых полей и объект меняется после добавления в map/set — он тоже может «потеряться»."
    },
    {
      "question": "Контракт equals/hashCode: что он гарантирует?",
      "answer": "Если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()` обязательно. Если `a.equals(b) == false`, `hashCode` может совпасть (коллизия). Также `equals` должен быть рефлексивным/симметричным/транзитивным/консистентным и возвращать `false` при сравнении с `null`."
    },
    {
      "question": "Может ли абстрактный класс быть final? А абстрактные методы — какими могут/не могут быть?",
      "answer": "Класс не может быть одновременно `abstract` и `final`: `abstract` требует наследников, `final` запрещает наследование. Абстрактный метод не может быть `final`, `private` или `static`, но может быть `public` или `protected`."
    },
    {
      "question": "Может ли класс быть static?",
      "answer": "Топ‑левел класс не может быть `static`. `static` может быть только у вложенного (nested) класса: `static class Inner { ... }`. Такой класс не держит неявной ссылки на внешний объект."
    },
    {
      "question": "Можно ли вызвать приватный метод/изменить приватное поле? Что нужно сделать (например, setAccessible)?",
      "answer": "Да, через рефлексию: получить `Method/Field`, сделать доступным (`setAccessible(true)`/`trySetAccessible()`), затем `invoke`/`get`/`set`. Но это ломает инкапсуляцию и в новых Java может быть ограничено модульной системой и настройками доступа."
    },
    {
      "question": "Можно ли класс объявить final и abstract одновременно? Почему?",
      "answer": "Нет. `abstract` требует наследника для реализации/создания экземпляра, а `final` запрещает наследование."
    },
    {
      "question": "Можно ли наследоваться от String? Почему?",
      "answer": "Нельзя: `String` объявлен `final`. Это сделано ради безопасности и предсказуемости (нельзя подменить поведение строки), а также ради оптимизаций (пул строк, кеширование хэша)."
    },
    {
      "question": "Можно ли переопределить статический метод? Чем override отличается от hiding?",
      "answer": "Статический метод нельзя переопределить (override) — можно только «скрыть» (method hiding), объявив метод с тем же именем в наследнике. Override выбирается по реальному типу объекта (рантайм), hiding — по типу ссылки (компиляция)."
    },
    {
      "question": "Можно ли понижать модификатор доступа при override?",
      "answer": "Нельзя: при переопределении нельзя делать метод менее доступным (например, `public` → `protected`). Можно оставить как есть или расширить доступ (например, `protected` → `public`)."
    },
    {
      "question": "Можно ли при переопределении метода сузить/расширить модификатор доступа? Какой принцип ООП нарушим при сужении?",
      "answer": "Расширить доступ можно, сузить — нельзя. Сужение нарушит принцип подстановки Лисков (LSP): наследник перестанет быть полноценной заменой базового типа."
    },
    {
      "question": "Можно ли свой класс использовать в for-each? Что нужно реализовать (Iterable/Iterator)?",
      "answer": "Да. Реализуйте `Iterable<T>` и верните `Iterator<T>` в `iterator()`. Тогда `for (T x : obj)` будет работать (компилятор разворачивает цикл в `iterator()/hasNext()/next()`)."
    },
    {
      "question": "Можно ли сузить или расширить модификатор доступа при переопределении метода? Почему?",
      "answer": "Расширить — да, сузить — нет. Иначе клиенты, которые могут вызывать метод у базового класса, не смогут вызывать его у наследника через тот же базовый тип."
    },
    {
      "question": "Обязательно ли всегда закрывать поля? Можно ли организовать инкапсуляцию на уровне пакета? Какой модификатор доступа используется?",
      "answer": "Обычно поля делают `private`, чтобы контролировать инварианты. Но можно делать инкапсуляцию на уровне пакета: package-private (без модификатора) — доступен только внутри того же пакета."
    },
    {
      "question": "Переопределение vs перегрузка. Перегружается ли конструктор?",
      "answer": "Override — в наследнике меняем реализацию метода с той же сигнатурой (выбор в рантайме). Overload — методы/конструкторы с одним именем, но разными параметрами (выбор на этапе компиляции). Конструкторы можно перегружать, но нельзя переопределять."
    },
    {
      "question": "Перечисли и объясни принципы ООП: инкапсуляция, наследование, полиморфизм.",
      "answer": "Инкапсуляция — скрываем внутреннее состояние и даём управляемый интерфейс. Наследование — расширяем/переиспользуем поведение через базовый класс/интерфейсы. Полиморфизм — работаем через общий тип, а конкретная реализация выбирается в рантайме."
    },
    {
      "question": "Перечисли примитивные типы.",
      "answer": "`byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`."
    },
    {
      "question": "Почему в Java нет множественного наследования? Как добиваться похожего эффекта?",
      "answer": "Множественное наследование классов усложняет модель и даёт конфликты реализаций (проблема «ромба»). Похожего эффекта добиваются интерфейсами (в т.ч. default-методы) и композицией/делегированием."
    },
    {
      "question": "Почему конкатенация строк в цикле — анти-паттерн? Чем заменить?",
      "answer": "Потому что `String` неизменяем: `s = s + x` создаёт новый объект на каждой итерации и копирует данные, что даёт много мусора и может деградировать по времени. Заменять на `StringBuilder` (или `StringBuffer`, если реально нужен общий потокобезопасный буфер), а для списков строк — `StringJoiner`/`String.join`."
    },
    {
      "question": "Почему конкатенация строк в цикле — антипаттерн?",
      "answer": "Из-за иммутабельности `String`: каждое `+` создаёт новую строку и копирует старое содержимое, поэтому легко получить квадратичную деградацию и нагрузку на GC. Правильный инструмент для накопления — `StringBuilder`."
    },
    {
      "question": "Почему нельзя использовать оператор == для сравнения объектов в Java?",
      "answer": "`==` для ссылочных типов сравнивает ссылки (один и тот же объект или нет), а не содержимое. Для «сравнения по значению» используется `equals()` (если он корректно реализован)."
    },
    {
      "question": "Почему нельзя сравнивать объекты оператором ==?",
      "answer": "Потому что `==` проверяет идентичность (одинаковая ссылка), а не равенство по смыслу. Два разных объекта с одинаковыми полями будут `== false`, но могут быть `equals() == true`."
    },
    {
      "question": "Почему объекты нельзя сравнивать через ==?",
      "answer": "Потому что `==` не знает «смысл» равенства и сравнивает только адрес/ссылку. Для смыслового сравнения нужен `equals()` (и согласованный `hashCode()` для хеш-коллекций)."
    },
    {
      "question": "Почему предпочтительнее использовать коллекции/дженерики вместо массивов?",
      "answer": "Коллекции удобнее: динамический размер, богатый API, разные реализации (List/Set/Map). Дженерики дают безопасность типов на этапе компиляции (`List<String>`), тогда как массивы фиксированного размера и требуют больше ручного кода."
    },
    {
      "question": "Почему при переопределении equals() обычно нужно переопределять и hashCode()?",
      "answer": "Потому что действует контракт: если объекты равны по `equals()`, их `hashCode()` должен совпадать. Иначе `HashMap`/`HashSet` могут работать некорректно: объект не будет находиться или в set появятся логические дубликаты."
    },
    {
      "question": "Почему строки нельзя сравнивать через ==? Какие виды сравнения есть? Что сравнивает String.equals()?",
      "answer": "`==` сравнивает ссылки: две строки с одинаковым текстом могут быть разными объектами. Виды сравнения: по ссылке (`==`), по содержимому (`equals`), лексикографически (`compareTo`). `String.equals()` сравнивает последовательность символов (содержимое), а не адрес."
    },
    {
      "question": "Почему Comparator удобен как функциональный интерфейс и как это влияет на способы сортировки?",
      "answer": "`Comparator` — функциональный интерфейс (один абстрактный метод `compare`), поэтому его удобно задавать лямбдой/ссылкой на метод: `Comparator.comparing(User::getName)`. Это упрощает сортировки и позволяет легко комбинировать критерии (`thenComparing`, `reversed`)."
    },
    {
      "question": "Почему String иммутабелен и какие плюсы это даёт (потоки, хеши, безопасность)?",
      "answer": "Иммутабельность `String` даёт: потокобезопасность (можно свободно шарить между потоками), возможность кешировать `hashCode` и эффективно использовать строки как ключи, безопасность (строка не «поменяется» после передачи в API), и возможность пула строк."
    },
    {
      "question": "Почему String иммутабельный и какие плюсы это даёт?",
      "answer": "Плюсы: проще reasoning (нет скрытых изменений), потокобезопасность, удобство как ключа в Map, кеширование хэша, пул строк и экономия памяти на повторяющихся значениях. Минус — при частой «модификации» создаются новые объекты, поэтому для сборки используют `StringBuilder`."
    },
    {
      "question": "Почему String immutable и final?",
      "answer": "`immutable` — чтобы содержимое не менялось после создания (безопасность, потокобезопасность, кеширование хэша, пул строк). `final` — чтобы нельзя было наследованием подменить поведение и нарушить эти гарантии."
    },
    {
      "question": "Почему String immutable? Плюсы и минусы иммутабельности строк.",
      "answer": "Плюсы: потокобезопасность, безопасное использование как ключа, кеширование `hashCode`, пул строк, предсказуемость. Минусы: при конкатенации/изменениях создаётся много объектов и копирований; обход — `StringBuilder`/`StringJoiner`."
    },
    {
      "question": "Приведи примеры билдера в стандартной Java.",
      "answer": "Примеры builder-подхода: `StringBuilder`/`StringBuffer` (сборка строк), `StringJoiner` (соединение с разделителем), `ProcessBuilder` (настройка процесса), `Locale.Builder`."
    },
    {
      "question": "Работает ли for-each без итератора? Как связаны Iterable и Iterator?",
      "answer": "Для коллекций for-each работает через итератор: объект должен быть `Iterable`, чтобы предоставить `Iterator`. Компилятор превращает `for (x : iterable)` в вызовы `iterator()`, затем `hasNext()`/`next()`. Для массивов итератор не нужен — там индексный перебор."
    },
    {
      "question": "Разница между интерфейсами Iterable и Iterator?",
      "answer": "`Iterable<T>` — «это можно перебирать» и содержит `iterator()`. `Iterator<T>` — «как именно перебирать»: `hasNext()`, `next()` (и иногда `remove()`)."
    },
    {
      "question": "Разница создания строк: литерал vs new String(...)?",
      "answer": "Литерал (`\"abc\"`) обычно берётся из пула строк: одинаковые литералы ссылаются на один объект. `new String(\"abc\")` всегда создаёт новый объект в куче; при необходимости можно получить каноническую строку через `intern()`."
    },
    {
      "question": "Разница final, finally, finalize (и почему finalize не использовать).",
      "answer": "`final` — модификатор (запрет наследования/переопределения или переназначения). `finally` — блок, который выполняется после `try/catch`. `finalize()` — устаревший механизм «финализации» перед GC: непредсказуем, тормозит и может не вызваться; в современном коде не используют (предпочитать try-with-resources)."
    },
    {
      "question": "Разница String, StringBuilder, StringBuffer и где какой использовать?",
      "answer": "`String` — неизменяемая строка для обычного использования. `StringBuilder` — изменяемый буфер без синхронизации: лучший выбор для сборки строк в одном потоке (особенно в цикле). `StringBuffer` — синхронизированный вариант: нужен редко при совместном доступе нескольких потоков к одному буферу."
    },
    {
      "question": "Реализуйте мини-Optional: дженерик-класс с value, методами map и filter (как в java.util.Optional).",
      "answer": "Идея: хранить `T value` (может быть `null`) и операции, которые безопасно пропускают отсутствие значения. Мини-скелет: `final class MiniOptional<T>{ private final T value; static <T> MiniOptional<T> ofNullable(T v){...} <R> MiniOptional<R> map(Function<? super T,? extends R> f){ return value==null? ofNullable(null): ofNullable(f.apply(value)); } MiniOptional<T> filter(Predicate<? super T> p){ return value!=null && p.test(value) ? this : ofNullable(null); } }`."
    },
    {
      "question": "Чем отличается ссылочное сравнение от сравнения «по значению» и как это связано с методом equals()?",
      "answer": "Ссылочное сравнение (`==`) проверяет, один и тот же объект в памяти или нет. Сравнение «по значению» — логическое равенство содержимого и реализуется через `equals()`. Если класс хочет «value semantics», он переопределяет `equals()` (и `hashCode()`)."
    },
    {
      "question": "Чем отличаются final, finally и finalize?",
      "answer": "`final` — запрет изменений (наследования/переопределения/переназначения). `finally` — блок в обработке исключений, обычно для освобождения ресурсов. `finalize()` — устаревший метод, который мог вызываться перед сборкой мусора; сейчас не используется."
    },
    {
      "question": "Чем отличаются StringBuilder и StringBuffer? Какой из них потокобезопасен?",
      "answer": "`StringBuilder` быстрее, но не потокобезопасен при совместном доступе. `StringBuffer` синхронизирован, поэтому потокобезопаснее (на уровне методов), но обычно медленнее. В практике чаще используют `StringBuilder` локально в методе."
    },
    {
      "question": "Чем перегрузка отличается от переопределения?",
      "answer": "Перегрузка (overload) — один метод/конструктор с разными параметрами (выбор на этапе компиляции). Переопределение (override) — метод в наследнике с той же сигнатурой, но другой реализацией (выбор в рантайме)."
    },
    {
      "question": "Чем abstract класс отличается от interface?",
      "answer": "Абстрактный класс может иметь состояние (поля), конструкторы и частичную реализацию; наследоваться можно только от одного класса. Интерфейс задаёт контракт и позволяет множественную реализацию; может иметь `default`/`static` методы, но обычно не хранит состояние (кроме констант)."
    },
    {
      "question": "Чем String отличается от StringBuilder и StringBuffer по назначению и потокобезопасности?",
      "answer": "`String` неизменяем и поэтому потокобезопасен «по природе». `StringBuilder` — для эффективной сборки/изменения строк в одном потоке. `StringBuffer` — как builder, но с синхронизацией методов для более безопасного совместного доступа."
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации + «под капотом»?",
      "answer": "В простых выражениях компилятор часто превращает `a + b + c` в использование `StringBuilder` внутри одной операции. Но в цикле `s = s + x` на каждой итерации создаёт новые объекты/билдеры и копирует данные. Явный `StringBuilder` позволяет переиспользовать один буфер."
    },
    {
      "question": "Чем StringBuilder отличается от конкатенации строк через + в цикле?",
      "answer": "`StringBuilder` накапливает результат в одном изменяемом буфере, а `+` в цикле создаёт новую строку и копирует старое содержимое на каждой итерации. Поэтому `StringBuilder` обычно намного быстрее и экономит память."
    },
    {
      "question": "Что будет, если hashCode() всегда возвращает константу? Это корректно?",
      "answer": "Формально корректно, но очень плохо по производительности: все ключи попадают в один бакет, и операции в `HashMap/HashSet` деградируют до O(n). В реальном коде так делать нельзя."
    },
    {
      "question": "Что делает блок finally? Всегда ли нужен для закрытия ресурсов?",
      "answer": "`finally` обычно используют для гарантированного освобождения ресурсов после `try/catch`. Но для `Closeable/AutoCloseable` сейчас лучше `try-with-resources` — он короче и правильно обрабатывает исключения при закрытии. `finally` может не выполниться при аварийном завершении JVM (например, `kill -9`)."
    },
    {
      "question": "Что делает intern()?",
      "answer": "`intern()` возвращает каноническую строку из пула строк: если такая строка уже есть в пуле — вернёт её, иначе добавит и вернёт. Это помогает экономить память на повторяющихся строках, но может раздувать пул, поэтому применять нужно осознанно."
    },
    {
      "question": "Что делает String#intern() и когда его использовать?",
      "answer": "`String.intern()` привязывает строку к пулу и возвращает общую (каноническую) ссылку. Использовать стоит редко: когда действительно много повторяющихся строк и набор значений ограничен; иначе можно получить лишнюю нагрузку и память."
    },
    {
      "question": "Что значит «иммутабельный класс» и как вручную сделать класс иммутабельным в Java?",
      "answer": "Иммутабельный класс — объект нельзя изменить после создания. Как сделать: класс `final` (или запретить расширение), поля `private final`, инициализация только в конструкторе, нет сеттеров, для массивов/коллекций — defensive copy (и в конструкторе, и в геттерах), не отдавать наружу мутабельные внутренности."
    },
    {
      "question": "Что обязательно проверять при реализации equals() (null, тип и т.д.)?",
      "answer": "Обычно: (1) `this == o` → `true`; (2) `o == null` → `false`; (3) проверка типа (`getClass()` или `instanceof` — зависит от наследования); (4) сравнение значимых полей (с учётом `null`); (5) соблюдение контракта `equals`. И почти всегда вместе с `equals` переопределяют `hashCode`."
    },
    {
      "question": "Что означает static для полей и методов?",
      "answer": "`static` означает «принадлежит классу, а не объекту». Статическое поле — одно на все экземпляры; статический метод вызывается как `Class.method()` и не имеет `this`, поэтому не может напрямую обращаться к нестатическим полям/методам."
    },
    {
      "question": "Что произойдёт при плохой реализации hashCode()? Чем грозят коллизии?",
      "answer": "Чем хуже распределение `hashCode`, тем больше коллизий и тем медленнее работают `HashMap/HashSet` (вплоть до O(n) на операции). Если `hashCode` зависит от изменяемых полей и объект меняется после добавления в map/set — запись может «потеряться» и перестать находиться."
    },
    {
      "question": "Что сравнивает equals? Зачем нужен hashCode? В чём контракт equals/hashCode?",
      "answer": "`equals` определяет логическое равенство объектов (обычно по значимым полям). `hashCode` нужен для быстрого выбора бакета в хеш-коллекциях. Контракт: если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()` обязательно; обратное неверно (коллизии допустимы)."
    },
    {
      "question": "Что такое автобоксинг/анбоксинг? Можно ли сравнивать Integer через ==? Как работает кэш значений?",
      "answer": "Автобоксинг — автоматическое преобразование примитива в обёртку (`int` → `Integer`), анбоксинг — обратно. `Integer` через `==` сравнивает ссылки, поэтому возможны сюрпризы из-за кэша: обычно кэшируются значения -128..127, поэтому `Integer a=127; Integer b=127; a==b` может быть `true`, а для 128 — уже `false`. Для числового равенства используйте `equals()` или примитивы."
    },
    {
      "question": "Что такое автоупаковка (autoboxing) и распаковка (unboxing)?",
      "answer": "Autoboxing — когда компилятор превращает примитив в объект-обёртку (например, при добавлении в `List<Integer>`). Unboxing — обратное. Важно помнить про накладные расходы и риск NPE при распаковке `null`."
    },
    {
      "question": "Что такое внутренние классы? Разница между static и нестатическими inner-классами и как их создавать?",
      "answer": "Внутренние классы: static nested, non-static inner, локальные и анонимные. Non-static inner держит неявную ссылку на внешний объект и создаётся так: `Outer o = new Outer(); Outer.Inner i = o.new Inner();`. Static nested не привязан к экземпляру: `Outer.Nested n = new Outer.Nested();`."
    },
    {
      "question": "Что такое иммутабельные объекты и зачем они нужны?",
      "answer": "Иммутабельный объект нельзя изменить после создания. Это упрощает код, снижает число багов, делает объекты безопасными для многопоточности и удобными как ключи в Map/элементы Set. Цена — больше аллокаций при «изменениях»."
    },
    {
      "question": "Что такое классы-обёртки (wrapper classes) и зачем они нужны?",
      "answer": "Wrapper classes — объектные аналоги примитивов: `Integer`, `Long`, `Double`, `Boolean`, `Character` и т.д. Нужны для коллекций/дженериков, `null`, API, где требуется `Object`, и для утилит (парсинг, сравнение, константы вроде `Integer.MAX_VALUE`)."
    },
    {
      "question": "Что такое неизменяемый (immutable) класс? Зачем он нужен?",
      "answer": "Immutable класс — класс, экземпляры которого нельзя изменить после создания. Нужен для надёжности, простоты reasoning, потокобезопасности и безопасного использования в качестве ключей и общих объектов."
    },
    {
      "question": "Что такое поверхностное и глубокое копирование?",
      "answer": "Shallow copy копирует сам объект, но ссылки внутри остаются на те же вложенные объекты. Deep copy копирует и вложенные объекты тоже. Deep copy нужна, если вы хотите полностью независимое состояние при наличии мутабельных полей."
    },
    {
      "question": "Что такое пул строк? Почему String иммутабельный и final?",
      "answer": "String Pool хранит канонические строки (обычно литералы и результат `intern()`), чтобы не создавать дубликаты. `String` иммутабелен и `final`, чтобы строки из пула были безопасны: их нельзя «поменять» после того как они стали общими, и нельзя наследованием нарушить гарантии."
    },
    {
      "question": "Что такое строковый пул (String Pool) и как он работает?",
      "answer": "String Pool — хранилище «канонических» строк: одинаковые литералы обычно указывают на один объект. При `intern()` строка либо берётся из пула, либо добавляется туда. Это уменьшает дублирование строк, но важно не «засорять» пул огромным количеством уникальных значений."
    },
    {
      "question": "Что такое функция main в Java? Сколько main может быть в приложении? Что будет, если main нет?",
      "answer": "`main` — точка входа: `public static void main(String[] args)`. В проекте может быть много классов с `main`, но при запуске вы выбираете один (главный класс). Если в выбранном классе нет подходящего `main`, приложение как обычная Java-программа не стартует."
    },
    {
      "question": "Что такое цикл enhanced for (for-each) и чем он обязан интерфейсу Iterable?",
      "answer": "Enhanced for (`for (T x : xs)`) — синтаксис перебора. Для коллекций работает, потому что объект реализует `Iterable` и даёт `Iterator`. Для массивов компилятор использует индексный цикл."
    },
    {
      "question": "Что такое immutable-объект? Какие плюсы и минусы?",
      "answer": "Immutable-объект нельзя изменить после создания. Плюсы: потокобезопасность, меньше багов, удобно кешировать и использовать как ключ. Минусы: больше аллокаций при «изменениях», иногда нужно копировать коллекции/массивы; обход — builder и аккуратный дизайн."
    },
    {
      "question": "Что такое Iterator и какие преимущества он даёт?",
      "answer": "`Iterator` — объект для последовательного обхода элементов (`hasNext()`/`next()`, иногда `remove()`). Преимущества: единый способ перебора разных коллекций, возможность безопасно удалять текущий элемент через `iterator.remove()`, отделение логики обхода от структуры данных."
    },
    {
      "question": "Что такое Iterator и Iterable?",
      "answer": "`Iterable` — «это можно перебирать» (метод `iterator()`). `Iterator` — «механизм перебора» (методы `hasNext/next`). `for-each` работает по `Iterable`."
    },
    {
      "question": "Что такое Optional и когда его использовать/не использовать?",
      "answer": "`Optional<T>` — контейнер «значение есть/значения нет» для явного API вместо `null`. Хорош для возвращаемых значений (например, поиск). Обычно не используют как поля сущностей/DTO и как параметры методов «везде подряд», чтобы не усложнять модель."
    },
    {
      "question": "Что такое record в Java 16+/17 и чем он отличается от Lombok-датакласса?",
      "answer": "`record` — встроенный в язык способ описать неизменяемый «носитель данных»: компоненты, конструктор, аксессоры, `equals/hashCode/toString` генерируются автоматически; record `final` и не наследуется от других классов. Lombok — сторонняя библиотека с генерацией кода на этапе компиляции (аннотации), гибче, но это зависимость и «магия» сборки."
    },
    {
      "question": "Что такое String Pool и как работает String.intern()?",
      "answer": "String Pool хранит канонические строки (обычно литералы). `intern()` возвращает строку из пула: если в пуле уже есть такая по содержимому — вернёт её, иначе добавит и вернёт. Это позволяет делить одинаковые строки между частями приложения."
    },
    {
      "question": "Что такое String Pool и чем отличается создание строки литералом от new String(...)?",
      "answer": "Литерал берётся из пула (обычно один объект на одинаковый литерал). `new String(\"...\")` всегда создаёт новый объект в куче, даже если в пуле уже есть такой текст. Чтобы получить каноническую ссылку из пула, можно вызвать `intern()`."
    },
    {
      "question": "Что такое String Pool?",
      "answer": "String Pool — механизм JVM, который хранит один экземпляр одинаковых строк (обычно литералы и строки после `intern()`), чтобы экономить память и уменьшать количество дубликатов."
    },
    {
      "question": "Что такое String Pool? Как туда попадают строки?",
      "answer": "В String Pool попадают строковые литералы и константные строковые выражения, а также строки, для которых вызвали `intern()`. В пуле хранится канонический объект, который можно переиспользовать."
    },
    {
      "question": "Что такое suppressed exceptions?",
      "answer": "Suppressed exceptions — исключения, которые возникли, например, при закрытии ресурсов в `try-with-resources`, когда уже есть основное исключение из тела `try`. Они прикрепляются к основному исключению и доступны через `Throwable.getSuppressed()`."
    },
    {
      "question": "Что такое try-with-resources и какие объекты можно туда помещать?",
      "answer": "Try-with-resources — конструкция `try (res) { ... }`, которая автоматически закрывает ресурсы после блока. В скобки можно помещать объекты, реализующие `AutoCloseable` (в т.ч. `Closeable`): потоки, файлы, JDBC `Connection/Statement/ResultSet` и т.п."
    },
    {
      "question": "Что такое try-with-resources? Какие объекты можно туда класть?",
      "answer": "Это `try` с автоматическим закрытием. Класть можно любые ресурсы с `AutoCloseable`/`Closeable` (например, `InputStream`, `Reader`, `Connection`, `PreparedStatement`). Закрытие происходит даже при исключении внутри `try`."
    },
    {
      "question": "Что такое try-with-resources? Какие объекты можно туда поместить (требование AutoCloseable)?",
      "answer": "Try-with-resources вызывает `close()` автоматически, поэтому ресурс должен реализовывать `AutoCloseable`. Можно указать несколько ресурсов — они закроются в обратном порядке объявления; исключения из `close()` могут стать suppressed."
    },
    {
      "question": "char — символьный или числовой тип?",
      "answer": "`char` — примитивный числовой тип (16‑битный беззнаковый кодовый юнит UTF‑16). Его можно использовать как символ, но технически это число."
    },
    {
      "question": "String — примитивный или ссылочный тип? Что важно знать о String и почему он immutable?",
      "answer": "`String` — ссылочный тип (объект). Важно: `String` неизменяем, поэтому безопасен для многопоточности и удобен как ключ; сравнение по содержимому — через `equals()`, а `==` сравнивает ссылки. Иммутабельность нужна для пула строк, кеширования хэша и безопасности."
    },
    {
      "question": "StringBuilder vs StringBuffer: различия и когда что использовать?",
      "answer": "`StringBuilder` — быстрый изменяемый буфер для одного потока (обычно лучший выбор). `StringBuffer` — синхронизированный вариант (потокобезопаснее при совместном доступе), но медленнее. Чаще используйте `StringBuilder`."
    },
    {
      "question": "Try-with-resources: как работает и какие требования к ресурсам?",
      "answer": "Ресурсы объявляются в `try (res1; res2)`, после блока JVM вызывает `close()` у каждого ресурса в обратном порядке. Требование: ресурс реализует `AutoCloseable`. Если исключение возникло и в теле `try`, и при `close()`, то исключение из `close()` станет suppressed и попадёт в `getSuppressed()`."
    },
    {
      "question": "Чем отличается Function от BiFunction по контракту входов/выходов?",
      "answer": "`Function<T,R>` принимает один аргумент `T` и возвращает `R` (`R apply(T t)`). `BiFunction<T,U,R>` принимает два аргумента `T` и `U` и возвращает `R` (`R apply(T t, U u)`)."
    },
    {
      "question": "Можно ли запустить Java-приложение, имея только JRE?",
      "answer": "Да, для запуска уже скомпилированного приложения (классы/JAR) достаточно среды выполнения (JRE/рантайм). Но компилировать (`javac`) и собирать артефакты без JDK нельзя. На практике сейчас часто ставят JDK, потому что отдельный JRE как продукт может не поставляться, но «рантайм для запуска» всё равно нужен."
    }
  ]
}
