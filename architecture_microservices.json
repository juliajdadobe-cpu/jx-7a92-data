{
  "Архитектура / Микросервисы": [
    { "question": "Зачем и когда выбирать микросервисную архитектуру вместо монолита?", "answer": "" },
    { "question": "Микросервисы vs монолит: ключевые плюсы и минусы?", "answer": "" },
    { "question": "Какие проблемы микросервисы решают помимо single point of failure?", "answer": "" },
    { "question": "Какие виды интеграций используете (REST/gRPC, брокеры, прямой доступ к БД, файлы) и когда какой выбрать?", "answer": "" },
    { "question": "Когда отдаёте приоритет синхронному взаимодействию (REST), а когда асинхронному (Kafka)?", "answer": "" },
    { "question": "Что такое API Gateway и зачем он нужен?", "answer": "" },
    { "question": "Нужен ли API Gateway? Чем он отличается от просто L7-балансировщика?", "answer": "" },
    { "question": "Какие разновидности API Gateway бывают и чем они отличаются?", "answer": "" },
    { "question": "Что такое паттерн SAGA и как он координирует распределённые транзакции?", "answer": "" },
    { "question": "Паттерн SAGA: для чего и какие варианты (оркестрация/хореография)?", "answer": "" },
    { "question": "Когда в системе имеет смысл применять паттерн SAGA?", "answer": "" },
    { "question": "Что такое идемпотентность запросов и как её обеспечить?", "answer": "" },
    { "question": "Как генерируете и храните ключ идемпотентности и где его проверяете?", "answer": "" },
    { "question": "Когда уместен паттерн Transactional Outbox и как его реализовать?", "answer": "" },
    { "question": "Как обеспечить транзакционную целостность между БД и сообщением в Kafka?", "answer": "" },
    { "question": "Как бороться с дубликатами сообщений при паттерне Outbox?", "answer": "" },
    { "question": "Как организован обработчик outbox-таблицы?", "answer": "" },
    { "question": "Как организовать outbox-читателей: батчи, идемпотентность, ретраи?", "answer": "" },
    { "question": "Как защитить слабый сервис от пиковых нагрузок (rate limiting, backpressure)?", "answer": "" },
    { "question": "Как микросервисы помогают с масштабированием под пиковые нагрузки?", "answer": "" },
    { "question": "Нужно ли открывать транзакцию и внутри неё ждать внешний сервис? Почему это опасно?", "answer": "" },
    { "question": "Как реализовать трассировку запросов между микросервисами (traceId/correlationId)?", "answer": "" },
    { "question": "Как передаётся traceId между сервисами?", "answer": "" },
    { "question": "Как обеспечить наблюдаемость в микросервисах?", "answer": "" },
    { "question": "Что такое bounded context и зачем он нужен в микросервисной архитектуре?", "answer": "" },
    { "question": "Почему shared database между микросервисами считается антипаттерном?", "answer": "" },
    { "question": "Кому принадлежит схема базы данных в микросервисной архитектуре?", "answer": "" },
    { "question": "Когда микросервисы являются избыточным решением?", "answer": "" },
    { "question": "Какие признаки говорят о том, что системе пока рано переходить на микросервисы?", "answer": "" },
    { "question": "Какие стратегии версионирования API используются в микросервисах?", "answer": "" },
    { "question": "Как обеспечивать обратную совместимость API?", "answer": "" },
    { "question": "В чём разница между synchronous request/response и event-driven архитектурой?", "answer": "" },
    { "question": "Когда event-driven архитектура ухудшает систему?", "answer": "" },
    { "question": "Что такое eventual consistency и почему она неизбежна в микросервисах?", "answer": "" },
    { "question": "Какие гарантии доставки сообщений существуют (at-most-once, at-least-once, exactly-once)?", "answer": "" },
    { "question": "Почему exactly-once семантика сложна и часто иллюзорна?", "answer": "" },
    { "question": "Что такое compensating transactions и как они связаны с SAGA?", "answer": "" },
    { "question": "Что такое circuit breaker и зачем он нужен в микросервисах?", "answer": "" },
    { "question": "Что такое retries и exponential backoff?", "answer": "" },
    { "question": "Почему бесконтрольные ретраи могут привести к каскадным отказам?", "answer": "" },
    { "question": "Что такое bulkhead pattern?", "answer": "" },
    { "question": "Почему timeout — это архитектурное решение, а не деталь реализации?", "answer": "" },
    { "question": "Что такое fan-out on read и fan-out on write?", "answer": "" },
    { "question": "В каких случаях fan-out приводит к проблемам масштабирования?", "answer": "" },
    { "question": "Что такое celebrity problem (hotspot) и как с ним бороться?", "answer": "" },
    { "question": "Как обеспечить идемпотентность consumer’ов в event-driven архитектуре?", "answer": "" },
    { "question": "Где хранить состояние обработки событий (offsets, processed keys)?", "answer": "" },
    { "question": "В чём разница между API Gateway и Backend-for-Frontend (BFF)?", "answer": "" },
    { "question": "Почему API Gateway может стать single point of failure?", "answer": "" },
    { "question": "Как снизить риски, связанные с API Gateway?", "answer": "" }
  ]
}
