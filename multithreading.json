{
  "Многопоточность": [
    { "question": "Что такое процесс и поток? В чём между ними разница?", "answer": "" },
    { "question": "Что такое многопоточность и зачем она нужна?", "answer": "" },
    { "question": "Асинхронность vs многопоточность: в чём разница?", "answer": "" },

    { "question": "Какие состояния потока существуют в Java (Thread.State)?", "answer": "" },
    { "question": "Как происходят переходы между состояниями потоков?", "answer": "" },

    { "question": "Как корректно создать и запустить поток в Java (Thread, Runnable)?", "answer": "" },
    { "question": "Почему предпочтительнее использовать Runnable/Callable, а не наследоваться от Thread?", "answer": "" },
    { "question": "В чём разница между Runnable и Callable?", "answer": "" },
    { "question": "Как получить результат из Callable и чем опасен Future.get()?", "answer": "" },

    { "question": "Что такое synchronized и как он работает?", "answer": "" },
    { "question": "Что такое monitor lock (intrinsic lock)?", "answer": "" },
    { "question": "Как работает synchronized: метод vs synchronized-блок?", "answer": "" },
    { "question": "Чем отличается synchronized метод от synchronized(obj) блока?", "answer": "" },
    { "question": "Как работает static synchronized и какой монитор используется?", "answer": "" },
    { "question": "Два потока вызывают разные synchronized-методы одного объекта — выполнятся ли они параллельно?", "answer": "" },

    { "question": "В чём проблема подхода с synchronized?", "answer": "" },
    { "question": "Почему появился пакет java.util.concurrent?", "answer": "" },
    { "question": "Когда использовать synchronized, а когда высокоуровневые concurrent-структуры?", "answer": "" },

    { "question": "Что такое volatile и какие гарантии он даёт?", "answer": "" },
    { "question": "Чего volatile НЕ гарантирует?", "answer": "" },
    { "question": "Почему volatile int++ не атомарен?", "answer": "" },
    { "question": "Когда volatile достаточно, а когда нужны атомарные типы?", "answer": "" },
    { "question": "Если только читаем/пишем переменную без инкремента — что использовать для видимости?", "answer": "" },

    { "question": "Что такое атомарность в многопоточности?", "answer": "" },
    { "question": "Что такое консистентность в контексте многопоточности?", "answer": "" },
    { "question": "Что такое CAS (compare-and-swap)?", "answer": "" },
    { "question": "Какие атомарные классы в Java ты знаешь (AtomicInteger и др.)?", "answer": "" },
    { "question": "Почему volatile недостаточно вместо Atomic-типов?", "answer": "" },

    { "question": "Что такое Java Memory Model (JMM)?", "answer": "" },
    { "question": "Что такое happens-before?", "answer": "" },
    { "question": "Почему без volatile или синхронизации возможны странные значения?", "answer": "" },

    { "question": "Что такое race condition?", "answer": "" },
    { "question": "Что такое deadlock?", "answer": "" },
    { "question": "Что такое livelock и starvation?", "answer": "" },
    { "question": "Как диагностировать deadlock?", "answer": "" },
    { "question": "Какие стратегии предотвращения deadlock ты знаешь?", "answer": "" },
    { "question": "Чем отличаются tryLock с тайм-аутом и упорядочивание захвата блокировок?", "answer": "" },

    { "question": "Что делает метод sleep()? Освобождает ли он монитор?", "answer": "" },
    { "question": "Что делает метод wait() и чем он отличается от sleep()?", "answer": "" },
    { "question": "Почему wait/notify нужно вызывать только внутри synchronized?", "answer": "" },
    { "question": "Для чего нужны notify() и notifyAll()?", "answer": "" },
    { "question": "Что такое spurious wakeup?", "answer": "" },
    { "question": "Почему wait() нужно вызывать в цикле while, а не if?", "answer": "" },

    { "question": "Что такое ExecutorService?", "answer": "" },
    { "question": "Зачем нужен ExecutorService?", "answer": "" },
    { "question": "Чем отличается execute() от submit()?", "answer": "" },

    { "question": "Для чего нужны пулы потоков?", "answer": "" },
    { "question": "Какие типы пулов потоков умеет Executors?", "answer": "" },
    { "question": "В чём отличие newFixedThreadPool и newCachedThreadPool?", "answer": "" },
    { "question": "Когда выбирать newSingleThreadExecutor?", "answer": "" },
    { "question": "Как выбирать размер пула потоков?", "answer": "" },

    { "question": "Что такое ForkJoinPool?", "answer": "" },
    { "question": "Чем ForkJoinPool отличается от обычных тред-пулов?", "answer": "" },
    { "question": "Что такое work-stealing?", "answer": "" },
    { "question": "Где ForkJoinPool уместен, а где использовать не стоит?", "answer": "" },
    { "question": "На каком пуле работает parallelStream()?", "answer": "" },

    { "question": "Что такое Future и CompletableFuture?", "answer": "" },
    { "question": "В чём разница между Future и CompletableFuture?", "answer": "" },
    { "question": "Как в CompletableFuture обрабатываются исключения (exceptionally, handle)?", "answer": "" },
    { "question": "Как определить, какая из параллельных CompletableFuture упала?", "answer": "" },
    { "question": "Как собрать общий результат из нескольких CompletableFuture?", "answer": "" },
    { "question": "Как реализовать ретраи в CompletableFuture?", "answer": "" },

    { "question": "Что такое thread-safe класс?", "answer": "" },
    { "question": "Какие способы сделать код потокобезопасным ты знаешь?", "answer": "" },
    { "question": "Почему immutable-объекты важны в многопоточности?", "answer": "" },

    { "question": "Какие коллекции являются потокобезопасными?", "answer": "" },
    { "question": "Чем отличаются Collections.synchronizedXXX и Concurrent-коллекции?", "answer": "" },
    { "question": "Как устроен ConcurrentHashMap и почему Hashtable считается неудачным?", "answer": "" },

    { "question": "Чем ReentrantLock отличается от synchronized?", "answer": "" },
    { "question": "Для чего нужны Lock и ReadWriteLock?", "answer": "" },
    { "question": "Как работает ReadWriteLock (параллельное чтение, эксклюзивная запись)?", "answer": "" },
    { "question": "Что такое fairness в блокировках?", "answer": "" },

    { "question": "Что такое ThreadLocal и когда его используют?", "answer": "" },
    { "question": "Какие проблемы могут возникать при неправильном использовании ThreadLocal?", "answer": "" },

    { "question": "Что такое interrupt и как корректно останавливать поток?", "answer": "" },
    { "question": "Почему нельзя принудительно убивать поток?", "answer": "" },
    { "question": "Что происходит при выбросе unchecked exception из потока?", "answer": "" },

    { "question": "Что такое virtual threads (Project Loom)?", "answer": "" },
    { "question": "Чем виртуальные потоки отличаются от платформенных?", "answer": "" },
    { "question": "Зачем нужны виртуальные потоки и почему голых Thread недостаточно?", "answer": "" },

    { "question": "В чём разница eager vs lazy singleton?", "answer": "" },
    { "question": "Как реализовать потокобезопасный singleton?", "answer": "" }
  ]
}
