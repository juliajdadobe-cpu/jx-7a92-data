{
  "Коллекции": [
    {
      "question": "Амортизированная сложность добавления в конец ArrayList и когда она нарушается?",
      "answer": "В среднем добавление в конец `ArrayList` — амортизированно O(1): чаще всего элемент просто кладётся в конец массива. Иногда происходит расширение (resize): выделяется новый массив и копируются элементы — это O(n), но редко, поэтому в среднем O(1). Амортизированность «ломается» при частых resize (например, если постоянно не хватает capacity) или если добавлять не в конец (там сдвиги O(n))."
    },
    {
      "question": "В чём преимущество удаления в LinkedList по сравнению с ArrayList?",
      "answer": "Удаление у `LinkedList` само по себе O(1), если у вас уже есть узел/итератор на элемент: нужно перекинуть ссылки `prev/next`. В `ArrayList` удаление из середины O(n), потому что нужно сдвигать хвост массива. Но поиск элемента в `LinkedList` обычно O(n), поэтому «преимущество» проявляется, когда позиция уже известна (например, при обходе итератором)."
    },
    {
      "question": "В чём различие между ArrayList и LinkedList (структура и доступ по индексу)?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "В чём различия ArrayList и LinkedList по операциям вставки/доступа?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "В чём разница между ArrayList и LinkedList? Когда какой использовать?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "В чём разница ArrayList и LinkedList? Сложности операций доступа/вставки/удаления?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "Допускают ли они null-ключ/значение?",
      "answer": "Зависит от конкретной коллекции. `ArrayList`/`LinkedList` допускают `null` как элемент. Из Map: `HashMap`/`LinkedHashMap` допускают один `null`‑ключ и `null`‑значения; `Hashtable` и `ConcurrentHashMap` не допускают `null` ни в ключах, ни в значениях. `TreeMap` обычно не допускает `null`‑ключи при естественной сортировке (можно с кастомным Comparator, но чаще `null`‑ключи избегают)."
    },
    {
      "question": "Иерархия коллекций Java: основные интерфейсы и их роли (Collection, List, Set, Queue, Map).",
      "answer": "Базовые интерфейсы: `Collection` → `List` (упорядочено, допускает дубли), `Set` (без дублей), `Queue`/`Deque` (очереди). `Map` стоит отдельно (ключ→значение) и не наследуется от `Collection`. Частые реализации: `ArrayList`, `LinkedList`; `HashSet`, `LinkedHashSet`, `TreeSet`; `ArrayDeque`; `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap`."
    },
    {
      "question": "Как в Java устроен LinkedList?",
      "answer": "`LinkedList` — двусвязный список: у коллекции есть ссылки на `first` и `last`, а каждый узел (Node) хранит `item`, `next`, `prev`. Операции `addFirst/addLast/removeFirst/removeLast` работают за O(1), а доступ по индексу — за O(n) (идёт от головы или хвоста, что даёт O(min(i, n−i)))."
    },
    {
      "question": "Как меняется сложность операций в HashMap при коллизиях и когда бакет становится деревом?",
      "answer": "В среднем операции `get/put` в `HashMap` — O(1) при хорошем распределении хэшей. При коллизиях элементы в одном бакете хранятся сначала как список; тогда операции могут деградировать до O(n) по числу элементов в бакете. Начиная с Java 8, при большом числе коллизий бакет может «деревьизироваться» в красно‑чёрное дерево: тогда операции в этом бакете становятся O(log n). Деревьизация происходит при превышении порога (типично 8 элементов) и достаточной ёмкости таблицы (типично ≥64); обратно — при уменьшении (типично до 6)."
    },
    {
      "question": "Как можно “потерять” объект в HashMap при использовании изменяемого ключа?",
      "answer": "Если ключ мутабельный и его поля, влияющие на `equals/hashCode`, изменились после вставки в `HashMap`, то: ключ окажется «в неправильном бакете» и `get/containsKey/remove` могут не найти запись. Поэтому ключи для hash‑коллекций должны быть неизменяемыми (или хотя бы не менять поля, участвующие в `equals/hashCode`)."
    },
    {
      "question": "Как отсортировать Map по значениям, а не по ключам?",
      "answer": "`Map` по умолчанию не сортируется по значениям. Типичный способ: взять `entrySet()`, отсортировать список `Map.Entry` по `getValue()`, затем собрать в `LinkedHashMap`, чтобы сохранить порядок. Если нужна сортировка «на лету», обычно используют не `TreeMap` (он сортирует по ключам), а структуру данных под задачу (например, `TreeSet` из `Entry` или приоритетную очередь)."
    },
    {
      "question": "Как проверить, что сортировка по значениям действительно стабильна и корректна для одинаковых значений?",
      "answer": "Если сортируете пары (key,value) по value, то при равных значениях порядок может быть важен. Чтобы он был детерминированным: либо используйте стабильную сортировку и заранее определённый исходный порядок, либо добавьте tie‑breaker в компаратор (например, по ключу). Проверка: сделать тестовый набор с одинаковыми value и убедиться, что порядок равных элементов соответствует ожидаемому (или что tie‑breaker работает)."
    },
    {
      "question": "Как работает Collections.unmodifiableList(...)?",
      "answer": "`Collections.unmodifiableList(list)` возвращает «read-only» представление исходного списка. Любые операции, меняющие список (add/remove/set), бросят `UnsupportedOperationException`. Важно: это не «глубокая неизменяемость» — если исходный `list` изменится, это будет видно через unmodifiable‑view."
    },
    {
      "question": "Как работает HashMap.put(K,V) пошагово?",
      "answer": "Упрощённо `put(k,v)` делает так: считает хэш ключа → вычисляет индекс бакета → если бакет пуст, кладёт новую ноду. Если в бакете уже есть элементы, ищет ключ по `equals`: если найден — заменяет значение и возвращает старое; если нет — добавляет новый узел (в список или дерево). После вставки проверяет порог `threshold` и при необходимости делает resize (увеличение массива бакетов и перераспределение элементов)."
    },
    {
      "question": "Как работает HashSet, как достигается O(1), что происходит при коллизиях и какие условия нужны для O(1)?",
      "answer": "`HashSet` внутри обычно основан на `HashMap`: элементы множества хранятся как ключи, а значение — фиктивное. O(1) в среднем достигается за счёт хеш-таблицы и хорошего `hashCode`. Коллизии обрабатываются цепочками (список) и, в Java 8+, деревом при большом числе коллизий. Для хорошего O(1) нужно: корректный `equals/hashCode` и нормальное распределение хэшей, а также не менять ключи после добавления."
    },
    {
      "question": "Как реализован TreeSet под капотом? Какие ограничения накладывает?",
      "answer": "`TreeSet` реализован на базе `TreeMap` (красно‑чёрное дерево). Элементы отсортированы по `Comparable` или по переданному `Comparator`. Операции `add/remove/contains` — O(log n). Ограничения: элементы должны быть сравнимы между собой, сравнение должно быть консистентным; `null` обычно не допускается (в зависимости от компаратора)."
    },
    {
      "question": "Как реализовать компаратор для сортировки Map по значению через TreeMap?",
      "answer": "`TreeMap` сортирует по ключам, поэтому «сортировать по значениям через TreeMap» — нетипично. Если очень нужно, можно построить `TreeMap` с компаратором, который сравнивает ключи по их значениям из внешней map, и обязательно добавить tie‑breaker по ключу, иначе равные значения приведут к «потере» ключей. Чаще проще: отсортировать `entrySet()` по value и собрать в `LinkedHashMap`."
    },
    {
      "question": "Как сделать ключ иммутабельным (требования к классу-ключу)?",
      "answer": "Ключ для Map (особенно для `HashMap`) должен иметь стабильные `equals()` и `hashCode()`. Практика: сделать ключ иммутабельным — поля `final`, без сеттеров, не использовать изменяемые поля (или делать defensive copy), и корректно переопределить `equals/hashCode` по этим полям."
    },
    {
      "question": "Как сделать коллекцию потокобезопасной? Какие способы есть (concurrent-коллекции, Collections.synchronized*) ?",
      "answer": "Основные способы: (1) `Collections.synchronizedList/Set/Map` — обёртка с синхронизацией (грубая, но простая). (2) Коллекции из `java.util.concurrent`: `ConcurrentHashMap`, `CopyOnWriteArrayList`, `ConcurrentLinkedQueue`, `BlockingQueue` и т.д. (3) Не разделять коллекцию между потоками (локальная, иммутабельная копия) — часто лучший вариант."
    },
    {
      "question": "Как удалить элементы из коллекции во время обхода, не ловя ConcurrentModificationException?",
      "answer": "Правильно: удалять через `Iterator.remove()` (или `ListIterator`), либо использовать `removeIf(...)`. Неправильно: вызывать `list.remove(...)` во время for-each по той же коллекции — получите `ConcurrentModificationException` (fail-fast). Альтернативы: собирать элементы на удаление в отдельный список и удалить после обхода, или использовать concurrent-коллекции, где уместно."
    },
    {
      "question": "Как устроена HashMap внутри: бакеты, хеш, индекс, коллизии, порог дерева?",
      "answer": "`HashMap` — массив бакетов (таблица). Индекс бакета вычисляется из хэша ключа (обычно `hash & (n-1)`). В бакете лежат `Node` (key, value, hash, next) как цепочка; при большом числе коллизий цепочка может стать деревом (tree bin). Есть `loadFactor` (обычно 0.75) и `threshold` (capacity*loadFactor): при превышении происходит resize и перераспределение элементов."
    },
    {
      "question": "Как устроена HashMap под капотом (бакеты, хэш, коллизии, деревоизация)?",
      "answer": "`HashMap` — массив бакетов (таблица). Индекс бакета вычисляется из хэша ключа (обычно `hash & (n-1)`). В бакете лежат `Node` (key, value, hash, next) как цепочка; при большом числе коллизий цепочка может стать деревом (tree bin). Есть `loadFactor` (обычно 0.75) и `threshold` (capacity*loadFactor): при превышении происходит resize и перераспределение элементов."
    },
    {
      "question": "Как устроена HashMap? Что такое коллизия и когда она происходит?",
      "answer": "`HashMap` — реализация `Map` на основе хеш-таблицы: хранит пары ключ→значение в массиве бакетов, индекс вычисляется из `hashCode` ключа; коллизии решаются цепочкой/деревом. Коллизия — ситуация, когда разные ключи попадают в один бакет (одинаковый индекс). Тогда `HashMap` хранит их вместе и при `get/put` дополнительно сравнивает ключи через `equals` (и может деревьизировать бакет)."
    },
    {
      "question": "Как устроены ноды LinkedList (какие ссылки они содержат)?",
      "answer": "Узел `LinkedList` обычно хранит три поля: `item` (значение), `next` (ссылка на следующий) и `prev` (на предыдущий). Это двусвязный список, поэтому вставка/удаление узла — это перекидывание ссылок."
    },
    {
      "question": "Как LinkedList обеспечивает быстрый доступ к первому/последнему элементу?",
      "answer": "`LinkedList` хранит ссылки на `first` и `last`, поэтому операции с концами (`getFirst/getLast`, `addFirst/addLast`, `removeFirst/removeLast`) работают за O(1) без прохода по списку."
    },
    {
      "question": "Какие коллекции знаете? Какова иерархия интерфейсов коллекций?",
      "answer": "Базовые интерфейсы: `Collection` → `List` (упорядочено, допускает дубли), `Set` (без дублей), `Queue`/`Deque` (очереди). `Map` стоит отдельно (ключ→значение) и не наследуется от `Collection`. Частые реализации: `ArrayList`, `LinkedList`; `HashSet`, `LinkedHashSet`, `TreeSet`; `ArrayDeque`; `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap`."
    },
    {
      "question": "Какие основные интерфейсы и реализации есть в Collections Framework?",
      "answer": "Основные интерфейсы: `List` (ArrayList/LinkedList), `Set` (HashSet/LinkedHashSet/TreeSet), `Queue/Deque` (ArrayDeque/LinkedList, приоритетная очередь), `Map` (HashMap/LinkedHashMap/TreeMap). Выбор обычно зависит от требований: нужен ли порядок, нужны ли дубликаты, нужна ли сортировка, важна ли скорость поиска по ключу/индексу."
    },
    {
      "question": "Какие потокобезопасные альтернативы есть у HashMap?",
      "answer": "Если нужен потокобезопасный map: чаще всего `ConcurrentHashMap`. Для простого случая можно `Collections.synchronizedMap(new HashMap<>())`, но это один общий монитор и хуже масштабируется. Если данные редко меняются — можно делать неизменяемые копии (copy-on-write/immutable map) и атомарно подменять ссылку."
    },
    {
      "question": "Какие потокобезопасные коллекции вы знаете/использовали (java.util.concurrent, ConcurrentHashMap, CopyOnWriteArrayList и др.)?",
      "answer": "Примеры из `java.util.concurrent`: `ConcurrentHashMap`, `ConcurrentLinkedQueue/Deque`, `CopyOnWriteArrayList/CopyOnWriteArraySet`, `BlockingQueue` (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue), `ConcurrentSkipListMap/Set`."
    },
    {
      "question": "Какие потокобезопасные коллекции знаешь (ConcurrentHashMap, BlockingQueue и т.д.)?",
      "answer": "Примеры из `java.util.concurrent`: `ConcurrentHashMap`, `ConcurrentLinkedQueue/Deque`, `CopyOnWriteArrayList/CopyOnWriteArraySet`, `BlockingQueue` (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue), `ConcurrentSkipListMap/Set`."
    },
    {
      "question": "Какие потокобезопасные коллекции знаешь?",
      "answer": "Примеры из `java.util.concurrent`: `ConcurrentHashMap`, `ConcurrentLinkedQueue/Deque`, `CopyOnWriteArrayList/CopyOnWriteArraySet`, `BlockingQueue` (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue), `ConcurrentSkipListMap/Set`."
    },
    {
      "question": "Какие потокобезопасные коллекции знаешь? Как достигается безопасность в ConcurrentHashMap?",
      "answer": "Примеры из `java.util.concurrent`: `ConcurrentHashMap`, `ConcurrentLinkedQueue/Deque`, `CopyOnWriteArrayList/CopyOnWriteArraySet`, `BlockingQueue` (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue), `ConcurrentSkipListMap/Set`. `ConcurrentHashMap` обеспечивает потокобезопасность без глобальной синхронизации: чтения в основном lock-free, обновления используют тонкие блокировки/атомарные операции на уровне бакета/узла (зависит от версии Java). Также он запрещает `null` ключи/значения, чтобы избежать неоднозначности при конкурентных чтениях."
    },
    {
      "question": "Какие реализации Set/Map знаешь и когда использовать TreeSet/TreeMap?",
      "answer": "`TreeSet/TreeMap` используйте, когда нужна сортировка и операции поиска/вставки/удаления за O(log n). Если сортировка не нужна и важна скорость — обычно `HashSet/HashMap` (O(1) в среднем). Если важен порядок вставки — `LinkedHashSet/LinkedHashMap`."
    },
    {
      "question": "Какие требования к ключам TreeMap?",
      "answer": "Ключи `TreeMap` должны быть сравнимы: либо реализовать `Comparable`, либо передать `Comparator`. Сравнение должно быть консистентным (одинаково для одинаковых ключей) и желательно согласованным с `equals`, иначе возможны неожиданные эффекты. `null` ключи обычно не допускаются при естественной сортировке."
    },
    {
      "question": "Какие требования к объектам-ключам в Map следует соблюдать?",
      "answer": "Ключи в `Map` должны корректно работать в выбранной реализации. Для hash‑map: стабильные `equals/hashCode`; для tree‑map: корректное сравнение (`Comparable/Comparator`). Ключи должны быть «стабильными» после вставки (не менять поля, влияющие на сравнение/хэш)."
    },
    {
      "question": "Какими свойствами должен обладать объект-ключ для использования в HashMap?",
      "answer": "Для `HashMap` ключ должен иметь корректные `equals()` и `hashCode()` и желательно быть неизменяемым по этим полям. Требование контракта: если `equals` истинно, `hashCode` должен совпадать."
    },
    {
      "question": "Какова амортизированная сложность добавления элемента в Map? Каков худший случай?",
      "answer": "Добавление в `HashMap` в среднем O(1) (амортизированно, с учётом редких resize). Худший случай — O(n) при большом числе коллизий (или если все ключи попали в один бакет). В Java 8+ при деревьизации бакета это ближе к O(log n) внутри бакета."
    },
    {
      "question": "Какова амортизированная сложность операций в HashMap и что меняется при коллизиях/деревьях?",
      "answer": "В среднем `get/put/remove` в `HashMap` — O(1). При коллизиях бакет может стать длинным списком → деградация к O(n); в Java 8+ при деревьизации — O(log n) для этого бакета. Resize (rehash) даёт редкие O(n), поэтому говорят «амортизированно»."
    },
    {
      "question": "Какова асимптотика доступа к середине в ArrayList и LinkedList?",
      "answer": "`ArrayList`: доступ по индексу к середине — O(1). `LinkedList`: нужно пройти до узла — O(n) (точнее O(min(i, n−i)))."
    },
    {
      "question": "Какова сложность добавления в конец/начало для ArrayList и LinkedList?",
      "answer": "`ArrayList`: add в конец — амортизированно O(1), add в начало/в середину — O(n) из-за сдвигов. `LinkedList`: addFirst/addLast — O(1), вставка по индексу — O(n) на поиск позиции + O(1) на привязку."
    },
    {
      "question": "Какова сложность доступа к первому и последнему элементам LinkedList?",
      "answer": "Доступ к первому и последнему элементам `LinkedList` — O(1), потому что хранится `first` и `last`."
    },
    {
      "question": "Какова сложность доступа к первому/последнему элементу в LinkedList и почему?",
      "answer": "Доступ к первому и последнему элементам `LinkedList` — O(1), потому что хранится `first` и `last`."
    },
    {
      "question": "Какова сложность доступа к последнему элементу LinkedList?",
      "answer": "`getLast()` у `LinkedList` — O(1), так как есть ссылка на `last`."
    },
    {
      "question": "Какова сложность операций в HashMap в среднем и при деградации?",
      "answer": "В среднем `HashMap` даёт O(1) на `get/put`, при деградации из-за коллизий — O(n) (или O(log n) при деревьизации бакета в Java 8+)."
    },
    {
      "question": "Какова сложность поиска в LinkedList по индексу? Всегда ли она линейная?",
      "answer": "Поиск/доступ по индексу в `LinkedList` — O(n) (идёт от головы или хвоста), то есть асимптотически линейно всегда."
    },
    {
      "question": "Какова средняя и худшая сложность вставки и получения в HashMap?",
      "answer": "Средняя сложность `get/put` в `HashMap` — O(1), худшая — O(n) при плохих хэшах/коллизиях (в Java 8+ часто O(log n) внутри tree‑бакета)."
    },
    {
      "question": "Когда бакет в HashMap превращается в дерево и обратно?",
      "answer": "Бакет в `HashMap` превращается в дерево при большом числе коллизий (типично 8+ элементов в бакете) и достаточной ёмкости таблицы (типично ≥64). Обратно в список — при уменьшении числа элементов в бакете (типично до 6)."
    },
    {
      "question": "Когда выбирать ArrayList, а когда LinkedList и почему?",
      "answer": "Как правило выбирают `ArrayList` (быстрее и компактнее). `LinkedList` имеет смысл как `Deque` (часто операции на концах) или когда часто вставляете/удаляете в середине через итератор/уже найденную позицию."
    },
    {
      "question": "Когда выбирать LinkedList вместо ArrayList и наоборот? Примеры сценариев.",
      "answer": "`ArrayList`: частые чтения по индексу, проходы по массиву, редко вставки в середину. `LinkedList`: очередь/дек (`addFirst/addLast/pollFirst/pollLast`) или частые удаления/вставки рядом с текущим итератором. Для обычного списка «на все случаи» чаще берут `ArrayList`."
    },
    {
      "question": "Когда уместен CopyOnWriteArrayList и каковы его минусы?",
      "answer": "`CopyOnWriteArrayList` хорош, когда очень много чтений/итераций и мало изменений (конфиги, список подписчиков). Итераторы у него «snapshot» и не бросают CME. Минусы: каждая запись/удаление копирует весь массив → дорого по CPU/памяти; не подходит для частых модификаций и больших списков."
    },
    {
      "question": "Корректно ли использовать массив (int[]) как ключ мапы?",
      "answer": "Технически можно, но почти всегда это ошибка: у массива `equals/hashCode` по умолчанию — по ссылке (как у Object), а не по содержимому. Значит `map.get(new int[]{1,2})` не найдёт запись, вставленную под другим `int[]{1,2}`. Лучше: обёртка-ключ со `Arrays.equals/hashCode`, или `List<Integer>`, или `IntBuffer`, или свой неизменяемый класс ключа."
    },
    {
      "question": "Может ли два разных hashCode попасть в один бакет?",
      "answer": "Да. Индекс бакета вычисляется по части бит хэша (например, `hash & (n-1)`), поэтому разные `hashCode` часто попадают в один бакет — это и есть коллизии."
    },
    {
      "question": "Можно ли использовать null как ключ? Где нельзя?",
      "answer": "`HashMap`/`LinkedHashMap` позволяют один `null` ключ и `null` значения. `Hashtable` и `ConcurrentHashMap` — не позволяют `null` ни в ключах, ни в значениях. `TreeMap` обычно не допускает `null` ключи при естественном порядке; значения могут быть `null`."
    },
    {
      "question": "Опиши иерархию коллекций (List/Set/Map и основные реализации).",
      "answer": "Основные интерфейсы: `List` (ArrayList/LinkedList), `Set` (HashSet/LinkedHashSet/TreeSet), `Queue/Deque` (ArrayDeque/LinkedList, приоритетная очередь), `Map` (HashMap/LinkedHashMap/TreeMap). Выбор обычно зависит от требований: нужен ли порядок, нужны ли дубликаты, нужна ли сортировка, важна ли скорость поиска по ключу/индексу."
    },
    {
      "question": "Потокобезопасные коллекции: ConcurrentHashMap, CopyOnWriteArrayList — когда применять и ограничения.",
      "answer": "`ConcurrentHashMap` — когда нужен общий map с конкурентными чтениями/записями и хорошей масштабируемостью. `CopyOnWriteArrayList` — когда много чтений/итераций и мало записей. Ограничения: `ConcurrentHashMap` не принимает `null`; у COW‑коллекций дорогие записи (копирование)."
    },
    {
      "question": "Почему в HashMap ключами часто делают String?",
      "answer": "`String` часто используют как ключ, потому что он иммутабелен, у него стабильный и кешируемый `hashCode`, и корректный `equals` по содержимому. Это снижает риск «потерять» ключ из-за изменения и обычно даёт хорошую производительность."
    },
    {
      "question": "Почему изменение полей ключа после помещения в HashMap приводит к проблемам?",
      "answer": "Потому что `HashMap` ищет элемент по `hashCode` → бакет → `equals`. Если ключ изменился, хэш/равенство могли измениться, и запись окажется в «другом месте». В результате `get/remove/containsKey` могут не найти её."
    },
    {
      "question": "Почему изменение состояния ключа после помещения в Map опасно?",
      "answer": "Потому что `HashMap` ищет элемент по `hashCode` → бакет → `equals`. Если ключ изменился, хэш/равенство могли измениться, и запись окажется в «другом месте». В результате `get/remove/containsKey` могут не найти её."
    },
    {
      "question": "Почему изменяемые ключи плохи для HashMap?",
      "answer": "Потому что `HashMap` ищет элемент по `hashCode` → бакет → `equals`. Если ключ изменился, хэш/равенство могли измениться, и запись окажется в «другом месте». В результате `get/remove/containsKey` могут не найти её."
    },
    {
      "question": "Почему мутабельные ключи в HashMap — это проблема?",
      "answer": "Потому что `HashMap` ищет элемент по `hashCode` → бакет → `equals`. Если ключ изменился, хэш/равенство могли измениться, и запись окажется в «другом месте». В результате `get/remove/containsKey` могут не найти её."
    },
    {
      "question": "Почему не рекомендуется использовать Hashtable?",
      "answer": "`Hashtable` — устаревшая коллекция: глобальная синхронизация на каждом методе, хуже масштабируется, неудобный API, не допускает `null`. Вместо неё обычно используют `HashMap` + внешнюю синхронизацию или `ConcurrentHashMap` для многопоточности."
    },
    {
      "question": "Почему плохо менять поля ключа в Map/элемент в Set после добавления?",
      "answer": "Потому что `HashMap` ищет элемент по `hashCode` → бакет → `equals`. Если ключ изменился, хэш/равенство могли измениться, и запись окажется в «другом месте». В результате `get/remove/containsKey` могут не найти её."
    },
    {
      "question": "Почему сортировка TreeMap по умолчанию работает по ключам, и как изменить это поведение?",
      "answer": "`TreeMap` — это `SortedMap`: по определению хранит элементы в порядке ключей (по `Comparable`/`Comparator`). Чтобы получить порядок по значениям, обычно сортируют `entrySet()` по value и собирают в `LinkedHashMap` или используют другую структуру (например, `TreeSet`/`PriorityQueue` по value)."
    },
    {
      "question": "Почему удаление/вставка в начало/середину ArrayList дорогостоящие?",
      "answer": "Потому что `ArrayList` — массив: при вставке/удалении в начале/середине нужно сдвигать элементы, что даёт O(n)."
    },
    {
      "question": "Почему Map не относится к иерархии Collection?",
      "answer": "`Map` — не «коллекция элементов одного типа», а отображение «ключ→значение». У него другой контракт: уникальность ключей, операции по ключу, представления `keySet()`, `values()`, `entrySet()`. Поэтому `Map` не наследуется от `Collection`."
    },
    {
      "question": "Почему String считается хорошим ключом для HashMap?",
      "answer": "Потому что `String` неизменяем, имеет корректные `equals/hashCode` и часто хорошо распределяет хэш — это делает его надёжным ключом для `HashMap`."
    },
    {
      "question": "Разница HashMap, LinkedHashMap, TreeMap.",
      "answer": "`HashMap` — быстрый O(1) в среднем, порядок итерации не гарантирован. `LinkedHashMap` — как `HashMap`, но сохраняет порядок вставки (или доступа при access-order). `TreeMap` — отсортирован по ключам (красно‑чёрное дерево), операции O(log n)."
    },
    {
      "question": "Разница HashSet и TreeSet.",
      "answer": "`HashSet` — быстрый в среднем O(1), порядок не гарантирован. `TreeSet` — отсортирован, операции O(log n). Если нужен порядок вставки — `LinkedHashSet`."
    },
    {
      "question": "Сложности операций ArrayList: get, set, add(index), remove(index) — объясните почему.",
      "answer": "`get/set` по индексу — O(1), потому что это обращение к элементу массива. `add(index)`/`remove(index)` — O(n), потому что нужно сдвигать элементы хвоста. `add` в конец — амортизированно O(1), иногда бывает O(n) при расширении массива."
    },
    {
      "question": "Сложности операций LinkedList: addLast, add(index), remove(index), get(index) — поясните.",
      "answer": "`addLast` — O(1), потому что есть ссылка на хвост. `get(index)`/`add(index)`/`remove(index)` — O(n) на поиск узла по индексу; после нахождения вставка/удаление узла — O(1)."
    },
    {
      "question": "Чем отличаются HashMap и Hashtable?",
      "answer": "`HashMap` не синхронизирован, допускает `null` (1 ключ и много значений), быстрее в однопоточном коде. `Hashtable` синхронизирован на каждом методе, `null` не допускает, считается устаревшим. Для многопоточности обычно выбирают `ConcurrentHashMap`."
    },
    {
      "question": "Чем различаются ArrayList и LinkedList по вставке/удалению, индексации и памяти?",
      "answer": "`ArrayList` хранит элементы в массиве: меньше накладных расходов по памяти и лучше кэш‑локальность. `LinkedList` хранит узлы с ссылками `prev/next`: больше памяти на каждый элемент и хуже локальность; зато операции на концах и удаление по итератору O(1)."
    },
    {
      "question": "Чем ArrayList отличается от LinkedList?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "Чем HashSet концептуально отличается от HashMap?",
      "answer": "`HashMap` хранит пары ключ→значение. `HashSet` хранит только уникальные элементы (по сути, только ключи)."
    },
    {
      "question": "Чем HashSet связан с HashMap?",
      "answer": "`HashSet` обычно реализован через `HashMap`: элемент set хранится как ключ, а значение — фиктивное (одинаковое для всех)."
    },
    {
      "question": "Чем LinkedHashMap отличается от HashMap? Что даёт режим access-order?",
      "answer": "`LinkedHashMap` хранит двусвязный список порядка итерации поверх хеш-таблицы. По умолчанию порядок — вставки; режим `access-order=true` делает порядок по обращениям (get/put) и это удобно для LRU‑кэша (можно переопределить `removeEldestEntry`)."
    },
    {
      "question": "Чем LinkedHashSet/LinkedHashMap отличаются от HashSet/HashMap (порядок итерации)?",
      "answer": "`LinkedHashSet/LinkedHashMap` сохраняют предсказуемый порядок итерации (обычно порядок вставки), в отличие от `HashSet/HashMap` where порядок не гарантирован."
    },
    {
      "question": "Чем List отличается от Set концептуально?",
      "answer": "`List` хранит элементы в порядке и допускает дубликаты; `Set` гарантирует уникальность элементов (по `equals/hashCode` или по компаратору)."
    },
    {
      "question": "Чем List, Set и Queue концептуально отличаются?",
      "answer": "`List` — последовательность с доступом по индексу, допускает дубли. `Set` — множество уникальных элементов. `Queue` — очередь (обычно FIFO) с операциями `offer/poll/peek`; `Deque` — очередь с двух концов."
    },
    {
      "question": "Чем Map отличается от остальных коллекций в общей иерархии?",
      "answer": "`Map` хранит пары ключ→значение и обеспечивает уникальность ключей; остальные коллекции (`List/Set/Queue`) хранят одиночные элементы."
    },
    {
      "question": "Чем TreeSet/TreeMap отличаются от HashSet/HashMap (сортировка, требования к ключам)?",
      "answer": "`TreeSet/TreeMap` — отсортированы (O(log n)), требуют сравнимости; `HashSet/HashMap` — не сортированы (O(1) в среднем), требуют корректного `hashCode/equals`."
    },
    {
      "question": "Что будет, если ключ в HashMap изменился после вставки?",
      "answer": "Если ключ изменился после вставки, запись может стать недоступной: `get/remove` не найдут её, потому что изменился `hashCode`/`equals` и вычислится другой бакет."
    },
    {
      "question": "Что может произойти, если использовать изменяемый (mutable) объект в качестве ключа HashMap?",
      "answer": "Можно получить «потерянную» запись, дубликаты и странное поведение (`containsKey` false, но запись есть). Поэтому ключи должны быть неизменяемыми по полям, участвующим в `equals/hashCode`."
    },
    {
      "question": "Что можно рассказать о HashMap, TreeMap, LinkedHashMap и их основе?",
      "answer": "`HashMap`/`LinkedHashMap` — хеш-таблицы (массив бакетов + цепочки/деревья). `TreeMap` — сбалансированное дерево (красно‑чёрное), поэтому хранит порядок ключей. Выбор: скорость O(1) vs сортировка/диапазонные запросы O(log n) vs порядок вставки."
    },
    {
      "question": "Что происходит при расширении HashMap (rehash)? Как меняются бакеты и элементы?",
      "answer": "При resize `HashMap` увеличивает внутренний массив бакетов (обычно в 2 раза), пересчитывает индексы и перераспределяет элементы по новому размеру. Это дорого (O(n)), поэтому происходит редко — когда size превысил `threshold` (capacity*loadFactor)."
    },
    {
      "question": "Что такое бакеты (buckets) в HashMap и как там хранятся пары ключ-значение?",
      "answer": "Бакет — ячейка массива таблицы в `HashMap`, куда попадают ключи с одинаковым индексом. В бакете хранятся пары ключ→значение как цепочка (список) или дерево при большом числе коллизий."
    },
    {
      "question": "Что такое коллизии в HashMap и как они разрешаются?",
      "answer": "Коллизия — ситуация, когда разные ключи попадают в один бакет (одинаковый индекс). Тогда `HashMap` хранит их вместе и при `get/put` дополнительно сравнивает ключи через `equals` (и может деревьизировать бакет). При коллизии `HashMap` идёт по цепочке/дереву в бакете и ищет ключ по `equals`. Если нашёл — обновляет значение; если нет — добавляет новый элемент."
    },
    {
      "question": "Что такое коллизия в HashMap и что при этом происходит?",
      "answer": "При коллизии `HashMap` идёт по цепочке/дереву в бакете и ищет ключ по `equals`. Если нашёл — обновляет значение; если нет — добавляет новый элемент."
    },
    {
      "question": "Что такое коллизия в HashMap? Как она обрабатывается (список/дерево)? Какие временные сложности операций?",
      "answer": "Коллизия — ситуация, когда разные ключи попадают в один бакет (одинаковый индекс). Тогда `HashMap` хранит их вместе и при `get/put` дополнительно сравнивает ключи через `equals` (и может деревьизировать бакет). При коллизиях цепочка даёт O(k) по размеру бакета; при деревьизации — O(log k). В среднем при хороших хэшах остаётся O(1)."
    },
    {
      "question": "Что такое CopyOnWriteArrayList, когда его применять и каковы его минусы?",
      "answer": "`CopyOnWriteArrayList` хорош, когда очень много чтений/итераций и мало изменений (конфиги, список подписчиков). Итераторы у него «snapshot» и не бросают CME. Минусы: каждая запись/удаление копирует весь массив → дорого по CPU/памяти; не подходит для частых модификаций и больших списков."
    },
    {
      "question": "Что такое fail-fast в коллекциях и когда возникает ConcurrentModificationException?",
      "answer": "Fail-fast — поведение итераторов многих коллекций: если коллекцию структурно изменили во время итерации «не тем способом», итератор бросает `ConcurrentModificationException`. Это раннее обнаружение багов (а не гарантия потокобезопасности)."
    },
    {
      "question": "Что такое fail-fast и как модифицировать коллекцию при итерации, избегая ConcurrentModificationException?",
      "answer": "Чтобы избегать CME: используйте `Iterator.remove()`/`ListIterator`, или `removeIf`, или удаляйте после обхода, или применяйте подходящие concurrent-коллекции."
    },
    {
      "question": "Что такое fail-fast и fail-safe итераторы?",
      "answer": "Fail-fast итераторы быстро падают с `ConcurrentModificationException` при структурной модификации (обычно через `modCount`). Fail-safe (например, у `CopyOnWriteArrayList`) итерируются по снимку (snapshot) и не падают, но могут не видеть свежие изменения."
    },
    {
      "question": "Что такое fail-fast итераторы? Что будет при удалении во время обхода?",
      "answer": "Если удалить элемент во время for-each напрямую через коллекцию, обычно будет `ConcurrentModificationException`. Правильно удалять через `iterator.remove()` или `removeIf`."
    },
    {
      "question": "Что такое fail-fast поведение коллекций и зачем оно нужно?",
      "answer": "Fail-fast нужен, чтобы быстро ловить ошибки модификации коллекции во время обхода и не получать тихо некорректные результаты."
    },
    {
      "question": "Что такое fail-fast при итерации коллекций?",
      "answer": "Fail-fast — поведение итераторов многих коллекций: если коллекцию структурно изменили во время итерации «не тем способом», итератор бросает `ConcurrentModificationException`. Это раннее обнаружение багов (а не гарантия потокобезопасности)."
    },
    {
      "question": "Что такое HashMap и как она устроена на высоком уровне?",
      "answer": "`HashMap` — реализация `Map` на основе хеш-таблицы: хранит пары ключ→значение в массиве бакетов, индекс вычисляется из `hashCode` ключа; коллизии решаются цепочкой/деревом."
    },
    {
      "question": "Что такое HashSet/LinkedHashSet/TreeSet и когда что использовать?",
      "answer": "`HashSet` — когда нужна быстрая проверка наличия и порядок не важен. `LinkedHashSet` — когда нужен порядок вставки. `TreeSet` — когда нужна сортировка и операции O(log n)."
    },
    {
      "question": "Что такое Map? Какие реализации знаешь и чем отличаются (HashMap, LinkedHashMap, TreeMap)?",
      "answer": "`Map` — структура «ключ→значение» с уникальными ключами. Основные реализации: `HashMap` (быстро, без порядка), `LinkedHashMap` (порядок вставки/доступа), `TreeMap` (сортировка по ключам)."
    },
    {
      "question": "Что такое Queue/Deque и какие операции они дают?",
      "answer": "`Queue` — очередь (обычно FIFO): `offer` (добавить), `poll` (взять и удалить), `peek` (посмотреть). `Deque` — двусторонняя очередь: `addFirst/addLast`, `pollFirst/pollLast`, `peekFirst/peekLast`. Типичная реализация — `ArrayDeque` (обычно лучше `LinkedList` для дека)."
    },
    {
      "question": "Что такое TreeMap/TreeSet и зачем нужны Comparator/Comparable?",
      "answer": "`TreeMap/TreeSet` нужны, когда важен отсортированный порядок и операции типа `floor/ceiling/subMap` (у map) — это даёт дерево и O(log n). `Comparator/Comparable` задают порядок элементов."
    },
    {
      "question": "Является ли Map коллекцией и почему?",
      "answer": "`Map` формально не является `Collection`, но предоставляет коллекционные представления: `keySet()` (Set), `values()` (Collection) и `entrySet()` (Set)."
    },
    {
      "question": "ArrayList vs LinkedList: устройство и когда что выбирать?",
      "answer": "`ArrayList` — динамический массив: быстрый доступ по индексу O(1), но вставка/удаление в середине требует сдвигов O(n). `LinkedList` — двусвязный список: доступ по индексу O(n), зато вставка/удаление после найденного узла O(1). На практике чаще выбирают `ArrayList`; `LinkedList` имеет смысл, когда много операций на концах как у `Deque` или когда действительно часто вставляете/удаляете в середине и уже имеете итератор/ссылку на узел."
    },
    {
      "question": "ArrayList: как устроен внутри, как происходит динамическое расширение?",
      "answer": "`ArrayList` хранит элементы в массиве. Когда места не хватает, он увеличивает `capacity` (создаёт новый массив, копирует элементы) и дальше добавляет. Из-за этого `add` в конец обычно O(1), но иногда O(n) при расширении. Можно заранее вызвать `ensureCapacity`, если известен размер."
    },
    {
      "question": "EnumSet: когда применять и чем он эффективен?",
      "answer": "`EnumSet` — специализированный `Set` для enum: внутри обычно битовая маска, поэтому очень быстрый и компактный по памяти. Используйте, когда элементы множества — значения одного enum (например, набор разрешений/флагов)."
    },
    {
      "question": "Hashtable vs HashMap: различия и актуальность в 202x.",
      "answer": "`HashMap` не синхронизирован, допускает `null` (1 ключ и много значений), быстрее в однопоточном коде. `Hashtable` синхронизирован на каждом методе, `null` не допускает, считается устаревшим. Для многопоточности обычно выбирают `ConcurrentHashMap`."
    },
    {
      "question": "LinkedList: структура узла, хранение ссылок, двусвязность.",
      "answer": "`LinkedList` — двусвязный список: каждый узел хранит `item`, `prev`, `next`, а коллекция держит ссылки на `first/last`. Это даёт O(1) операции на концах и O(n) доступ по индексу."
    },
    {
      "question": "Map: зачем интерфейс выделен отдельно от Collection?",
      "answer": "`Map` — не «коллекция элементов одного типа», а отображение «ключ→значение». У него другой контракт: уникальность ключей, операции по ключу, представления `keySet()`, `values()`, `entrySet()`. Поэтому `Map` не наследуется от `Collection`."
    }
  ]
}
