{
  "Дженерики": [
    {
      "question": "В чём различия между Comparable и Comparator? Когда применять каждый из них?",
      "answer": "`Comparable` — «естественный порядок» *внутри* класса: класс реализует `compareTo`, и сортировка знает, как сравнивать элементы без дополнительных настроек.\n`Comparator` — внешний способ сравнения: можно задавать разные варианты сортировки (по имени, по дате, по сумме), комбинировать `thenComparing`, делать `reversed`.\nВыбор: один «естественный» порядок → `Comparable`; несколько вариантов/внешнее сравнение → `Comparator`."
    },
    {
      "question": "Зачем нужны дженерики и почему недостаточно Object? Какие бывают ограничения типов?",
      "answer": "Дженерики нужны для:\n- безопасности типов на этапе компиляции (`List<String>` вместо `List`);\n- уменьшения кастов и ошибок `ClassCastException` в рантайме;\n- более читаемого API.\n`Object` недостаточно, потому что всё превращается в «мешок объектов» и ошибки находятся поздно.\nОграничения (bounds): `T extends X` (верхняя граница — класс/интерфейс), wildcard-границы `? extends` и `? super`."
    },
    {
      "question": "Как дженерики обеспечивают безопасность типов в Java? Что такое дженерики и как именно они это делают?",
      "answer": "Дженерики — параметризация типов: вы говорите компилятору, какие типы допустимы (например, `List<String>`).\nКомпилятор проверяет операции (нельзя положить `Integer` в `List<String>`) и вставляет нужные проверки/касты автоматически.\nВ рантайме параметр типа обычно стирается (type erasure), поэтому главная безопасность — на этапе компиляции."
    },
    {
      "question": "Как интерфейсы Comparable и Comparator реализуют сравнение объектов? В чём их различия и когда какой использовать?",
      "answer": "`Comparable<T>`: метод `int compareTo(T other)` — сравнение «этого» объекта с другим (естественный порядок).\n`Comparator<T>`: метод `int compare(T a, T b)` — отдельная стратегия сравнения двух объектов.\nИспользуйте `Comparable`, если порядок один и логичен для домена; `Comparator`, если вариантов несколько или вы не хотите/не можете менять класс."
    },
    {
      "question": "Чем Java Generics отличаются от C++ templates (в т.ч. стирание типов)?",
      "answer": "В Java дженерики в основном реализованы через *стирание типов* (type erasure): в рантайме нет `List<String>` vs `List<Integer>` — это просто `List`.\nВ C++ templates — генерация кода под конкретные типы (примерно «компиляция разных версий»), типы сохраняются как отдельные специализации.\nСледствия Java: нельзя `new T()`, нельзя создать `new List<String>[...]`, ограничена работа с `instanceof` по параметризованным типам; зато меньше раздувание кода."
    },
    {
      "question": "Можно ли создать массив обобщённого типа? Почему?",
      "answer": "Нельзя создать массив параметризованного типа: `new List<String>[10]` запрещено.\nПричина: массивы в Java ковариантны и проверяют тип в рантайме, а у дженериков тип стирается — это могло бы привести к небезопасным ситуациям.\nОбычно используют `List<List<String>>` или создают массив «сырого» типа/через `@SuppressWarnings`, но лучше избегать."
    },
    {
      "question": "Можно ли создать экземпляр параметрического типа T (например, new T())? Почему?",
      "answer": "Нельзя: `new T()` запрещено, потому что в рантайме из-за type erasure JVM не знает, какой конкретно класс у `T`.\nОбходные пути: передавать `Class<T>` и создавать через reflection (`clazz.getDeclaredConstructor().newInstance()`), или передавать фабрику `Supplier<T>`, или создавать конкретный тип вне дженерика."
    },
    {
      "question": "Объясни принцип PECS (producer-extends, consumer-super). Почему именно так?",
      "answer": "PECS: если параметр *производит* значения типа `T` (мы читаем из него), используем `? extends T`.\nЕсли параметр *потребляет* значения типа `T` (мы кладём в него), используем `? super T`.\nИнтуиция: `extends` гарантирует, что из контейнера можно безопасно получить `T`; `super` гарантирует, что в контейнер можно безопасно положить `T`."
    },
    {
      "question": "Чем отличаются List<? extends T> и List<? super T>? Правило PECS.",
      "answer": "`List<? extends T>`: список некоторого подтипа `T`. Можно безопасно читать элементы как `T`, но нельзя добавлять `T` (кроме `null`), потому что реальный тип может быть `List<SubT>`.\n`List<? super T>`: список некоторого супертипа `T`. Можно безопасно добавлять `T`, но при чтении получаете только `Object` (потому что фактический тип может быть `List<Object>`).\nЭто и есть PECS: producer — extends, consumer — super."
    },
    {
      "question": "Что появляется при стирании типа у ограничений вида T extends … и у wildcard’ов (? extends / ? super)?",
      "answer": "При стирании:\n- `T extends SomeType` стирается до `SomeType` (верхняя граница), поэтому в байткоде `T` ведёт себя как `SomeType`.\n- `T` без границы стирается до `Object`.\n- `? extends X` в рантайме тоже превращается в верхнюю границу `X`.\n- `? super X` стирается до `Object` (верхняя граница у таких wildcard’ов — `Object`)."
    },
    {
      "question": "Что происходит при стирании типов (type erasure) и какие это накладывает ограничения в рантайме?",
      "answer": "Type erasure удаляет информацию о параметрах типов в рантайме: `List<String>` и `List<Integer>` становятся просто `List`.\nОграничения: нельзя узнать `T` в рантайме, нельзя `new T()`, нельзя `instanceof List<String>`, нельзя создать массив параметризованного типа, ограничены проверки типов без передачи `Class<T>`.\nЗато остаётся совместимость со старым байткодом до Java 5."
    },
    {
      "question": "Что такое инвариантность дженериков в Java?",
      "answer": "Инвариантность означает: даже если `Cat extends Animal`, то `List<Cat>` *не является* подтипом `List<Animal>`.\nИначе можно было бы положить `Dog` в `List<Cat>` через ссылку `List<Animal>`, что сломало бы типобезопасность.\nДля «гибкости» используют wildcard’ы: `List<? extends Animal>` или `List<? super Cat>`."
    },
    {
      "question": "Что такое ковариантность/контравариантность для массивов и дженериков?",
      "answer": "Массивы в Java ковариантны: `Cat[]` можно присвоить `Animal[]`, но это может упасть в рантайме (`ArrayStoreException`), если записать туда `Dog`.\nДженерики инвариантны: `List<Cat>` нельзя присвоить `List<Animal>`, поэтому типобезопасность достигается на этапе компиляции.\nВариативность для дженериков задают wildcard’ами: ковариантность — `? extends`, контравариантность — `? super`."
    },
    {
      "question": "Что такое type erasure?",
      "answer": "Type erasure (стирание типов) — механизм реализации дженериков в Java: параметры типов используются компилятором для проверок, но в рантайме стираются до `Object` или до верхней границы (`extends`).\nИз-за этого в рантайме нельзя напрямую работать с `T` как с конкретным типом без дополнительной информации."
    }
  ]
}
