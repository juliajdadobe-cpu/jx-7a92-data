{
  "Исключения": [
    {
      "question": "В чём отличие checked и unchecked исключений?",
      "answer": "Checked (проверяемые) — наследники `Exception`, кроме `RuntimeException`: компилятор требует обработать их (`try/catch`) или объявить в сигнатуре (`throws`).\nUnchecked — `RuntimeException` и его наследники: компилятор не заставляет их ловить/объявлять.\nОбычно checked — про ожидаемые сценарии восстановления, unchecked — про ошибки программирования или состояния, которые сложно/неправильно чинить на месте."
    },
    {
      "question": "В чём разница между Exception и Error?",
      "answer": "`Exception` — исключительные ситуации приложения, которые можно/нужно обрабатывать: например, отсутствие файла, ошибка запроса, ошибка валидации.\n`Error` — серьёзные проблемы JVM/окружения, от которых обычно нельзя корректно восстановиться (например, `OutOfMemoryError`, `StackOverflowError`).\nИх, как правило, не ловят, а дают приложению упасть и лечат причину."
    },
    {
      "question": "В чём разница между throw и throws?",
      "answer": "`throw` — оператор, который бросает конкретное исключение: `throw new IllegalArgumentException(\"...\")`.\n`throws` — часть сигнатуры метода, которая объявляет, какие checked-исключения метод может выбросить: `void f() throws IOException`."
    },
    {
      "question": "Для чего нужен try-with-resources? Что требуется от ресурса?",
      "answer": "`try-with-resources` автоматически закрывает ресурсы после блока `try`, даже если внутри было исключение.\nРесурс должен реализовывать `AutoCloseable` (или `Closeable`) — то есть иметь `close()`.\nЕсли исключение случилось и в теле `try`, и при `close()`, исключение из `close()` попадёт в suppressed (`getSuppressed()`)."
    },
    {
      "question": "Зачем вообще закрывать ресурсы?",
      "answer": "Ресурсы типа файловых дескрипторов, сетевых соединений, JDBC `Connection/Statement/ResultSet` — ограничены на уровне ОС/пула.\nЕсли их не закрывать, возможны утечки: исчерпание дескрипторов/соединений, блокировки, зависания, рост памяти.\nGC не гарантирует своевременное освобождение таких ресурсов, поэтому закрывать нужно явно (лучше через `try-with-resources`)."
    },
    {
      "question": "Иерархия исключений: ключевые базовые классы и практики обработки.",
      "answer": "Верхушка — `Throwable`. От него: `Error` и `Exception`. У `Exception` есть ветка `RuntimeException` (unchecked).\nПрактики:\n- ловить конкретные исключения;\n- не ловить слишком широко (`Exception`/`Throwable`) без причины;\n- не «глотать» исключения;\n- логировать с контекстом;\n- оборачивать низкоуровневые исключения в свои и сохранять причину: `new X(\"...\", e)`."
    },
    {
      "question": "Исключения: checked vs unchecked — различия и когда что использовать?",
      "answer": "Checked — когда вызывающий код реально может и должен отреагировать (восстановиться/выбрать альтернативный сценарий) и это часть контракта метода.\nUnchecked (`RuntimeException`) — когда это ошибка программирования или нарушение инвариантов, которые «на месте» обычно не чинят.\nВо многих приложениях инфраструктурные ошибки (БД/сеть) оборачивают в runtime-исключения и обрабатывают централизованно на верхнем уровне."
    },
    {
      "question": "Как бы ты реализовал унификацию и преобразование checked-исключений JDBC в unchecked (без «магии»)?",
      "answer": "Сделать слой-обёртку над JDBC: ловить `SQLException` и бросать своё `RuntimeException`, сохраняя причину.\nНапример: `catch (SQLException e) { throw new DataAccessException(\"DB error\", e); }`.\nТак сигнатуры методов не «протекают» `throws SQLException`, а обработка делается на уровне сервиса/контроллера (маппинг в ошибку/HTTP-код)."
    },
    {
      "question": "Какие два типа исключений есть в Java?",
      "answer": "Обычно выделяют два типа: checked (проверяемые) и unchecked (непроверяемые).\nНепроверяемые — это `RuntimeException` и `Error` (компилятор не требует их объявлять/ловить)."
    },
    {
      "question": "Какими способами обрабатывать исключения? Можно ли несколько catch?",
      "answer": "Способы:\n- обработать в `try/catch` (восстановиться/понятно сообщить);\n- пробросить выше (`throws` для checked);\n- обернуть в другое исключение (часто в `RuntimeException`).\nНесколько `catch` можно. Порядок важен: сначала более конкретные, потом более общие. В Java есть multi-catch: `catch (A | B e) { ... }`."
    },
    {
      "question": "Когда использовать собственные исключения?",
      "answer": "Когда нужно выразить доменную/бизнес-ошибку своим типом (например, `UserNotFoundException`) или унифицировать ошибки внешних систем (обёртка над `SQLException`, HTTP-клиентом).\nСвой тип помогает: корректно обработать на верхнем уровне (маппинг на HTTP-коды/сообщения), не терять контекст и не смешивать домен с низкоуровневой детализацией."
    },
    {
      "question": "Когда уместно использовать checked-исключения? Приведи бизнес-пример.",
      "answer": "Когда ошибка — ожидаемая часть контракта и вызывающий код обязан решить, что делать дальше.\nПример: чтение конфигурации/файла: вызывающий код может попросить другой путь, повторить попытку, переключиться на дефолтную конфигурацию."
    },
    {
      "question": "Кратко опиши иерархию исключений в Java (Throwable / Error / Exception).",
      "answer": "`Throwable` — всё, что можно бросить/поймать.\nВетки: `Error` (критические проблемы JVM/окружения) и `Exception` (ошибки приложения).\nУ `Exception` есть `RuntimeException` — непроверяемые. Checked — это `Exception` кроме `RuntimeException`."
    },
    {
      "question": "Может ли быть try без catch? Можно ли несколько catch и в каком порядке их располагать?",
      "answer": "`try` может быть без `catch`, если есть `finally` (или `try-with-resources`).\nНесколько `catch` можно; располагать нужно от более конкретных к более общим, иначе будет ошибка компиляции.\nМожно использовать multi-catch: `catch (A | B e)` (если типы не наследуются друг от друга)."
    },
    {
      "question": "Почему обычно не ловят Error?",
      "answer": "Потому что `Error` обычно означает критическое состояние (OOM, переполнение стека и т.п.), и приложение не может гарантированно продолжить работу корректно.\nЛовить `Error` имеет смысл редко — например, чтобы залогировать и корректно завершиться."
    },
    {
      "question": "Почему finally может не выполниться при Error?",
      "answer": "`finally` не выполнится, если JVM аварийно завершилась или поток был насильно остановлен: `System.exit()`, `kill -9`, падение JVM.\nТакже при тяжёлых ошибках (например, сильный OOM) приложение может не иметь ресурсов, чтобы выполнить код корректно.\nВ обычных случаях `finally` всё же выполняется и при `Exception`, и при большинстве `Error`."
    },
    {
      "question": "Чем отличаются checked и unchecked исключения? Зачем Java поддерживает checked?",
      "answer": "Checked требуют явной обработки/проброса и делают контракт метода явным: вызывающий код видит, что может пойти не так.\nUnchecked удобны для ошибок программирования/инвариантов и не «засоряют» сигнатуры.\nИдея checked — заставить не забыть обработать ожидаемые ошибки, но ими важно не злоупотреблять, иначе будет много шаблонного кода."
    },
    {
      "question": "Что делать с checked-исключением, если не хотим try/catch?",
      "answer": "Варианты:\n- объявить `throws` и пробросить выше;\n- обернуть в `RuntimeException`/своё unchecked-исключение;\n- преобразовать в результат (например, `Optional`/объект-результат с ошибкой);\n- использовать фреймворк, который оборачивает сам (например, Spring)."
    },
    {
      "question": "Checked vs Runtime exceptions: когда и какие использовать? Плюсы и минусы подходов.",
      "answer": "Checked: плюс — явный контракт и принуждение к обработке; минус — много шаблонного кода и «протекание» исключений через слои.\nRuntime: плюс — чище сигнатуры и проще прокидывать через слои; минус — проще «забыть» обработку и получить падение выше.\nПрактика: checked — для реально ожидаемых сценариев восстановления; runtime — для нарушений инвариантов/валидации/инфраструктуры с централизованной обработкой."
    }
  ]
}
