{
  "DevOps / Docker / Kubernetes": [
    {
      "question": "Что такое dependency management и как избежать конфликтов версий?",
      "answer": "Dependency management — управление версиями зависимостей (какие библиотеки и в каких версиях попадают в итоговый артефакт).\n\nКонфликты версий возникают из-за транзитивных зависимостей (A тянет B:1.0, C тянет B:2.0).\n\nКак избегать:\n- использовать BOM/управление версиями централизованно,\n- смотреть дерево зависимостей (`mvn dependency:tree`, `gradle dependencies`),\n- фиксировать версии проблемных библиотек,\n- исключать (exclude) нежелательные транзитивные зависимости,\n- держать обновления регулярными."
    },
    {
      "question": "Основные фазы жизненного цикла Maven.",
      "answer": "Основные фазы default lifecycle:\n- `validate`\n- `compile`\n- `test`\n- `package`\n- `verify`\n- `install`\n- `deploy`\n\nЧаще всего в повседневной работе используют `mvn test`, `mvn package`, `mvn install`."
    },
    {
      "question": "Плюсы/минусы Gradle vs Maven.",
      "answer": "Maven:\n+ простая модель, предсказуемые сборки, стандартная структура проекта\n+ огромная экосистема\n- меньше гибкости, XML может быть громоздким\n\nGradle:\n+ быстрее (инкрементальность, кэш), гибче, удобнее для мульти-модулей\n+ Kotlin DSL/ Groovy\n- сложнее, больше возможностей «сделать нестабильно», иногда труднее дебажить билд\n\nВыбор часто зависит от команды и проекта."
    },
    {
      "question": "Какая версия Java сегодня самая популярная в проде?",
      "answer": "Чаще всего в проде встречаются LTS-версии.\n\nИсторически долго доминировала Java 8, затем широко распространилась Java 11, сейчас всё активнее Java 17 (и уже появляется Java 21).\n\nНа собеседовании обычно ожидают ответ: «в проде чаще LTS: 8/11/17 (и постепенно 21)»."
    },
    {
      "question": "Что такое BOM и как им пользоваться?",
      "answer": "BOM (Bill of Materials) — набор согласованных версий зависимостей.\n\nИспользование:\n- в Maven подключают BOM в `dependencyManagement` (например, `spring-boot-dependencies`). Тогда версии многих библиотек можно не указывать.\n- в Gradle подключают platform/enforcedPlatform.\n\nПлюсы: меньше конфликтов версий и проще обновлять стек."
    },
    {
      "question": "package vs install vs deploy — когда что?",
      "answer": "- `package`: собрать артефакт (jar/war) в `target/`.\n- `install`: положить артефакт в локальный Maven-репозиторий (`~/.m2`) для использования другими локальными проектами.\n- `deploy`: загрузить артефакт в удалённый репозиторий (Nexus/Artifactory) для команды/CI."
    },
    {
      "question": "Можно ли собрать приложение как WAR вместо «fat JAR»? Как это настраивается в сборщике?",
      "answer": "Да.\n\nВ Maven обычно:\n- поменять `packaging` на `war`,\n- для Spring Boot: настроить `spring-boot-starter-tomcat` как `provided`,\n- добавить класс-наследник `SpringBootServletInitializer`.\n\nWAR нужен, если деплой в внешний servlet container. Для Docker/K8s чаще используют executable (fat) JAR."
    },
    {
      "question": "В чём различие деплоя приложения в виде JAR и WAR?",
      "answer": "JAR (executable/fat JAR): приложение запускается как отдельный процесс (`java -jar`), часто со встроенным сервером. Удобно для контейнеров.\n\nWAR: артефакт разворачивается во внешний servlet container (например, внешний Tomcat). Контейнер управляет жизненным циклом.\n\nНа практике сегодня чаще деплоят JAR + Docker/Kubernetes."
    },
    {
      "question": "В чём разница команд ADD и COPY в Dockerfile?",
      "answer": "`COPY` просто копирует файлы/папки из контекста сборки.\n\n`ADD` умеет больше:\n- может распаковывать локальные архивы (tar),\n- может скачивать по URL (хотя обычно это не рекомендуют).\n\nРекомендация: по умолчанию использовать `COPY`, а `ADD` — только когда реально нужны его дополнительные возможности."
    },
    {
      "question": "Как располагать команды в Dockerfile, чтобы максимально использовать кэш слоёв?",
      "answer": "Принцип: сначала — то, что меняется редко, потом — то, что меняется часто.\n\nПрактика:\n- сначала копируют файлы зависимостей (`pom.xml`, `build.gradle`), скачивают зависимости,\n- затем копируют исходники.\n\nТак при изменении кода не ломается кэш слоя с зависимостями.\n\nЕщё важно: меньше слоёв с часто меняющимися файлами и аккуратно использовать `.dockerignore`."
    },
    {
      "question": "Как уменьшить размер образа Java-приложения?",
      "answer": "Основные приёмы:\n- multi-stage build (собирать в одном образе, запускать в другом),\n- использовать slim/distroless базовые образы,\n- не тащить build tools в runtime образ,\n- чистить кэш пакетного менеджера,\n- копировать только нужный артефакт,\n- при необходимости сделать jre/jlink (минимальный runtime) для конкретного приложения.\n\nТакже помогает правильный `.dockerignore`."
    },
    {
      "question": "Как упаковываете приложение: Docker→Kubernetes? Что из этого настраиваете сами, что — DevOps?",
      "answer": "Типичный пайплайн:\n- собрать артефакт (JAR),\n- собрать Docker image, запушить в registry,\n- задеплоить в Kubernetes (Deployment/Service/Ingress), настроить конфиг (ConfigMap/Secret), ресурсы, probes.\n\nЧто обычно делает разработчик: Dockerfile, параметры приложения, health endpoints, базовые манифесты/Helm values.\n\nЧто часто делает DevOps: CI/CD, registry, политики, мониторинг, ingress, безопасность, autoscaling, инфраструктура кластера."
    },
    {
      "question": "Какие типичные проблемы и на что обращать внимание при сборке Docker-образа?",
      "answer": "Типичные проблемы:\n- большой размер образа (лишние файлы, зависимости, кэш),\n- плохой кеш (копируют весь проект до скачивания зависимостей),\n- неправильные права/пользователь (запуск под root без нужды),\n- секреты попали в образ (неправильный контекст, нет `.dockerignore`),\n- несовпадение архитектур/Java версии,\n- отсутствие healthcheck/probes.\n\nСмотрю на: размер, слойность, безопасность, скорость сборки и предсказуемость."
    },
    {
      "question": "Почему БД и приложение не кладут в один контейнер?",
      "answer": "Потому что контейнеры должны быть независимыми и масштабируемыми:\n- БД и приложение имеют разные требования к ресурсам/хранению данных,\n- БД требует persistent storage и отдельного управления (backup, репликация),\n- масштабирование приложения и БД — разное,\n- обновления/перезапуски контейнера приложения не должны трогать БД.\n\nВ Kubernetes БД обычно выносят в отдельный StatefulSet/managed сервис."
    },
    {
      "question": "Разница между инструкциями COPY и ADD в Dockerfile?",
      "answer": "`COPY` — простой перенос файлов.\n\n`ADD` — дополнительно может распаковывать tar-архивы и скачивать по URL.\n\nЛучше использовать `COPY` по умолчанию, чтобы Dockerfile был предсказуемым."
    },
    {
      "question": "Разница между Docker image и container.",
      "answer": "Image — неизменяемый шаблон (набор слоёв), из которого создают контейнер.\n\nContainer — запущенный (или остановленный) экземпляр image с собственным writable layer и состоянием.\n\nПроще: image = «класс», container = «объект»."
    },
    {
      "question": "Разница между Dockerfile и docker-compose?",
      "answer": "Dockerfile описывает, как собрать один image.\n\ndocker-compose описывает, как запускать набор контейнеров вместе: сервисы, сети, volume’ы, переменные окружения.\n\nCompose часто используют для локальной разработки, а в проде — оркестраторы вроде Kubernetes."
    },
    {
      "question": "Чем ENTRYPOINT отличается от CMD?",
      "answer": "`ENTRYPOINT` задаёт «основную команду» контейнера.\n\n`CMD` задаёт значения по умолчанию для аргументов команды или команду по умолчанию.\n\nПрактически:\n- `ENTRYPOINT` обычно фиксируют (например, `java`),\n- `CMD` оставляют как настраиваемые аргументы (например, `-jar app.jar`).\n\n`CMD` можно легко переопределить при запуске."
    },
    {
      "question": "Что такое многоэтапная сборка (multi-stage) и зачем она?",
      "answer": "Multi-stage build — когда в Dockerfile несколько `FROM`: в первом этапе собираем артефакт (с Maven/Gradle), во втором — берём только результат (JAR) и запускаем на лёгком runtime образе.\n\nЗачем:\n- меньше итоговый образ,\n- нет build-инструментов в runtime,\n- лучше безопасность и быстрее доставка."
    },
    {
      "question": "Что такое Docker и для чего он используется в разработке/деплое?",
      "answer": "Docker — инструмент для упаковки приложения и его зависимостей в контейнер.\n\nИспользуется для:\n- одинакового окружения локально/в CI/в проде,\n- упрощения деплоя (image в registry → запуск),\n- изоляции процессов,\n- удобной работы с зависимостями (поднять Postgres/Redis локально)."
    },
    {
      "question": "Что такое volume и bind-mount? Когда что использовать?",
      "answer": "Bind-mount — монтирование конкретной папки/файла с хоста в контейнер.\n\nVolume — управляемое Docker хранилище, обычно в специальной директории Docker.\n\nКогда:\n- bind-mount удобен для разработки (код с хоста),\n- volume удобен для данных сервисов (БД), потому что он проще переносится и управляется Docker’ом."
    },
    {
      "question": "Как часто работаешь с Linux и что обычно делаешь?",
      "answer": "Типовые задачи: работать с логами (`journalctl`, `tail`, `grep`), проверять процессы (`ps`, `top`), сеть (`curl`, `netstat/ss`), диски (`df`, `du`), права, переменные окружения.\n\nВ контексте сервисов — диагностика, настройка конфигов, проверка доступности, базовая отладка в контейнерах."
    },
    {
      "question": "Насколько глубоко знаком с Kubernetes ресурсами?",
      "answer": "Базовые ресурсы:\n- `Deployment`, `Pod`, `Service`, `Ingress`,\n- `ConfigMap`, `Secret`,\n- `StatefulSet` для stateful,\n- `Job`/`CronJob`,\n- `HPA` (autoscaling).\n\nТакже важны readiness/liveness probes, requests/limits, namespaces, RBAC.\n\nГлубина зависит от роли, но разработчику важно понимать деплой, конфиг, probes и ресурсы."
    }
  ]
}
