{
  "SQL / Базы данных": [
    {
      "question": "Масштабирование в глубину: зачем и как разбивать таблицы по диапазонам (partitioning) по дате/ключу?",
      "answer": "Партиционирование (partitioning) — это разбиение *одной логической таблицы* на части (партиции) по диапазону/списку/хэшу (в Postgres чаще range по дате).\n\nЗачем:\n- ускорить запросы, которые фильтруют по ключу партиции (работает partition pruning — читаем только нужные партиции),\n- проще управлять данными: быстро удалять старые партиции, хранить «горячие» отдельно.\n\nКак: выбрать ключ (например, `created_at`), определить границы (по дням/месяцам), создать партиционированную таблицу и партиции, настроить индексы и загрузку данных."
    },
    {
      "question": "1NF и 2NF: в чём суть?",
      "answer": "1NF: значения в таблице атомарны (нет массивов/списков в одной ячейке), строки однородные, есть ключ.\n\n2NF: таблица уже в 1NF и все неключевые атрибуты зависят *от всего* составного ключа, а не от его части (нет частичных зависимостей при составном PK).\n\nИдея нормализации — уменьшить дублирование и аномалии обновления."
    },
    {
      "question": "В каких операциях, помимо SELECT, индекс может быть задействован?",
      "answer": "Индекс участвует не только в `SELECT`:\n- `UPDATE`/`DELETE` — чтобы быстро найти строки по условию `WHERE`.\n- `JOIN` — для быстрого поиска соответствий по ключам.\n- `ORDER BY`/`GROUP BY` — иногда можно читать данные уже в нужном порядке.\n- `UNIQUE`/`PRIMARY KEY` — проверка уникальности.\n\nНо индексы также *замедляют* `INSERT/UPDATE/DELETE`, потому что их нужно поддерживать."
    },
    {
      "question": "В чём разница между JOIN и UNION?",
      "answer": "`JOIN` объединяет таблицы *по горизонтали*: увеличивает число столбцов, связывая строки по условию (`ON ...`).\n\n`UNION` объединяет результаты *по вертикали*: склеивает строки из двух запросов с одинаковым набором столбцов. `UNION` удаляет дубликаты, `UNION ALL` — нет."
    },
    {
      "question": "В чём разница репликации и шардинга?",
      "answer": "Репликация — копирование одной и той же базы/таблиц на несколько узлов (обычно: один primary, несколько replicas). Цель: отказоустойчивость и масштабирование чтения.\n\nШардинг — разбиение данных по узлам (каждый хранит *часть* данных). Цель: масштабирование записи/объёма данных.\n\nЧасто используют вместе: каждый шард может иметь свои реплики."
    },
    {
      "question": "Для каких бизнес-сценариев критично соблюдать ACID (например, банковский перевод)?",
      "answer": "ACID критичен там, где нельзя допустить «полу-результат» и важна корректность:\n- финансы: переводы, списания, балансы,\n- биллинг/оплаты/заказы,\n- складские остатки и резервирование,\n- любые операции, где нарушенный инвариант = деньги/потери.\n\nЕсли данные можно согласовывать «в итоге» (eventual consistency), требования к ACID могут быть мягче."
    },
    {
      "question": "Если в запросе участвуют два отдельных индекса — как это отразится на плане? Когда лучше составной индекс?",
      "answer": "Иногда Postgres может использовать *два индекса* через `Bitmap Index Scan` и объединить результаты (`BitmapAnd/BitmapOr`). Это хорошо, когда каждый индекс сильно сокращает выборку.\n\nНо часто лучше составной индекс, если запрос стабильно фильтрует по нескольким колонкам вместе (например, `WHERE a=? AND b=?`) и важен порядок/сортировка.\n\nСоставной индекс особенно полезен, когда один из отдельных индексов мало селективен."
    },
    {
      "question": "Если на таблице много индексов и запрос использует поля из разных индексов — как Postgres выбирает план/индекс?",
      "answer": "Postgres выбирает план по оценке стоимости (cost-based optimizer): сравнивает варианты (seq scan, index scan, bitmap scan, join-стратегии) и выбирает самый дешёвый по статистике.\n\nНа выбор влияет:\n- статистика/селективность (`ANALYZE`),\n- кардинальность, распределение значений,\n- настройки (например, `random_page_cost`),\n- актуальность статистики и корреляция данных.\n\nМного индексов не гарантируют «лучший индекс» — иногда планировщик выберет seq scan."
    },
    {
      "question": "Зачем нужен внешний ключ, если можно делать JOIN без него?",
      "answer": "`FOREIGN KEY` нужен для *целостности данных*: он гарантирует, что ссылка на родительскую запись существует (или задаёт правило при удалении/обновлении).\n\nJOIN можно сделать и без FK, но тогда база не защищает от «битых ссылок», и ошибки легко пропустить.\n\nПлюс FK документирует модель данных и помогает поддерживать корректность при изменениях/миграциях."
    },
    {
      "question": "Зачем нужен FOREIGN KEY, если можно связать таблицы через JOIN?",
      "answer": "JOIN — это способ получить связанные данные в запросе.\n\nFOREIGN KEY — это *ограничение*, которое заставляет данные быть связными всегда: нельзя вставить ссылку на несуществующего родителя, можно настроить `ON DELETE/UPDATE` (CASCADE/RESTRICT/SET NULL).\n\nТо есть JOIN — про чтение, FK — про гарантию корректности при записи."
    },
    {
      "question": "Зачем нужен PRIMARY KEY? Какие ещё задачи он решает, помимо идентификации?",
      "answer": "PRIMARY KEY:\n- гарантирует уникальность и `NOT NULL`,\n- даёт стабильный идентификатор строки,\n- обычно автоматически создаёт индекс (ускоряет поиск и joins),\n- упрощает ссылки (FK), дедупликацию и обновления.\n\nБез PK сложно гарантировать корректные связи и надёжно обновлять «ровно одну» запись."
    },
    {
      "question": "Индексы: виды, когда и куда ставить, составные индексы.",
      "answer": "Основные виды (Postgres):\n- B-Tree — универсальный (=`=`, диапазоны, сортировка), чаще всего.\n- Hash — в основном для равенства (реже используют).\n- GIN/GiST — для массивов, JSONB, полнотекста, гео и т.п.\n- частичные индексы (`WHERE ...`) и выражения (`(lower(email))`).\n\nСтавят индексы на:\n- колонки в `WHERE`, `JOIN ON`, `ORDER BY/GROUP BY` (если реально помогает),\n- ключи уникальности.\n\nСоставной индекс нужен, когда запрос фильтрует по нескольким колонкам вместе и важен порядок колонок."
    },
    {
      "question": "Индексы: по каким полям создавать, когда нужен составной индекс?",
      "answer": "Индекс обычно нужен на поля, по которым часто:\n- фильтруют (`WHERE`),\n- соединяют таблицы (`JOIN`),\n- сортируют (`ORDER BY`) или группируют.\n\nСоставной индекс нужен, если типовой запрос использует несколько условий одновременно (например, `a=? AND b=?`) или сортировку по нескольким полям. Порядок полей в индексе важен: сначала более селективные и/или те, что участвуют в равенстве."
    },
    {
      "question": "Как выбирать поля для индексов? Когда отдельные, когда составные? В чём нюансы порядка полей и селективности?",
      "answer": "Ориентир — реальные запросы и `EXPLAIN`.\n\nОтдельные индексы хорошо работают, когда фильтры используются по отдельности или планировщик может их «склеить» bitmap-сканом.\n\nСоставной индекс лучше, когда почти всегда фильтруют по набору полей вместе.\n\nПорядок полей важен: индекс эффективно использует «левый префикс». Обычно сначала ставят поля с равенством (`=`), затем диапазон (`>`, `<`) и/или сортировку. Селективность — насколько условие «сужает» выборку: чем выше, тем индекс полезнее."
    },
    {
      "question": "Как диагностировать медленные запросы (execution plan)?",
      "answer": "- Снять план: `EXPLAIN` и лучше `EXPLAIN ANALYZE` (реальные времена).\n- Посмотреть, где время: `Seq Scan` на большой таблице, тяжёлые `Nested Loop`, большие sort/hash.\n- Проверить индексы, селективность, статистику (`ANALYZE`).\n- Посмотреть фактические vs оценочные строки (если сильно расходятся — проблемы со статистикой/корреляцией).\n- Проверить блокировки/ожидания и I/O.\n\nПлюс полезны логи медленных запросов и `pg_stat_statements`."
    },
    {
      "question": "Как индексы влияют на вставки/обновления при высокой частоте изменений?",
      "answer": "Каждый `INSERT/UPDATE/DELETE` должен обновить не только таблицу, но и *все индексы*, которые затронуты.\n\nПоэтому много индексов:\n- замедляет запись,\n- увеличивает размер данных и нагрузку на диск,\n- может усиливать блокировки и вакуум.\n\nИндексы нужно держать «по запросам», а не «на всякий случай»."
    },
    {
      "question": "Как на практике решать проблему non-repeatable read / lost update?",
      "answer": "- Поднять уровень изоляции или использовать правильные блокировки.\n\nLost update (потерянное обновление) обычно решают:\n- `SELECT ... FOR UPDATE` (пессимистично),\n- оптимистично: поле версии (`@Version`), проверка `WHERE id=? AND version=?`.\n\nNon-repeatable read решают:\n- `REPEATABLE READ` (снимок данных),\n- или блокировками чтения/записи, если нужно."
    },
    {
      "question": "Как обеспечивать целостность данных: constraints vs triggers?",
      "answer": "Обычно сначала используют constraints (ограничения): `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, `NOT NULL`, `CHECK` — они декларативные, понятные и оптимизируемые.\n\nTriggers (триггеры) нужны, когда логика сложнее и не выражается ограничениями (например, аудит, сложные проверки, синхронизация таблиц). Минус триггеров — скрытая логика, сложнее отлаживать и поддерживать.\n\nПравило: если можно — constraints; триггеры — по необходимости."
    },
    {
      "question": "Как оптимизировать «толстые» запросы при ограниченных ресурсах (батчинг, разбиение и т. п.)?",
      "answer": "Подход:\n- уменьшить объём данных: выбирать только нужные колонки, фильтровать раньше, ограничивать `LIMIT`.\n- правильные индексы под фильтры/джоины.\n- разбивать на батчи (особенно для массовых обновлений/удалений).\n- избегать огромных `OFFSET` (лучше cursor pagination).\n- предварительные агрегации/материализованные представления, если надо.\n- анализ плана (`EXPLAIN ANALYZE`) и устранение узких мест (sort, hash, seq scan)."
    },
    {
      "question": "Как подступиться к медленному запросу в Postgres? Что смотреть сначала?",
      "answer": "Сначала:\n- `EXPLAIN ANALYZE` (факт),\n- какой скан: `Seq Scan` или индекс,\n- оценка vs факт по количеству строк,\n- есть ли сортировка/агрегация на миллионах строк,\n- join-стратегия (`Nested Loop` vs `Hash Join`).\n\nДальше: статистика (`ANALYZE`), индексы, переписывание запроса, параметры (work_mem), блокировки и I/O."
    },
    {
      "question": "Как получить и читать план запроса (EXPLAIN/EXPLAIN ANALYZE)? На что смотреть (seq scan, индексы)?",
      "answer": "`EXPLAIN` показывает план и оценки, `EXPLAIN ANALYZE` — ещё и фактическое выполнение (время/строки).\n\nСмотреть:\n- `Seq Scan` на больших таблицах (часто сигнал, но не всегда плохо),\n- `Index Scan`/`Bitmap Index Scan` — используется ли индекс,\n- фактические строки vs оценка (если сильно отличается — статистика/корреляция),\n- дорогие узлы: сортировки, хеши, nested loop на больших объёмах."
    },
    {
      "question": "Как проверить, использует ли запрос индекс, и почему планировщик мог его не выбрать?",
      "answer": "Проверка: `EXPLAIN (ANALYZE, BUFFERS)` — видно `Index Scan`/`Bitmap Index Scan`.\n\nПочему индекс не выбрали:\n- условие мало селективно (слишком много строк подходит),\n- статистика устарела (`ANALYZE` не запускался),\n- дешевле seq scan (особенно при чтении большой доли таблицы),\n- условие не соответствует индексу (функции без выражения-индекса, не тот порядок полей в составном индексе),\n- параметры конфигурации/кэш/корреляция данных."
    },
    {
      "question": "Как работает уровень SERIALIZABLE в Postgres?",
      "answer": "`SERIALIZABLE` в Postgres реализован через SSI (Serializable Snapshot Isolation): транзакции работают на снимке, но база отслеживает опасные конфликтные шаблоны.\n\nЕсли система обнаруживает, что параллельное выполнение могло бы нарушить сериализуемость, одна из транзакций завершается ошибкой (serialization failure), и её нужно повторить.\n\nПлюс: сильные гарантии. Минус: больше конфликтов/откатов, нужно уметь ретраить."
    },
    {
      "question": "Как реализовать commit/rollback в коде? Когда делать rollback?",
      "answer": "В JDBC:\n- `conn.setAutoCommit(false)`\n- выполнить операции\n- `conn.commit()` при успехе\n- `conn.rollback()` при исключении\n\nRollback делают, когда операция должна быть атомарной, но на середине произошла ошибка/валидация/конфликт. Важно всегда закрывать ресурсы (try-with-resources) и не забывать вернуть autoCommit при переиспользовании соединения."
    },
    {
      "question": "Как реализуешь пагинацию? Какие подходы (offset/limit, slice, cursor) и их trade-off’ы?",
      "answer": "Подходы:\n- `LIMIT/OFFSET` — просто, но большие `OFFSET` медленные и могут «прыгать» при изменении данных.\n- Cursor (keyset) pagination — `WHERE (created_at,id) < (?,?) ORDER BY created_at DESC, id DESC LIMIT N`: быстро и стабильно, но сложнее и требует «курсора».\n- Slice — вариант без общего `count`, просто «есть ли следующая страница».\n\nДля больших таблиц и лент чаще выбирают cursor pagination."
    },
    {
      "question": "Как Postgres оценивает селективность колонок?",
      "answer": "Postgres опирается на статистику, собранную `ANALYZE`: распределение значений, количество уникальных, частоты (histogram, most common values), корреляцию.\n\nСелективность — оценка доли строк, которые пройдут фильтр. Чем точнее статистика, тем лучше план. Если данные сильно изменились — помогает `ANALYZE`/автовакуум."
    },
    {
      "question": "Какая структура данных чаще всего лежит в основе индекса по PK и какова сложность поиска?",
      "answer": "В Postgres индекс по `PRIMARY KEY` обычно B-Tree.\n\nПоиск по B-Tree — `O(log N)` по количеству записей (плюс стоимость чтения страниц с диска/из кэша).\n\nДля равенства и диапазонов B-Tree подходит лучше всего."
    },
    {
      "question": "Какие аномалии изоляции знаешь (грязное чтение, неповторяемое чтение, фантомы, потерянные обновления)? Что такое грязное чтение?",
      "answer": "Аномалии:\n- dirty read (грязное чтение),\n- non-repeatable read (неповторяемое чтение),\n- phantom read (фантомы),\n- lost update (потерянные обновления).\n\nГрязное чтение — когда транзакция читает *незакоммиченные* изменения другой транзакции. Если та откатится — первая увидела «неправду». В Postgres dirty read фактически не допускается."
    },
    {
      "question": "Какие аномалии/проблемы параллельных транзакций бывают?",
      "answer": "Типичные проблемы:\n- dirty read,\n- non-repeatable read,\n- phantom read,\n- lost update,\n- write skew (на snapshot-изоляции),\n- взаимные блокировки (deadlocks) и ожидания блокировок.\n\nКакие возможны — зависит от уровня изоляции и способа блокировок."
    },
    {
      "question": "Какие бывают связи: one-to-one, one-to-many, many-to-many?",
      "answer": "- One-to-one: одной записи A соответствует максимум одна запись B (обычно через `UNIQUE` FK).\n- One-to-many: одной записи A соответствует много B (FK в таблице «many»).\n- Many-to-many: многие A связаны со многими B (обычно через таблицу-связку с двумя FK).\n\nПравильные ограничения (FK/UNIQUE) помогают поддерживать эти связи."
    },
    {
      "question": "Какие виды индексов знаешь (B-Tree, Hash, GIN, GiST, частичные, составные)? Когда применять?",
      "answer": "- B-Tree — универсальный: `=`, диапазоны, сортировка, PK/UK.\n- Hash — в основном `=` (реже нужен).\n- GIN — для множественных значений: массивы, `jsonb`, полнотекст.\n- GiST — геоданные, некоторые типы диапазонов, расширяемые индексы.\n- Частичный (`WHERE ...`) — если запросы всегда по подмножеству строк.\n- Составной — если фильтруем по нескольким полям вместе.\n\nВыбор определяется типом запросов и данными."
    },
    {
      "question": "Какие виды ограничений знаешь (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, DEFAULT)?",
      "answer": "Основные constraints:\n- `PRIMARY KEY` — уникальный идентификатор, не `NULL`.\n- `FOREIGN KEY` — ссылочная целостность.\n- `UNIQUE` — уникальность.\n- `NOT NULL` — запрет `NULL`.\n- `CHECK` — проверка условия.\n- `DEFAULT` — значение по умолчанию.\n\nОни помогают держать данные корректными на уровне БД."
    },
    {
      "question": "Какие ограничения (констрейнты) знаешь: PK, FK, UNIQUE, NOT NULL, CHECK — зачем каждый?",
      "answer": "- PK: уникально идентифицирует строку, ускоряет joins/поиск.\n- FK: запрещает «битые ссылки», задаёт поведение при удалении/обновлении.\n- UNIQUE: предотвращает дубликаты по бизнес-ключу.\n- NOT NULL: фиксирует обязательность значения.\n- CHECK: проверяет доменные правила (например, `amount > 0`).\n\nЭто «первый барьер» качества данных."
    },
    {
      "question": "Какие ограничения (constraints) бывают в БД?",
      "answer": "Чаще всего:\n- `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, `NOT NULL`, `CHECK`, `DEFAULT`.\n\nЕщё бывают `EXCLUDE` (в Postgres) для более сложных ограничений (например, не пересекающиеся интервалы)."
    },
    {
      "question": "Какие сущности/механизмы SQL используешь для обеспечения целостности (constraints, triggers)?",
      "answer": "Для целостности использую:\n- constraints: PK/FK/UNIQUE/NOT NULL/CHECK/DEFAULT,\n- транзакции (атомарность),\n- блокировки при необходимости (`SELECT ... FOR UPDATE`),\n- триггеры — для аудита/сложных правил,\n- уровни изоляции — чтобы предотвратить аномалии.\n\nИдеально, когда правила держатся максимально в БД, а не только в коде."
    },
    {
      "question": "Какие типы констрейнтов в PostgreSQL вы знаете?",
      "answer": "В Postgres есть:\n- `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, `NOT NULL`, `CHECK`, `DEFAULT`,\n- `EXCLUDE` constraint,\n- также ограничения можно делать через уникальные индексы на выражения и частичные индексы.\n\nНа практике чаще всего используются PK/FK/UNIQUE/NOT NULL/CHECK."
    },
    {
      "question": "Какие уровни изоляции знаешь и какие аномалии они предотвращают?",
      "answer": "Классические уровни: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.\n\nГрубо:\n- выше уровень → меньше аномалий, но больше конфликтов/паузы.\n- `READ COMMITTED` предотвращает dirty read.\n- `REPEATABLE READ` предотвращает non-repeatable read (в Postgres — snapshot).\n- `SERIALIZABLE` стремится предотвратить все аномалии, обеспечивая эффект «как будто транзакции шли по очереди»."
    },
    {
      "question": "Какие уровни изоляции транзакций существуют и какие аномалии они предотвращают?",
      "answer": "Уровни: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.\n\nИдея:\n- `READ COMMITTED`: видим только закоммиченные данные, но возможны non-repeatable/phantom.\n- `REPEATABLE READ`: один снимок на транзакцию, меньше «скачков» данных.\n- `SERIALIZABLE`: максимально строгий, предотвращает конфликтные сценарии ценой возможных откатов.\n\nТочные эффекты зависят от конкретной СУБД (в Postgres `READ UNCOMMITTED` ~ `READ COMMITTED`)."
    },
    {
      "question": "Какие феномены возникают: dirty read, non-repeatable read, phantom read, lost update?",
      "answer": "- Dirty read: чтение незакоммиченных данных.\n- Non-repeatable read: повторное чтение той же строки даёт другой результат из-за коммита другой транзакции.\n- Phantom read: при повторном запросе по условию появляется/исчезает набор строк.\n- Lost update: два обновления перезаписывают друг друга, теряется одно из изменений.\n\nУровень изоляции и блокировки определяют, какие из них возможны."
    },
    {
      "question": "Категории SQL: DDL, DML, DCL, TCL — что к чему относится?",
      "answer": "- DDL (Data Definition): `CREATE`, `ALTER`, `DROP` — структура.\n- DML (Data Manipulation): `SELECT`, `INSERT`, `UPDATE`, `DELETE` — данные.\n- DCL (Data Control): `GRANT`, `REVOKE` — права.\n- TCL (Transaction Control): `BEGIN/START TRANSACTION`, `COMMIT`, `ROLLBACK`, `SAVEPOINT` — транзакции."
    },
    {
      "question": "Когда индекс ускорит запрос, а когда навредит? Что такое селективность?",
      "answer": "Индекс ускоряет, когда условие в `WHERE`/`JOIN` сильно уменьшает число строк (высокая селективность), и нужно прочитать маленькую часть таблицы.\n\nНавредит/не поможет, когда:\n- выбираем большую долю таблицы (seq scan дешевле),\n- колонка низкоселективна (например, `is_active` почти у всех),\n- много обновлений (индекс дорог в поддержке).\n\nСелективность — доля строк, подходящих под условие (чем меньше доля, тем лучше для индекса)."
    },
    {
      "question": "Масштабирование БД: репликация vs шардирование — в чём разница и когда применять?",
      "answer": "Репликация: копии данных на нескольких узлах → читаем масштабируемо и повышаем отказоустойчивость.\n\nШардинг: распределяем разные части данных по узлам → масштабируем объём и запись.\n\nКогда:\n- много чтения и нужна HA → репликация.\n- упёрлись в размер/запись на одном узле → шардинг.\n\nКомбинация тоже распространена."
    },
    {
      "question": "Может ли одна транзакция «врываться» в другую?",
      "answer": "Транзакции выполняются параллельно и их операции могут *переплетаться* по времени. Что именно «видно» друг другу — зависит от уровня изоляции.\n\nНапример, при `READ COMMITTED` одна транзакция может увидеть результат другой после её `COMMIT` даже «в середине» своей работы (при следующем запросе).\n\nПри более строгих уровнях (`REPEATABLE READ`) транзакция видит снимок и меньше подвержена таким «вклиниваниям»."
    },
    {
      "question": "Можно ли «заставить» Postgres использовать конкретный индекс для запроса?",
      "answer": "В Postgres нет встроенных «hint’ов» как в некоторых СУБД.\n\nПрактические варианты:\n- переписать запрос (чтобы условие соответствовало индексу),\n- обновить статистику (`ANALYZE`),\n- создать подходящий индекс (составной/частичный/на выражение),\n- для экспериментов можно временно отключать типы сканов (`SET enable_seqscan=off`), но это не решение для продакшена,\n- есть расширение `pg_hint_plan`, если очень нужно."
    },
    {
      "question": "Назови уровни изоляции транзакций. На каких уровнях возможны типичные аномалии?",
      "answer": "Уровни: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.\n\nГрубо:\n- Dirty read возможен только на `READ UNCOMMITTED` (в Postgres фактически нет).\n- Non-repeatable read и phantom возможны на `READ COMMITTED`.\n- На `REPEATABLE READ` меньше «скачков», но возможны конфликтные сценарии типа write skew.\n- `SERIALIZABLE` старается исключить аномалии, но может завершать транзакции с ошибкой и требовать ретрая."
    },
    {
      "question": "Насколько важен порядок полей в составном индексе и почему?",
      "answer": "Очень важен, потому что B-Tree эффективно использует «левый префикс» индекса.\n\nЕсли индекс `(a, b)`, то он отлично помогает для `WHERE a=?` и `WHERE a=? AND b=?`, но *может не помочь* для `WHERE b=?`.\n\nОбычно сначала ставят поля, по которым часто есть `=` и высокая селективность, а затем — поля для диапазонов/сортировки."
    },
    {
      "question": "Нормализация: зачем и когда денормализуют?",
      "answer": "Нормализация уменьшает дублирование и аномалии обновления, делает данные более консистентными.\n\nДенормализация — осознанное добавление дублирования ради производительности/удобства чтения (меньше join’ов, быстрее отчёты).\n\nДенормализуют, когда:\n- есть узкое место по чтению,\n- данные относительно стабильны,\n- есть понятный механизм синхронизации (триггеры, фоновые джобы, materialized views) и вы готовы принять риски рассинхронизации."
    },
    {
      "question": "Объясните различия пессимистических и оптимистических блокировок. Когда что применять?",
      "answer": "Пессимистическая блокировка: «блокируем заранее», чтобы никто параллельно не изменил данные (например, `SELECT ... FOR UPDATE`). Подходит при высокой конкуренции и когда конфликт дорог.\n\nОптимистическая: «не блокируем заранее», но при записи проверяем, что данные не изменились (версия/таймстамп). Если изменились — конфликт и ретрай. Подходит, когда конфликтов мало и важна масштабируемость."
    },
    {
      "question": "Оптимистические vs пессимистические блокировки — в чём разница и где применять?",
      "answer": "Оптимистические: нет блокировки на чтении, конфликт выявляется на записи (через `version`/`@Version`). Хорошо для UI-редактирования, низкой конкуренции.\n\nПессимистические: блокируем записи в БД на время транзакции (`FOR UPDATE`) — хорошо для денег/остатков/высокой конкуренции.\n\nВыбор — по частоте конфликтов и цене ошибки."
    },
    {
      "question": "Перечислите уровни изоляции транзакций и их эффекты (грязное чтение, фантомы и т. п.).",
      "answer": "- `READ UNCOMMITTED`: теоретически возможны dirty reads.\n- `READ COMMITTED`: dirty read нет, но возможны non-repeatable read и phantom.\n- `REPEATABLE READ`: читаем один снимок, нет non-repeatable read; фантомы/конфликты зависят от СУБД (в Postgres snapshot, но возможны write-skew сценарии).\n- `SERIALIZABLE`: эффект как при последовательном выполнении; возможны откаты транзакций из-за конфликтов (нужен ретрай)."
    },
    {
      "question": "Почему в Postgres «грязное чтение» недоступно даже при READ UNCOMMITTED?",
      "answer": "Потому что Postgres использует MVCC (multi-version concurrency control): чтения видят только закоммиченные версии строк (или свой снимок) и не читают незакоммиченные изменения других транзакций.\n\nВ Postgres `READ UNCOMMITTED` фактически работает как `READ COMMITTED`."
    },
    {
      "question": "Почему нельзя повесить индексы на все колонки таблицы? Что произойдёт?",
      "answer": "Можно технически, но это почти всегда плохо:\n- `INSERT/UPDATE/DELETE` сильно замедлятся (нужно обновлять множество индексов),\n- вырастет размер базы и нагрузка на диск/кэш,\n- VACUUM/maintenance станут тяжелее,\n- часть индексов всё равно не будет использоваться.\n\nИндексы должны соответствовать реальным запросам, иначе они только «тормозят» систему."
    },
    {
      "question": "Почему оптимистические блокировки хуже работают при высокой доле записей?",
      "answer": "Потому что при высокой конкуренции конфликты происходят часто: много транзакций завершаются ошибкой версии и требуют повторов.\n\nВ итоге растут ретраи, нагрузка на БД и задержки. В таком сценарии пессимистическая блокировка или другие стратегии (очередь, сериализация по ключу) могут быть стабильнее."
    },
    {
      "question": "Почему HashMap не используют как основной индекс в СУБД и почему чаще выбирают B-tree?",
      "answer": "Хэш-индекс хорошо работает для `=` в памяти, но в СУБД важны:\n- диапазонные запросы (`>`, `<`), сортировка, `ORDER BY`,\n- эффективная работа с диском (страницы),\n- устойчивость и предсказуемость.\n\nB-Tree поддерживает и равенство, и диапазоны, и порядок, поэтому он универсален и чаще используется как базовый индекс."
    },
    {
      "question": "При пессимистичной блокировке что именно блокируется — вся таблица или конкретные записи?",
      "answer": "Обычно блокируются *конкретные строки* (row-level locks), например через `SELECT ... FOR UPDATE`.\n\nБлокировка всей таблицы возможна, но это отдельные механизмы (table-level locks) и применяется реже (DDL, некоторые операции обслуживания).\n\nВажно: даже строковые блокировки могут создавать ожидания и дедлоки при неправильном порядке обновлений."
    },
    {
      "question": "Расскажите про оптимистичные и пессимистичные блокировки: в чём идея и когда что использовать?",
      "answer": "Оптимистичная: предполагаем, что конфликтов мало. Читаем без блокировок, при записи проверяем версию/условие. При конфликте — ошибка и повтор.\n\nПессимистичная: предполагаем, что конфликты вероятны. Блокируем данные заранее и гарантируем, что никто параллельно не изменит их до коммита.\n\nИспользовать:\n- оптимистичную — для редактирования/низкой конкуренции,\n- пессимистичную — для денег/остатков/высокой конкуренции и критичных инвариантов."
    },
    {
      "question": "Реляционные БД: что такое нормализация и денормализация? Когда применять каждую?",
      "answer": "Нормализация — проектирование схемы так, чтобы уменьшить дублирование и зависимости (1NF/2NF/3NF…), снизить аномалии обновления.\n\nДенормализация — намеренное дублирование/агрегация ради скорости чтения.\n\nПрименение:\n- сначала нормализуем, чтобы модель была корректной,\n- денормализуем точечно, когда есть измеренная проблема производительности и понятна стратегия поддержания консистентности."
    },
    {
      "question": "Реляционные vs документные БД: базовые отличия?",
      "answer": "Реляционные БД:\n- таблицы, строгая схема, SQL, сильные транзакции и joins,\n- хорошо для сложных связей и консистентности.\n\nДокументные БД:\n- хранят документы (JSON-подобные), схема гибче,\n- удобно, когда данные «в одном документе» и структура часто меняется,\n- joins обычно слабее/дороже, часто делают вложенность.\n\nВыбор — по модели данных, требованиям к консистентности и запросам."
    },
    {
      "question": "Сработает ли индекс только на city для запроса WHERE city=? AND country=?; а индекс на (country, city) — для запроса только по city?",
      "answer": "Индекс на `city` может помочь для `WHERE city=? AND country=?`: он отфильтрует по city, а country проверится уже по найденным строкам.\n\nСоставной индекс `(country, city)` отлично подходит для `WHERE country=? AND city=?`.\n\nНо для запроса только `WHERE city=?` индекс `(country, city)` обычно *не так полезен*, потому что условие не использует левый префикс (`country`). Поэтому порядок колонок в составном индексе критичен."
    },
    {
      "question": "Уровни изоляции транзакций и какие аномалии они предотвращают?",
      "answer": "Чем выше изоляция, тем меньше аномалий:\n- `READ COMMITTED` предотвращает dirty read.\n- `REPEATABLE READ` предотвращает non-repeatable read (снимок данных на транзакцию).\n- `SERIALIZABLE` предотвращает конфликтные сценарии и даёт эффект последовательного выполнения (но может требовать ретраев).\n\nPhantom/lost update зависят от СУБД и способа обновления (блокировки/версия)."
    },
    {
      "question": "Уровни изоляции транзакций и феномены (dirty/non-repeatable/phantom).",
      "answer": "Феномены:\n- dirty read,\n- non-repeatable read,\n- phantom read.\n\nУровни:\n- `READ COMMITTED`: dirty read нет, но возможны non-repeatable и phantom.\n- `REPEATABLE READ`: меньше «скачков» (один снимок), но конфликтные ситуации всё равно возможны.\n- `SERIALIZABLE`: максимально строгий, стремится исключить феномены ценой возможных откатов."
    },
    {
      "question": "Уровни изоляции транзакций: какие есть?",
      "answer": "Классические уровни изоляции:\n- `READ UNCOMMITTED`\n- `READ COMMITTED`\n- `REPEATABLE READ`\n- `SERIALIZABLE`\n\nВ Postgres `READ UNCOMMITTED` фактически эквивалентен `READ COMMITTED`."
    },
    {
      "question": "Чем отличается EXPLAIN от EXPLAIN ANALYZE?",
      "answer": "`EXPLAIN` показывает план, который *планировщик* собирается использовать, и его оценки (cost/rows).\n\n`EXPLAIN ANALYZE` реально выполняет запрос и показывает *фактические* времена и количество строк на каждом шаге.\n\nДля оптимизации обычно важнее `EXPLAIN ANALYZE`, но его осторожно используют на тяжёлых запросах в проде."
    },
    {
      "question": "Чем ты руководствуешься при создании индексов в БД? Когда нужны составные индексы?",
      "answer": "Руководствуюсь:\n- реальными запросами (лог медленных запросов, `pg_stat_statements`),\n- `EXPLAIN ANALYZE` и статистикой,\n- селективностью и частотой обновлений.\n\nСоставные индексы нужны, когда запросы стабильно фильтруют по нескольким колонкам вместе и/или требуют сортировку по этому набору. Обязательно учитывать порядок колонок (левый префикс)."
    },
    {
      "question": "Что включает первичный ключ? Какие значения недопустимы для PK? Можно ли дубликаты/NULL?",
      "answer": "PRIMARY KEY — это ограничение уникальности + запрет `NULL`.\n\nНедопустимо:\n- `NULL` в любой части PK,\n- дубликаты (две строки с одинаковым PK).\n\nPK может быть составным (несколько колонок), тогда уникальна комбинация значений."
    },
    {
      "question": "Что делать, если в индексируемой колонке очень много NULL? Как это влияет на B-Tree? Как оптимизировать?",
      "answer": "Много `NULL` снижает полезность индекса, если запросы часто ищут `IS NULL`/`IS NOT NULL` или если `NULL` встречается у большинства строк.\n\nОптимизация:\n- частичный индекс, например `CREATE INDEX ... WHERE col IS NOT NULL` (если обычно ищем не-NULL),\n- или отдельный индекс `WHERE col IS NULL`, если часто ищем именно NULL,\n- пересмотреть модель данных (может `NULL` лучше заменить на явное значение/статус).\n\nГлавное — ориентироваться на реальные запросы."
    },
    {
      "question": "Что означает ACID (Atomicity, Consistency, Isolation, Durability)?",
      "answer": "ACID:\n- Atomicity — либо все изменения транзакции применились, либо ни одно.\n- Consistency — транзакция переводит базу из корректного состояния в корректное (инварианты/constraints).\n- Isolation — параллельные транзакции не мешают друг другу (в рамках уровня изоляции).\n- Durability — после `COMMIT` данные не потеряются даже при сбое (за счёт WAL/журнала)."
    },
    {
      "question": "Что произойдёт при удалении записей, связанных внешним ключом (каскады и т.п.)?",
      "answer": "Зависит от правила `ON DELETE` у внешнего ключа:\n- `RESTRICT/NO ACTION` — удалить нельзя, пока есть дочерние записи.\n- `CASCADE` — удалятся и дочерние записи.\n- `SET NULL` — у дочерних FK станет `NULL`.\n- `SET DEFAULT` — у дочерних FK станет значение по умолчанию.\n\nВыбор зависит от бизнес-семантики."
    },
    {
      "question": "Что такое внешний ключ и зачем он, если можно делать JOIN?",
      "answer": "Внешний ключ (FK) — ограничение, которое обеспечивает ссылочную целостность: значение в дочерней таблице должно существовать в родительской (или быть `NULL`, если так разрешено).\n\nJOIN нужен для получения данных, но не гарантирует, что данные корректны.\n\nFK предотвращает «битые ссылки» и задаёт поведение при удалении/обновлении (cascade и т.п.)."
    },
    {
      "question": "Что такое индексы и для чего они нужны?",
      "answer": "Индекс — это дополнительная структура данных, которая ускоряет поиск строк по колонкам (как «указатель» в книге).\n\nНужны для ускорения:\n- `WHERE`, `JOIN`, `ORDER BY`, уникальности.\n\nЦена: занимают место и замедляют изменения данных (`INSERT/UPDATE/DELETE`), потому что индекс надо обновлять."
    },
    {
      "question": "Что такое кластеризованный и некластеризованный индекс? Последствия при изменениях?",
      "answer": "Кластеризованный индекс — когда физический порядок строк на диске соответствует порядку индекса (в некоторых СУБД это «clustered index»).\n\nВ Postgres строгого clustered index «навсегда» нет, но можно выполнить `CLUSTER` по индексу: таблица будет физически переупорядочена, но со временем порядок снова «поплывёт».\n\nНекластеризованный индекс — обычный индекс: хранит ссылки на строки, не меняя физический порядок.\n\nПоследствия: кластеризация может ускорить range-сканы и I/O-локальность, но требует обслуживания и ухудшается при частых изменениях."
    },
    {
      "question": "Что такое оптимистическая (@Version) и пессимистическая блокировки?",
      "answer": "Оптимистическая блокировка (`@Version` в JPA): у записи есть поле версии. При обновлении проверяем, что версия не изменилась. Если изменилась — конфликт и ретрай.\n\nПессимистическая блокировка: блокируем запись в БД на время транзакции (например, `SELECT ... FOR UPDATE`), чтобы никто параллельно не изменил.\n\nОптимистичная лучше при редких конфликтах, пессимистичная — при частых конфликтах/критичных инвариантах."
    },
    {
      "question": "Что такое принципы ACID (атомарность, согласованность, изоляция, долговечность)?",
      "answer": "ACID — набор свойств транзакций:\n- атомарность: всё или ничего,\n- согласованность: инварианты/ограничения соблюдены,\n- изоляция: параллельные транзакции не мешают друг другу в рамках уровня,\n- долговечность: коммит не теряется при сбоях.\n\nЭто база надёжности OLTP-систем."
    },
    {
      "question": "Что такое транзакция и принципы ACID на понятном бизнес-примере?",
      "answer": "Транзакция — набор операций, который выполняется как единое целое.\n\nПример: перевод денег.\n- списать 100 у A,\n- начислить 100 B,\n- записать историю.\n\nACID:\n- Atomicity: либо все три шага применились, либо ни один.\n- Consistency: баланс не становится «кривым».\n- Isolation: параллельные переводы не ломают друг друга.\n- Durability: после `COMMIT` перевод не пропадёт при падении."
    },
    {
      "question": "Что такое COMMIT и ROLLBACK? Зачем транзакции? Что такое ACID?",
      "answer": "`COMMIT` фиксирует изменения транзакции.\n\n`ROLLBACK` откатывает изменения транзакции.\n\nТранзакции нужны, чтобы выполнять несколько операций как единое целое и сохранять корректность при ошибках и параллельной работе.\n\nACID — свойства транзакций: атомарность, согласованность, изоляция, долговечность."
    },
    {
      "question": "Что такое dirty read, non-repeatable read, phantom read, lost update?",
      "answer": "- Dirty read: прочитали незакоммиченные данные другой транзакции.\n- Non-repeatable read: повторное чтение строки дало другой результат.\n- Phantom read: повторный запрос по условию вернул другой набор строк (добавились/исчезли).\n- Lost update: одно обновление затёрло другое, часть изменений потерялась.\n\nИзоляция/блокировки определяют, какие из них возможны."
    },
    {
      "question": "Эволюция схемы БД без простоя: как переименовать колонку пошагово?",
      "answer": "Безопасный подход (zero-downtime) обычно такой:\n1) Добавить новую колонку.\n2) Начать писать данные в обе (dual-write) или настроить триггер.\n3) Мигрировать старые данные батчами.\n4) Переключить чтение приложения на новую колонку.\n5) Удалить старую колонку и триггеры/dual-write.\n\nЕсли СУБД поддерживает быстрый `ALTER TABLE ... RENAME COLUMN` (в Postgres часто это метаданные), можно сделать проще, но нужно учитывать совместимость приложения и миграции."
    },
    {
      "question": "ACID: что означает каждая буква? Зачем уровень изоляции?",
      "answer": "A — Atomicity (всё или ничего),\nC — Consistency (инварианты/ограничения),\nI — Isolation (параллельные транзакции не мешают),\nD — Durability (коммит не теряется).\n\nУровень изоляции нужен, чтобы выбрать баланс между корректностью и производительностью: чем выше изоляция, тем меньше аномалий, но больше блокировок/конфликтов и потенциальных откатов."
    },
    {
      "question": "ACID: что означают свойства и кто их гарантирует?",
      "answer": "Свойства ACID относятся к транзакциям:\n- атомарность и долговечность обеспечиваются механизмами СУБД (WAL/журнал, recovery),\n- изоляция — уровнями изоляции, MVCC и блокировками,\n- согласованность — сочетанием транзакций + constraints + логики приложения.\n\nВ целом гарантии даёт СУБД, но «consistency» часто зависит и от бизнес-правил в коде."
    },
    {
      "question": "Требуется ли совпадение структур таблиц при JOIN?",
      "answer": "Нет. Для `JOIN` не нужно, чтобы структуры таблиц совпадали.\n\nНужно, чтобы выражение `ON` было корректным: типы сравниваемых полей должны быть совместимы (или приводимы), и была логика связи.\n\nСовпадение структуры требуется для `UNION/UNION ALL` (одинаковое число и совместимые типы столбцов)."
    },
    {
      "question": "Что возвращает LEFT JOIN, если в правой таблице нет соответствия?",
      "answer": "`LEFT JOIN` возвращает все строки из левой таблицы.\n\nЕсли соответствия в правой нет, то столбцы правой таблицы в результирующей строке будут `NULL`.\n\nЭто удобно для «взять всё слева и дополнить, если есть данные справа»."
    },
    {
      "question": "Что такое SELECT … FOR UPDATE и когда нужен?",
      "answer": "`SELECT ... FOR UPDATE` берёт блокировку на выбранные строки, чтобы другие транзакции не могли их изменить/заблокировать конфликтно до завершения вашей транзакции.\n\nНужен для пессимистичной синхронизации: деньги, остатки, уникальные ресурсы — когда важно исключить параллельные изменения и предотвратить lost update.\n\nВажно держать транзакцию короткой, иначе будут ожидания и дедлоки."
    },
    {
      "question": "CHAR vs VARCHAR: в чём практическая разница хранения?",
      "answer": "`CHAR(n)` — фиксированная длина: значения дополняются пробелами до `n`.\n\n`VARCHAR(n)` — переменная длина до `n`.\n\nПрактически:\n- для «фиксированных кодов» (`country_code`, `iso_code`) иногда удобен `CHAR`,\n- для обычных строк чаще берут `VARCHAR`/`TEXT`.\n\nВ Postgres различия по производительности обычно небольшие; важнее семантика и ограничения."
    },
    {
      "question": "UNION vs UNION ALL: различия и ограничения (совпадение числа/типа столбцов)?",
      "answer": "`UNION` объединяет результаты и удаляет дубликаты (обычно требует дополнительной сортировки/хеша).\n\n`UNION ALL` просто склеивает результаты и *не убирает* дубликаты — обычно быстрее.\n\nОграничения: обе части должны возвращать одинаковое число столбцов, и типы по позициям должны быть совместимы."
    },
    {
      "question": "WHERE vs HAVING: когда что использовать и почему?",
      "answer": "`WHERE` фильтрует строки *до* группировки (`GROUP BY`).\n\n`HAVING` фильтрует *группы* после `GROUP BY` (обычно по агрегатам: `HAVING count(*) > 10`).\n\nЕсли условие не использует агрегаты — почти всегда лучше `WHERE`, потому что он уменьшит объём данных раньше."
    }
  ]
}
